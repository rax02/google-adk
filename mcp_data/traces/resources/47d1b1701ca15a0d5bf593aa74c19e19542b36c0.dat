(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.oracleMercuryClient = {})));
}(this, (function (exports) { 'use strict';

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (LoggingLevel) {
      LoggingLevel["DEBUG"] = "DEBUG";
      LoggingLevel["WARN"] = "WARN";
      LoggingLevel["ERROR"] = "ERROR";
  })(exports.LoggingLevel || (exports.LoggingLevel = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ChannelDestinationType) {
      /** This is a Resource that can perform actions on the Channel (like an Agent or BOT) */
      ChannelDestinationType["RESOURCE"] = "RESOURCE";
      /** This is Queue :-) */
      ChannelDestinationType["QUEUE"] = "QUEUE";
  })(exports.ChannelDestinationType || (exports.ChannelDestinationType = {}));

  /**
   * An Agent (Resource) specific destination used for Transfer
   */
  var AgentChannelDestination = /** @class */ (function () {
      function AgentChannelDestination() {
          this.destinationType = exports.ChannelDestinationType.RESOURCE;
      }
      return AgentChannelDestination;
  }());

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __values(o) {
      var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
      if (m) return m.call(o);
      return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  var Operation;
  (function (Operation) {
      Operation[Operation["GET"] = 0] = "GET";
      Operation[Operation["PUT"] = 1] = "PUT";
      Operation[Operation["DELETE"] = 2] = "DELETE";
      Operation[Operation["DELETE_BY_FILTER"] = 3] = "DELETE_BY_FILTER";
      Operation[Operation["CLEANUP"] = 4] = "CLEANUP";
      Operation[Operation["GET_ALL"] = 5] = "GET_ALL";
      Operation[Operation["CLEAR"] = 6] = "CLEAR";
  })(Operation || (Operation = {}));
  var ChatIndexedDbManager = /** @class */ (function () {
      function ChatIndexedDbManager() {
          this.init();
      }
      ChatIndexedDbManager.getInstance = function () {
          if (!ChatIndexedDbManager.instance) {
              ChatIndexedDbManager.instance = new ChatIndexedDbManager();
          }
          return ChatIndexedDbManager.instance;
      };
      ChatIndexedDbManager.doOperation = function (idbDatabase, dbRequest) {
          return __awaiter(this, void 0, void 0, function () {
              var transactionMode, schema, objectStore, request_1;
              return __generator(this, function (_a) {
                  try {
                      transactionMode = dbRequest.operation === Operation.GET ? 'readonly' : 'readwrite';
                      if (dbRequest.operation === Operation.CLEANUP) {
                          if (dbRequest.objectStorage) {
                              schema = ChatIndexedDbManager.getSchemaDetails(dbRequest.objectStorage);
                              if (schema) {
                                  return [2 /*return*/, ChatIndexedDbManager.cleanUpStaleDataFromObjectStore(idbDatabase, schema)];
                              }
                          }
                          else {
                              return [2 /*return*/, ChatIndexedDbManager.cleanUpStaleData(idbDatabase)];
                          }
                      }
                      objectStore = idbDatabase
                          .transaction(dbRequest.objectStorage, transactionMode)
                          .objectStore(dbRequest.objectStorage);
                      switch (dbRequest.operation) {
                          case Operation.GET:
                              request_1 = objectStore.get(dbRequest.data);
                              break;
                          case Operation.PUT:
                              request_1 = objectStore.put(dbRequest.data);
                              break;
                          case Operation.DELETE:
                              request_1 = objectStore.delete(dbRequest.data);
                              break;
                          case Operation.GET_ALL:
                              request_1 = objectStore.getAll();
                              break;
                          case Operation.CLEAR:
                              request_1 = objectStore.clear();
                              break;
                          case Operation.DELETE_BY_FILTER:
                              return [2 /*return*/, ChatIndexedDbManager.deleteItemsByFilter(objectStore, dbRequest.filterFunction)];
                          default:
                              break;
                      }
                      return [2 /*return*/, new Promise(function (resolve, reject) {
                              request_1.onsuccess = function (event) {
                                  resolve(event.target.result);
                              };
                              request_1.onerror = function (err) {
                                  reject(err);
                              };
                          })];
                  }
                  catch (err) {
                      console.warn(ChatIndexedDbManager.PRE + " Error adding record in Local DB " + dbRequest.objectStorage);
                      console.warn(err);
                      return [2 /*return*/, Promise.reject(err)];
                  }
                  return [2 /*return*/];
              });
          });
      };
      ChatIndexedDbManager.cleanUpStaleData = function (idbDatabase) {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  ChatIndexedDbManager.IDB_DATABASE_SCHEMA.forEach(function (schema) { return __awaiter(_this, void 0, void 0, function () {
                      return __generator(this, function (_a) {
                          switch (_a.label) {
                              case 0: return [4 /*yield*/, this.cleanUpStaleDataFromObjectStore(idbDatabase, schema)];
                              case 1:
                                  _a.sent();
                                  return [2 /*return*/];
                          }
                      });
                  }); });
                  return [2 /*return*/];
              });
          });
      };
      ChatIndexedDbManager.cleanUpStaleDataFromObjectStore = function (idbDatabase, schema) {
          return __awaiter(this, void 0, void 0, function () {
              var objectStore;
              return __generator(this, function (_a) {
                  if (schema.cleanupFunction) {
                      try {
                          objectStore = idbDatabase
                              .transaction(schema.name, 'readwrite')
                              .objectStore(schema.name);
                          ChatIndexedDbManager.deleteItemsByFilter(objectStore, schema.cleanupFunction);
                      }
                      catch (error) {
                          console.warn(ChatIndexedDbManager.PRE + " Error while stale data cleanup for " + schema.name);
                      }
                  }
                  return [2 /*return*/];
              });
          });
      };
      ChatIndexedDbManager.deleteItemsByFilter = function (objectStore, filterFunction) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (!filterFunction) {
                      console.warn(this.PRE + " missing filter function");
                      return [2 /*return*/, false];
                  }
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          objectStore.openCursor().onsuccess = function (event) {
                              var _a;
                              var cursor = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
                              if (!cursor) {
                                  resolve(true);
                              }
                              else {
                                  if (filterFunction(cursor)) {
                                      cursor.delete();
                                  }
                                  cursor.continue();
                              }
                          };
                          objectStore.openCursor().onerror = function (err) {
                              reject(err);
                          };
                      })];
              });
          });
      };
      ChatIndexedDbManager.upgradeNeeded = function (event) {
          return __awaiter(this, void 0, void 0, function () {
              var request, db_1;
              return __generator(this, function (_a) {
                  console.warn(ChatIndexedDbManager.PRE + " DB Upgrade Started");
                  try {
                      request = event.target;
                      db_1 = request.result;
                      ChatIndexedDbManager.IDB_DATABASE_SCHEMA.forEach(function (schema) {
                          if (!db_1.objectStoreNames.contains(schema.name)) {
                              var objectStore_1 = db_1.createObjectStore(schema.name, { keyPath: schema.key });
                              if (schema.indexes && schema.indexes.length > 0) {
                                  schema.indexes.forEach(function (index) {
                                      objectStore_1.createIndex(index.name, index.name, { unique: index.unique });
                                  });
                              }
                          }
                      });
                      console.warn(ChatIndexedDbManager.PRE + " DB Upgrade Success for");
                      return [2 /*return*/, Promise.resolve(db_1)];
                  }
                  catch (err) {
                      console.warn(ChatIndexedDbManager.PRE + " Error while upgrading DB");
                      console.warn(err);
                      return [2 /*return*/, Promise.reject(err)];
                  }
                  return [2 /*return*/];
              });
          });
      };
      ChatIndexedDbManager.getSchemaDetails = function (objectStore) {
          return ChatIndexedDbManager.IDB_DATABASE_SCHEMA.get(objectStore);
      };
      ChatIndexedDbManager.prototype.performIndexDbOperation = function (dbRequest) {
          return __awaiter(this, void 0, void 0, function () {
              var dbOpenRequest;
              var _this = this;
              return __generator(this, function (_a) {
                  dbOpenRequest = self.indexedDB.open(ChatIndexedDbManager.DB_NAME, ChatIndexedDbManager.DB_VERSION);
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          dbOpenRequest.onsuccess = function (event) { return __awaiter(_this, void 0, void 0, function () {
                              var db, response, err_1;
                              var _a;
                              return __generator(this, function (_b) {
                                  switch (_b.label) {
                                      case 0:
                                          _b.trys.push([0, 2, , 3]);
                                          db = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
                                          return [4 /*yield*/, ChatIndexedDbManager.doOperation(db, dbRequest)];
                                      case 1:
                                          response = _b.sent();
                                          resolve(response);
                                          return [3 /*break*/, 3];
                                      case 2:
                                          err_1 = _b.sent();
                                          reject(err_1);
                                          return [3 /*break*/, 3];
                                      case 3: return [2 /*return*/];
                                  }
                              });
                          }); };
                          dbOpenRequest.onupgradeneeded = function (event) { return __awaiter(_this, void 0, void 0, function () {
                              var err_2;
                              return __generator(this, function (_a) {
                                  switch (_a.label) {
                                      case 0:
                                          _a.trys.push([0, 2, , 3]);
                                          return [4 /*yield*/, ChatIndexedDbManager.upgradeNeeded(event)];
                                      case 1:
                                          _a.sent();
                                          return [3 /*break*/, 3];
                                      case 2:
                                          err_2 = _a.sent();
                                          reject(err_2);
                                          return [3 /*break*/, 3];
                                      case 3: return [2 /*return*/];
                                  }
                              });
                          }); };
                          dbOpenRequest.onerror = function (err) {
                              reject(err);
                          };
                          dbOpenRequest.onblocked = function (err) {
                              reject(err);
                          };
                      })];
              });
          });
      };
      ChatIndexedDbManager.prototype.init = function () {
          // Cleanup for removing stale data
          this.performIndexDbOperation({
              data: '',
              objectStorage: '',
              operation: Operation.CLEANUP,
          });
      };
      ChatIndexedDbManager.PRE = '[ChatIndexedDbManager] ';
      ChatIndexedDbManager.DB_NAME = 'omnichannel-sharedworker';
      ChatIndexedDbManager.DB_VERSION = 3;
      ChatIndexedDbManager.IDB_DATABASE_SCHEMA = new Map([
          ['logger', {
                  cleanupFunction: function (cursor) { var _a; return ((Date.now() - ((_a = cursor.value) === null || _a === void 0 ? void 0 : _a.created)) > 30 * 60 * 1000); },
                  key: 'created',
                  name: 'logger',
              }],
      ]);
      return ChatIndexedDbManager;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  // tslint:disable no-console
  var Logger = /** @class */ (function () {
      function Logger() {
      }
      Logger.setDebugMode = function (debugMode) {
          Logger.debugModeEnabled = debugMode === 'Y';
      };
      Logger.setAppName = function (appName) {
          Logger.appName = appName;
      };
      Logger.getAppName = function () {
          return Logger.appName;
      };
      Logger.disableLoging = function () {
          Logger.disableLogs = true;
      };
      Logger.log = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.level === exports.LoggingLevel.DEBUG) {
              console.log.apply(this, arguments);
          }
          Logger.storeLogsToIndexedDb(args, 'LOG');
      };
      Logger.debug = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.level === exports.LoggingLevel.DEBUG) {
              console.debug.apply(this, arguments);
          }
          Logger.storeLogsToIndexedDb(args, 'DEBUG');
      };
      Logger.warn = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.level === exports.LoggingLevel.WARN || this.level === exports.LoggingLevel.DEBUG) {
              console.warn.apply(this, arguments);
          }
          Logger.storeLogsToIndexedDb(args, 'WARN');
      };
      Logger.error = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.level === exports.LoggingLevel.ERROR || this.level === exports.LoggingLevel.WARN || this.level === exports.LoggingLevel.DEBUG) {
              console.error.apply(this, arguments);
          }
          Logger.storeLogsToIndexedDb(args, 'ERROR');
      };
      Logger.trace = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          console.trace.apply(this, arguments);
      };
      Logger.withoutDB = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (this.level === exports.LoggingLevel.DEBUG) {
              console.log.apply(this, arguments);
          }
      };
      Logger.getChatIndexedDbManager = function () {
          if (!Logger.chatIndexedDbManager) {
              Logger.chatIndexedDbManager = ChatIndexedDbManager.getInstance();
          }
          return Logger.chatIndexedDbManager;
      };
      Logger.storeLogsToIndexedDb = function (message, level) {
          var extraData = [];
          for (var _i = 2; _i < arguments.length; _i++) {
              extraData[_i - 2] = arguments[_i];
          }
          var jsonString = '';
          var messageString = message;
          var app = 'SharedWorker';
          if (!Logger.disableLogs && (level === 'ERROR' || level === 'WARN' || Logger.debugModeEnabled)) {
              try {
                  jsonString = JSON.stringify(extraData);
                  if (typeof message !== 'string' && !(message instanceof String)) {
                      messageString = JSON.stringify(message);
                  }
              }
              catch (e) {
                  jsonString = '';
              }
              var dbRequest = {
                  data: {
                      app: app,
                      created: Date.now(),
                      jsonString: jsonString,
                      level: level,
                      message: messageString,
                      windowName: Logger.appName,
                  },
                  objectStorage: 'logger',
                  operation: Operation.PUT,
              };
              try {
                  Logger.getChatIndexedDbManager().performIndexDbOperation(dbRequest);
              }
              catch (error) {
                  jsonString = '';
              }
          }
      };
      Logger.level = exports.LoggingLevel.ERROR;
      Logger.debugModeEnabled = false;
      Logger.disableLogs = false;
      Logger.appName = 'Client-Lib';
      return Logger;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * A Resource is an entity within the systems that performs duties.
   * A Human is a Resource.  A BOT (automation process) is also a Resource.
   * Essentially it is any entity that can participate within a chhannel
   */
  var Resource = /** @class */ (function () {
      function Resource() {
      }
      /**
       * Reconstruct the Participant object from the json
       * @param json JSON format
       * @returns a Participant Object
       */
      Resource.revive = function (jsonRepresentation) {
          var resource = new Resource();
          resource.identifier = jsonRepresentation.identifier;
          resource.name = jsonRepresentation.name;
          resource.type = jsonRepresentation.type;
          return resource;
      };
      Resource.prototype.toJSON = function () {
          return {
              identifier: this.identifier,
              name: this.name,
              type: this.type,
          };
      };
      return Resource;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ResourceType) {
      ResourceType["HUMAN"] = "HUMAN";
      ResourceType["BOT"] = "BOT";
      ResourceType["END_USER"] = "END_USER";
      ResourceType["AGENT"] = "AGENT";
      ResourceType["SUPERVISOR"] = "SUPERVISOR";
      ResourceType["Agent"] = "AGENT";
      ResourceType["Supervisor"] = "SUPERVISOR";
  })(exports.ResourceType || (exports.ResourceType = {}));

  /**
   * A Resource is an entity within the systems that performs duties
   * A Human is a Resource
   * A automation process (BOT) is a Resource
   * Essentially it is any entity that can participate within a channel
   */
  var HumanResource = /** @class */ (function (_super) {
      __extends(HumanResource, _super);
      function HumanResource() {
          var _this = _super.call(this) || this;
          _this.type = exports.ResourceType.HUMAN;
          return _this;
      }
      HumanResource.prototype.setFirstName = function (value) {
          this.firstName = value;
          this.setName();
      };
      HumanResource.prototype.setLastName = function (value) {
          this.lastName = value;
          this.setName();
      };
      HumanResource.prototype.setName = function () {
          this.name = this.firstName + " " + this.lastName;
      };
      return HumanResource;
  }(Resource));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ParticipationRoleType) {
      /** Unknown role  */
      ParticipationRoleType["UNKNOWN"] = "UNKNOWN";
      /** Consumer or initiator of the Channel */
      ParticipationRoleType["END_USER"] = "END_USER";
      ParticipationRoleType["TRANSIENT"] = "TRANSIENT";
      /** Consumer or initiator of the Channel - From Agent */
      ParticipationRoleType["ENDUSER"] = "END_USER";
      /** The leader of the Channel/Conversation */
      ParticipationRoleType["LEAD"] = "LEAD";
      /** Someone invited into the Channel */
      ParticipationRoleType["CONFEREE"] = "CONFEREE";
      /** Someone who is monitoring the Channel */
      ParticipationRoleType["MONITOR"] = "MONITOR";
      /** Someone who is coaching the Channel */
      ParticipationRoleType["COACH"] = "COACH";
  })(exports.ParticipationRoleType || (exports.ParticipationRoleType = {}));

  /**
   * A Participant is a resource within a channel with a specific role
   */
  var Participant = /** @class */ (function () {
      function Participant(resource) {
          this.isConnected = true;
          this.role = exports.ParticipationRoleType.UNKNOWN;
          this.resource = resource;
          this.identifier = resource.identifier;
          this.name = resource.name ? resource.name : resource.firstName;
      }
      /**
       * Reconstruct the Participant object from the json
       * @param json JSON format
       * @returns a Participant Object
       */
      Participant.revive = function (jsonRepresentation) {
          var resource = Resource.revive(jsonRepresentation.resource);
          var participant = new Participant(resource);
          participant.identifier = jsonRepresentation.identifier;
          participant.isConnected = jsonRepresentation.isConnected;
          participant.role = jsonRepresentation.role;
          return participant;
      };
      Participant.convert = function (participant) {
          var member = new Participant(participant.resource);
          member.resource = participant.resource.toJSON ? participant.resource : Resource.revive(participant.resource);
          member.identifier = participant.identifier;
          member.name = participant.name.trim();
          member.queue = participant.queue;
          member.isConnected = participant.isConnected;
          member.role = participant.role;
          return member;
      };
      Participant.prototype.toJSON = function () {
          var resourceJSON;
          if (this.resource) {
              resourceJSON = this.resource.toJSON();
          }
          return {
              identifier: this.identifier,
              isConnected: this.isConnected,
              name: this.name,
              resource: resourceJSON,
              role: this.role,
          };
      };
      return Participant;
  }());

  var ClientStore = /** @class */ (function () {
      function ClientStore() {
      }
      ClientStore.getListenersCount = function () {
          return ClientStore.listenersCount;
      };
      ClientStore.incrementListenersCount = function () {
          return ClientStore.listenersCount++;
      };
      ClientStore.decrementListenersCount = function () {
          return ClientStore.listenersCount--;
      };
      ClientStore.getClients = function () {
          if (ClientStore.clients.size > 0) {
              return Array.from(ClientStore.clients.values());
          }
          return [];
      };
      ClientStore.addClient = function (clientId, client) {
          ClientStore.clients.set(clientId, { messagePort: client, suspended: false });
      };
      ClientStore.isClientExists = function () {
          return ClientStore.clients.size > 0;
      };
      ClientStore.addClientTab = function (tabId) {
          ClientStore.clientTabIdList.push(tabId);
      };
      ClientStore.isLastTab = function () {
          return ClientStore.clientTabIdList.length <= 1;
      };
      ClientStore.getCommunicationChannelId = function () {
          return ClientStore.communicationChannelId;
      };
      ClientStore.removeClient = function (clientId) {
          if (ClientStore.clients.has(clientId)) {
              ClientStore.clients.delete(clientId);
          }
      };
      ClientStore.hasClientExists = function (clientId) {
          return ClientStore.clients.has(clientId);
      };
      ClientStore.markAsTemporarySuspendedClient = function (clientId) {
          if (ClientStore.clients.has(clientId)) {
              var client = ClientStore.clients.get(clientId);
              client.suspended = true;
              ClientStore.clients.set(clientId, client);
          }
      };
      ClientStore.enableClient = function (clientId) {
          if (ClientStore.clients.has(clientId)) {
              var client = ClientStore.clients.get(clientId);
              client.suspended = false;
              ClientStore.clients.set(clientId, client);
          }
      };
      ClientStore.communicationChannelId = 'tab-' + new Date().getTime();
      ClientStore.clients = new Map();
      ClientStore.clientTabIdList = [];
      ClientStore.listenersCount = 0;
      return ClientStore;
  }());

  var QueueStore = /** @class */ (function () {
      function QueueStore() {
      }
      QueueStore.getQueueName = function (id) {
          var _a;
          return ((_a = this.queuesMap.get(+id)) === null || _a === void 0 ? void 0 : _a.name) || '';
      };
      QueueStore.getQueueById = function (id) {
          return this.queuesMap.get(id);
      };
      QueueStore.getQueueSessionCheck = function (id) {
          var _a;
          return (_a = this.queuesMap.get(+id)) === null || _a === void 0 ? void 0 : _a.transferToQueue.enableSessionCheck;
      };
      QueueStore.populateQueue = function (id, queue) {
          QueueStore.queuesMap.set(id, queue);
      };
      QueueStore.queuesMap = new Map();
      return QueueStore;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
      {
        "queueId": 3,
        "queueIdString": "3",
        "availableAgentSessions": 5,
        "availableAgentSessionsString": "5",
        "totalAvailableAgents": 2,
        "totalUnavailableAgents": 0,
        "totalAgentsRequestingNewEngagement": 2,
        "expectedWaitSeconds": 0,
        "expectedWaitSecondsString": "0",
        "profileIdsList": [
          5
        ],
        "profileIdsStringList": [
          "5"
        ]
      }
  */
  /**
   * A Queue destination used for Transfer
   */
  var QueueChannelDestination = /** @class */ (function () {
      function QueueChannelDestination(localeString) {
          this.localeString = localeString;
          this.destinationType = exports.ChannelDestinationType.QUEUE;
      }
      Object.defineProperty(QueueChannelDestination.prototype, "name", {
          /** Return the name of this destination */
          get: function () {
              var returnedName;
              var keys = Object.keys(this.names);
              if (keys.length === 1) {
                  // just return it
                  returnedName = Object.values(this.names)[0];
              }
              else {
                  // The server sends the language codes in 'java format' i.e. en_us
                  // instead of browser format i.e. en-us We need to normalize
                  var serverFormatLocale = this.localeString.replace('-', '_');
                  // we need to do some fuzzy matching
                  // Is there an exact match?
                  returnedName = this.names[serverFormatLocale];
                  if (!returnedName) {
                      // Need to use fuzzy matching
                      // drop the country from the test and try again
                      var parts = serverFormatLocale.split('_');
                      returnedName = this.names[parts[0]];
                      if (!returnedName) {
                          Logger.error("unable to find locale match with [" + serverFormatLocale + "] and [" + JSON.stringify(this.names) + "]");
                      }
                  }
              }
              return returnedName;
          },
          enumerable: true,
          configurable: true
      });
      QueueChannelDestination.prototype.setNames = function (value) {
          // We need to lower case all the names
          var newNamesObject = {};
          for (var property in value) {
              if (value.hasOwnProperty(property)) {
                  newNamesObject[property.toLowerCase()] = value[property];
              }
          }
          this.names = newNamesObject;
      };
      return QueueChannelDestination;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (AvailabilityType) {
      /** Present BUT NOT available to receive new work */
      AvailabilityType["PRESENT"] = "PRESENT";
      /** Available to receive new work */
      AvailabilityType["Available"] = "Available";
      /** Unavailable to receive new work */
      AvailabilityType["Uavailable"] = "Unavailable";
      // ===========================================
      // The following are required to handle the
      // conversion from OLD capaital format to new
      // ===========================================
      AvailabilityType["AVAILABLE"] = "Available";
      AvailabilityType["UNAVAILABLE"] = "Unavailable";
  })(exports.AvailabilityType || (exports.AvailabilityType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
      "chatSystemError": {
          "errorCondition": "BAD_REQUEST",
          "text": "Failed",
          "type": "MODIFY"
      },
      "clientSendTime": 1580254772697,
      "serviceStartTime": 1580254772743,
      "serviceFinishTime": 1580254772747,
      "sessionId": "142413283500630016",
      "clientId": 3224594173952,            // DO NOT YOU - ONLY USE THE IdString
      "clientIdString": "3224594173952",
      "sequenceNumber": 0,
      "sequenceNumberString": "0"
  }
  */
  var BaseResponse = /** @class */ (function () {
      function BaseResponse() {
      }
      return BaseResponse;
  }());

  /*
  {
    agents: [
      {
        maximumSessionCount: 3,
        currentEngagementCount: 0,
        availableSessionCount: 3,
        numberOfEngagementsInWrapUp: 0,
        clientId: 131,
        clientIdString: '131',
        name: 'Derek',
        accountId: 13,
        accountIdString: '13',
        profileId: 5,
        profileIdString: '5',
        groupId: 100001,
        status: 'AVAILABLE',
        subTypeId: 0,
        mediaList: null
      },
      {
        maximumSessionCount: 3,
        currentEngagementCount: 1,
        availableSessionCount: 2,
        numberOfEngagementsInWrapUp: 0,
        clientId: 132,
        clientIdString: '132',
        name: 'Edward Huth  ;-)',
        accountId: 10,
        accountIdString: '10',
        profileId: 5,
        profileIdString: '5',
        groupId: 100001,
        status: 'AVAILABLE',
        subTypeId: 0,
        mediaList: null
      }
    ],
    clientSendTime: null,
    serviceStartTime: 1553024228122,
    serviceFinishTime: 1553024228125,
    sessionId: 'h2j2fce03xds5rxa9fzava4g',
    clientId: 131,
    clientIdString: '131',
    sequenceNumber: 0,
    sequenceNumberString: '0',
    queues: [
      {
        queueId: 3,
        queueIdString: '3',
        availableAgentSessions: 5,
        availableAgentSessionsString: '5',
        totalAvailableAgents: 2,
        totalUnavailableAgents: 0,
        totalAgentsRequestingNewEngagement: 2,
        expectedWaitSeconds: 0,
        expectedWaitSecondsString: '0',
        profileIdsList: [
          5
        ],
        profileIdsStringList: [
          '5'
        ]
      },
      {
        queueId: 4,
        queueIdString: '4',
        availableAgentSessions: 0,
        availableAgentSessionsString: '0',
        totalAvailableAgents: 0,
        totalUnavailableAgents: 0,
        totalAgentsRequestingNewEngagement: 0,
        expectedWaitSeconds: 0,
        expectedWaitSecondsString: '0',
        profileIdsList: [
          9,
          10,
          11
        ],
        profileIdsStringList: [
          '9',
          '10',
          '11'
        ]
      },
      {
        queueId: 5,
        queueIdString: '5',
        availableAgentSessions: 0,
        availableAgentSessionsString: '0',
        totalAvailableAgents: 0,
        totalUnavailableAgents: 0,
        totalAgentsRequestingNewEngagement: 0,
        expectedWaitSeconds: 0,
        expectedWaitSecondsString: '0',
        profileIdsList: [
          9,
          10,
          11
        ],
        profileIdsStringList: [
          '9',
          '10',
          '11'
        ]
      }
    ]
  }
  */
  /**
   * This class represents the response from
   * the 'assignmentAcknowledgement' request
   */
  var RetrieveAgentsAndQueuesResponse = /** @class */ (function (_super) {
      __extends(RetrieveAgentsAndQueuesResponse, _super);
      function RetrieveAgentsAndQueuesResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new '????????' object
       * @param legacyMessage Legacy Channel
       */
      RetrieveAgentsAndQueuesResponse.convert = function (legacyMessage, localeString) {
          var e_1, _a, e_2, _b;
          var destinations = [];
          try {
              // ==============================
              // Process the Agent Destinations
              // ==============================
              for (var _c = __values(legacyMessage.agents), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var agent = _d.value;
                  var agentDestination = new AgentChannelDestination();
                  agentDestination.identifier = agent.clientIdString;
                  agentDestination.accountId = agent.accountIdString;
                  agentDestination.currentChannelCount = agent.currentEngagementCount;
                  agentDestination.availableCapacity = agent.availableSessionCount;
                  agentDestination.name = agent.name;
                  agentDestination.status = exports.AvailabilityType[agent.status];
                  // Add it to the response
                  destinations.push(agentDestination);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              }
              finally { if (e_1) throw e_1.error; }
          }
          try {
              // ==============================
              // Process the Queue Destinations
              // ==============================
              for (var _e = __values(legacyMessage.queues), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var queue = _f.value;
                  var queueDestination = new QueueChannelDestination(localeString);
                  queueDestination.identifier = queue.queueIdString;
                  queueDestination.names = { 'en_US': QueueStore.getQueueName(queue.queueIdString) };
                  queueDestination.availableCapacity = queue.availableAgentSessions;
                  queueDestination.totalAvailableResources = queue.totalAvailableAgents;
                  queueDestination.totalUnavilableResources = queue.totalUnavailableAgents;
                  queueDestination.expectedWaitSeconds = queue.expectedWaitSeconds;
                  queueDestination.enableSessionCheck = QueueStore.getQueueSessionCheck(queue.queueIdString);
                  queueDestination.profileIds = queue.profileIdsStringList;
                  // Add it to the response
                  if (ClientStore.isClientExists() || QueueStore.getQueueName(queue.queueIdString)) {
                      // Ignoring queue with invalid ids
                      destinations.push(queueDestination);
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
              }
              finally { if (e_2) throw e_2.error; }
          }
          // ===================
          // Return the response
          // ===================
          return destinations;
      };
      RetrieveAgentsAndQueuesResponse.revive = function (destinations) {
          var e_3, _a;
          var _b;
          var revivedDestinations = [];
          try {
              // ==============================
              // Process the Agent Destinations
              // ==============================
              for (var destinations_1 = __values(destinations), destinations_1_1 = destinations_1.next(); !destinations_1_1.done; destinations_1_1 = destinations_1.next()) {
                  var destination = destinations_1_1.value;
                  var agent = destination;
                  if (destination.destinationType === exports.ChannelDestinationType.RESOURCE) {
                      var agentDestination = new AgentChannelDestination();
                      agentDestination.identifier = agent.identifier;
                      agentDestination.accountId = agent.accountId;
                      agentDestination.currentChannelCount = agent.currentChannelCount;
                      agentDestination.availableCapacity = agent.availableCapacity;
                      agentDestination.name = agent.name;
                      agentDestination.status = exports.AvailabilityType[agent.status];
                      // Add it to the response
                      revivedDestinations.push(agentDestination);
                  }
                  else if (destination.destinationType === exports.ChannelDestinationType.QUEUE) {
                      var queue = destination;
                      var queueDestination = new QueueChannelDestination(queue.localeString);
                      queueDestination.identifier = queue.identifier;
                      queueDestination.names = { 'en_US': QueueStore.getQueueName(queue.identifier) };
                      queueDestination.stripeCode = (_b = QueueStore.getQueueById(+queue.identifier)) === null || _b === void 0 ? void 0 : _b.stripeCd;
                      queueDestination.availableCapacity = queue.availableCapacity;
                      queueDestination.totalAvailableResources = queue.totalAvailableResources;
                      queueDestination.totalUnavilableResources = queue.totalUnavilableResources;
                      queueDestination.expectedWaitSeconds = queue.expectedWaitSeconds;
                      queueDestination.enableSessionCheck = QueueStore.getQueueSessionCheck(queue.identifier);
                      queueDestination.profileIds = queue.profileIds;
                      // Add it to the response
                      if (QueueStore.getQueueName(queue.identifier)) {
                          // Ignoring queue with invalid ids
                          revivedDestinations.push(queueDestination);
                      }
                  }
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (destinations_1_1 && !destinations_1_1.done && (_a = destinations_1.return)) _a.call(destinations_1);
              }
              finally { if (e_3) throw e_3.error; }
          }
          return revivedDestinations;
      };
      return RetrieveAgentsAndQueuesResponse;
  }(BaseResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * This class represents the Message object
   * This object contains the data being passed between the members
   * of a Channel
   * The message can be text as well as structured i.e. JSON
   */
  var Message = /** @class */ (function () {
      function Message() {
          this.isAgentsOnly = false;
          this.isFailedToSend = false;
          this.preserve = true;
          this.visibility = [];
          this.messageDataMap = new Map();
          this.richText = false;
          this.allowSuggestions = false;
          this.created = new Date();
      }
      /**
       * Reconstruct the Message object from the json
       * @param json JSON format
       */
      Message.revive = function (jsonRepresentation) {
          var sender = Participant.revive(jsonRepresentation.sender);
          var message = new Message();
          message.body = jsonRepresentation.body;
          message.channelIdentifier = jsonRepresentation.channelIdentifier;
          message.created = new Date(jsonRepresentation.created);
          message.identifier = jsonRepresentation.identifier;
          message.offTheRecord = jsonRepresentation.offTheRecord;
          message.isAgentsOnly = jsonRepresentation.isAgentsOnly;
          message.type = jsonRepresentation.type;
          message.preserve = jsonRepresentation.preserve;
          message.richText = jsonRepresentation.richText;
          message.sender = sender;
          message.type = jsonRepresentation.type;
          message.visibility = jsonRepresentation.visibility;
          message.unique = jsonRepresentation.unique;
          message.isFailedToSend = jsonRepresentation.isFailedToSend;
          message.isAttachment = jsonRepresentation.isAttachment;
          message.allowSuggestions = jsonRepresentation.allowSuggestions || false;
          return message;
      };
      Message.prototype.toJSON = function () {
          var senderJSON;
          if (this.sender) {
              senderJSON = this.sender.toJSON();
          }
          return {
              body: this.body,
              channelIdentifier: this.channelIdentifier,
              created: this.created,
              identifier: this.identifier,
              isAgentsOnly: this.isAgentsOnly,
              isAttachment: this.isAttachment,
              isFailedToSend: this.isFailedToSend,
              messageDataMap: this.messageDataMap,
              offTheRecord: this.offTheRecord,
              preserve: this.preserve,
              richText: this.richText,
              sender: senderJSON,
              type: this.type,
              unique: this.unique,
              visibility: this.visibility,
          };
      };
      Message.prototype.isSender = function (participant) {
          var isSender = false;
          if (this.sender) {
              isSender = this.sender.resource.identifier === participant.identifier;
          }
          return isSender;
      };
      return Message;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (AssignmentType) {
      /** This indicates that the assignment is comes with it ownership or 'lead' of the work */
      AssignmentType["LEAD"] = "LEAD";
      /**  This indicates that the assignment is a transfer of work from some other resource and comes with it ownership of the work */
      AssignmentType["TRANSFER"] = "TRANSFER";
      /**  This indicates that the assignment is a invitation to collaborate on work (Ownership does not come with this) */
      AssignmentType["CONFERENCE"] = "CONFERENCE";
      /**  This indicates that the assignment is a invitation to monitor ongoing work (Ownership does not come with this) */
      AssignmentType["MONITOR"] = "MONITOR";
  })(exports.AssignmentType || (exports.AssignmentType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ChannelContextNameType) {
      /** First Name of the END_USER */
      ChannelContextNameType["FIRST_NAME"] = "firstName";
      /**  Last Name of the END_USER */
      ChannelContextNameType["LAST_NAME"] = "lastName";
      /**  email of the END_USER */
      ChannelContextNameType["EMAIL"] = "emailAddress";
      /**  Question/Problem description  */
      ChannelContextNameType["QUESTION"] = "question";
      /**  Product Id */
      ChannelContextNameType["PRODUCT_ID"] = "productId";
      /**  Product Category Id */
      ChannelContextNameType["CATEGORY_ID"] = "categoryId";
      /**  End-User's contact id */
      ChannelContextNameType["CONTACT_ID"] = "contactId";
      /**  Incident/SR id */
      ChannelContextNameType["INCIDENT_ID"] = "incidentId";
      /**  Locale Specific Queue Name */
      ChannelContextNameType["QUEUE_NAME"] = "QUEUE_NAME";
      /**  All Queue Names */
      ChannelContextNameType["QUEUE_NAMES"] = "QUEUE_NAMES";
      /**  Queue Id */
      ChannelContextNameType["QUEUE_ID"] = "queueId";
      /** Offer expiration time, in seconds */
      ChannelContextNameType["OFFER_TIMEOUT"] = "offerTimeOut";
      /** Engagement Id used by MCA for offer uniqueness */
      ChannelContextNameType["FUSION_ENGAGEMENT_ID"] = "fusionEngagementId";
  })(exports.ChannelContextNameType || (exports.ChannelContextNameType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ChannelStateType) {
      /** Queued, awaiting assignment */
      ChannelStateType["QUEUED"] = "QUEUED";
      /** Currently active */
      ChannelStateType["ACTIVE"] = "ACTIVE";
      /** Concluded but not released */
      ChannelStateType["CONCLUDED"] = "CONCLUDED";
      /** Released/ended */
      ChannelStateType["RELEASED"] = "RELEASED";
  })(exports.ChannelStateType || (exports.ChannelStateType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (MercuryEventType) {
      /** The state of an Offer has changed */
      MercuryEventType["OFFER_STATUS"] = "OFFER_STATUS";
      /** The state of an Offer has changed */
      MercuryEventType["OFFER_STATUS_HISTORY"] = "OFFER_STATUS_HISTORY";
      /** An Offer has been retracted */
      MercuryEventType["OFFER_CANCELLATION"] = "OFFER_CANCELLATION";
      /** An Offer has been retracted */
      MercuryEventType["OFFER_CANCELLATION_HISTORY"] = "OFFER_CANCELLATION_HISTORY";
      /** A Channel has been assigned to the Session */
      MercuryEventType["CHANNEL_ADDED"] = "CHANNEL_ADDED";
      /** A Channel has been removed from the Session */
      MercuryEventType["CHANNEL_REMOVED"] = "CHANNEL_REMOVED";
      /** A Channel has been removed from the Session */
      MercuryEventType["CHANNEL_REMOVED_HISTORY"] = "CHANNEL_REMOVED_HISTORY";
      /** A Work invitation is being offered */
      MercuryEventType["WORK_OFFER"] = "WORK_OFFER";
      /** A Work invitation has previously been offered */
      MercuryEventType["WORK_OFFER_HISTORY"] = "WORK_OFFER_HISTORY";
      /** Availability has changed */
      MercuryEventType["AVAILABILITY_CHANGE"] = "AVAILABILITY_CHANGE";
      // Message Event
      /** A message has arrived on the Channel */
      MercuryEventType["MESSAGE_ADDED"] = "MESSAGE_ADDED";
      /** A message has arrived on the Channel */
      MercuryEventType["MESSAGE_ADDED_HISTORY"] = "MESSAGE_ADDED_HISTORY";
      /** Private message has arrived on the Channel */
      MercuryEventType["PRIVATE_MESSAGE_ADDED"] = "PRIVATE_MESSAGE_ADDED";
      /** A message has been updated */
      MercuryEventType["MESSAGE_UPDATED"] = "MESSAGE_UPDATED";
      /** A message has been removed from the Channel */
      MercuryEventType["MESSAGE_REMOVED"] = "MESSAGE_REMOVED";
      /** A message has failed to send to the Channel */
      MercuryEventType["MESSAGE_FAILED"] = "MESSAGE_FAILED";
      /** A file attachment message has failed to send to the Channel */
      MercuryEventType["ATTACHMENT_MESSAGE_FAILED"] = "ATTACHMENT_MESSAGE_FAILED";
      /** Activity has occurred on the Channel */
      MercuryEventType["ACTIVITY_CHANGE"] = "ACTIVITY_CHANGE";
      // Participation Events
      /** A Participant  has joined the Channel */
      MercuryEventType["MEMBER_JOINED"] = "MEMBER_JOINED";
      /** A Participant has previously joined the Channel */
      MercuryEventType["MEMBER_JOINED_HISTORY"] = "MEMBER_JOINED_HISTORY";
      /** A Participant has left the Channel */
      MercuryEventType["MEMBER_LEFT"] = "MEMBER_LEFT";
      /** A Participant has previously left the Channel */
      MercuryEventType["MEMBER_LEFT_HISTORY"] = "MEMBER_LEFT_HISTORY";
      /** A Participant's details have been updated */
      MercuryEventType["MEMBER_UPDATED"] = "MEMBER_UPDATED";
      /** A Participant's details have been updated */
      MercuryEventType["MEMBER_UPDATED_HISTORY"] = "MEMBER_UPDATED_HISTORY";
      // Control Events
      // used for things like typing started/Ended
      MercuryEventType["CONTROL_MESSAGE"] = "CONTROL_MESSAGE";
      /** An upload process has started.  This will be paired with an UPLOAD_COMPLETE event */
      MercuryEventType["UPLOAD_STATUS"] = "UPLOAD_STATUS";
      /** An upload process has started.  This will be paired with an UPLOAD_COMPLETE event */
      MercuryEventType["UPLOAD_STATUS_HISTORY"] = "UPLOAD_STATUS_HISTORY";
      /** An upload process has completed. */
      MercuryEventType["UPLOAD_COMPLETED"] = "UPLOAD_COMPLETED";
      /** An upload process has completed. */
      MercuryEventType["UPLOAD_COMPLETED_HISTORY"] = "UPLOAD_COMPLETED_HISTORY";
      /** An error has occurred on the connection. */
      MercuryEventType["CONNECTION_ERROR"] = "CONNECTION_ERROR";
      /** Connectivity has been temporarily lost. */
      MercuryEventType["UNSTABLE_CONNECTION"] = "UNSTABLE_CONNECTION";
      /** Connection has been reestablished. */
      MercuryEventType["CONNECTION_ESTABLISHED"] = "CONNECTION_ESTABLISHED";
      /** A change in the participant's role has occurred. */
      MercuryEventType["ROLE_CHANGE"] = "ROLE_CHANGE";
      /** A change in the participant's role has occurred. */
      MercuryEventType["ROLE_CHANGE_HISTORY"] = "ROLE_CHANGE_HISTORY";
      /** A change in the participant's role has occurred. */
      MercuryEventType["LEAD_CHANGE"] = "LEAD_CHANGE";
      /** A change in the participant's role has occurred. */
      MercuryEventType["LEAD_CHANGE_HISTORY"] = "LEAD_CHANGE_HISTORY";
      /** A change in the context has occurred. */
      MercuryEventType["CONTEXT_UPDATE"] = "CONTEXT_UPDATE";
      /** A change in the context has occurred. */
      MercuryEventType["CONTEXT_UPDATE_HISTORY"] = "CONTEXT_UPDATE_HISTORY";
      MercuryEventType["SESSION_CHANGED"] = "SESSION_CHANGED";
      MercuryEventType["NEW_CHANNEL"] = "NEW_CHANNEL";
      MercuryEventType["ACTIVITY_STATUS_CHANGE"] = "ACTIVITY_STATUS_CHANGE";
  })(exports.MercuryEventType || (exports.MercuryEventType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (MessageType) {
      MessageType["TEXT"] = "RICH_TEXT";
      MessageType["STRUCTURED"] = "STRUCTURED";
  })(exports.MessageType || (exports.MessageType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * A Channel is a communication path between resources in the system.
   */
  var Channel = /** @class */ (function () {
      function Channel(sessionToken, identifier) {
          this.members = [];
          this.state = exports.ChannelStateType.ACTIVE; // Default to ACTIVE
          this.context = new Map();
          this.hasLeft = false;
          this.isSupervisor = false;
          this._listeners = new Map();
          this.sessionToken = sessionToken;
          this.identifier = identifier;
      }
      Channel.convert = function (channel) {
          var e_1, _a;
          var newChannel = new Channel(channel.sessionToken, channel.identifier);
          newChannel.state = channel.state;
          newChannel.participationRole = channel.participationRole;
          newChannel.myParticipant = channel.myParticipant;
          newChannel.context = channel.context;
          newChannel.stateListener = channel.stateListener;
          newChannel.hasLeft = channel.hasLeft;
          newChannel.isSupervisor = channel.isSupervisor;
          newChannel.externalIdString = channel.externalIdString;
          newChannel.workTypeCode = channel.workTypeCode;
          newChannel.contactInfo = channel.contactInfo;
          newChannel.fusionChannelId = channel.fusionChannelId;
          newChannel.conversationId = channel.conversationId;
          var members = [];
          try {
              for (var _b = __values(channel.members), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var member = _c.value;
                  var newMember = Participant.convert(member);
                  members.push(newMember);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          newChannel.members = members;
          return newChannel;
      };
      Object.defineProperty(Channel.prototype, "endUsersPresent", {
          /**
           * Detect if a end-user is present
           * @returns all the end-user participants for the channel
           */
          get: function () {
              var endUsers = this.members.filter(function (member) {
                  return member.role === exports.ParticipationRoleType.END_USER && member.isConnected;
              });
              return endUsers;
          },
          enumerable: true,
          configurable: true
      });
      Channel.prototype.connection = function (value) {
          var _this = this;
          this._connection = value;
          // Now register interest on specific messages
          // =============================================
          // Register interest with the _connection Handler
          // =============================================
          var memberJoinedListener = function (incomingEvent, joinedMessage) {
              if (joinedMessage.channelIdentifier === _this.identifier) {
                  _this.handleMemberJoined(incomingEvent, joinedMessage);
              }
          };
          var memberLeftListener = function (incomingEvent, disconnectMessage) {
              if (disconnectMessage.channelIdentifier === _this.identifier) {
                  _this.handleMemberLeft(incomingEvent, disconnectMessage);
              }
          };
          var roleChangeListener = function (incomingEvent, roleChangeMessage) {
              if (roleChangeMessage.channelIdentifier === _this.identifier) {
                  _this.myParticipant.role = roleChangeMessage.role;
              }
          };
          var leadChangeListener = function (incomingEvent, leadChangeMessage) {
              if (_this.identifier === leadChangeMessage.channelIdentifier) {
                  for (var i = 0; i < _this.members.length; i++) {
                      if (_this.members[i].identifier === leadChangeMessage.newLead) {
                          _this.members[i].role = exports.ParticipationRoleType.LEAD;
                      }
                      else if (_this.members[i].identifier === leadChangeMessage.oldLead) {
                          _this.members[i].role = exports.ParticipationRoleType.CONFEREE;
                      }
                  }
              }
          };
          var contextUpdateListener = function (incomingEvent, contextUpdateMessage) {
              if (contextUpdateMessage.channelIdentifier === _this.identifier) {
                  _this.handleContextUpdate(contextUpdateMessage);
              }
          };
          var sessionChangedListener = function (incomingEvent, sessionDetailsMessage) {
              var _a;
              (_a = sessionDetailsMessage.channels) === null || _a === void 0 ? void 0 : _a.forEach(function (channel) {
                  if (_this.identifier === channel.identifier) {
                      _this.sessionToken = sessionDetailsMessage.sessionIdentifier;
                      Logger.log('#### UPDATING Channel session Token IN Channel => ' + channel.identifier + ' : ' + channel.conversationId);
                  }
              });
          };
          var memberUpdatedListener = function (incomingEvent, memberUpdate) {
              var _a;
              if (memberUpdate.channelIdentifier === _this.identifier) {
                  memberUpdate.member.name = (_a = _this.members.find(function (member) {
                      return member.identifier === memberUpdate.member.identifier;
                  })) === null || _a === void 0 ? void 0 : _a.name;
              }
          };
          this.registerConnectionListener(exports.MercuryEventType.MEMBER_JOINED, memberJoinedListener);
          this.registerConnectionListener(exports.MercuryEventType.MEMBER_LEFT, memberLeftListener);
          this.registerConnectionListener(exports.MercuryEventType.ROLE_CHANGE, roleChangeListener);
          this.registerConnectionListener(exports.MercuryEventType.LEAD_CHANGE, leadChangeListener);
          this.registerConnectionListener(exports.MercuryEventType.CONTEXT_UPDATE, contextUpdateListener);
          this.registerConnectionListener(exports.MercuryEventType.SESSION_CHANGED, sessionChangedListener);
          this.registerConnectionListener(exports.MercuryEventType.MEMBER_UPDATED, memberUpdatedListener);
          this._connection.on(exports.MercuryEventType.MEMBER_JOINED, memberJoinedListener, true);
          this._connection.on(exports.MercuryEventType.MEMBER_LEFT, memberLeftListener, true);
          this._connection.on(exports.MercuryEventType.ROLE_CHANGE, roleChangeListener, true);
          this._connection.on(exports.MercuryEventType.LEAD_CHANGE, leadChangeListener, true);
          this._connection.on(exports.MercuryEventType.CONTEXT_UPDATE, contextUpdateListener, true);
          this._connection.on(exports.MercuryEventType.SESSION_CHANGED, sessionChangedListener, true);
          this._connection.on(exports.MercuryEventType.MEMBER_UPDATED, memberUpdatedListener, true);
      };
      /**
       * Allow the caller to register interest in a specific event
       * @param event
       * @param callback
       */
      Channel.prototype.on = function (event, callback) {
          var _this = this;
          Logger.log("Channel: Registering interest in " + event);
          var listeners = this._listeners.get(event);
          if (listeners) {
              var matchingListener = listeners.find(function (listener) { return listener === callback; });
              if (!matchingListener) {
                  // has not been registered already, include this callback for this event
                  listeners.push(callback);
              }
          }
          else {
              // Add an entry
              this._listeners.set(event, [callback]);
              // =============================================
              // Register interest with the _connection Handler
              // =============================================
              var mainEventCallback = function (incomingEvent, message) {
                  _this.mainEventListener(incomingEvent, message);
              };
              this.registerConnectionListener(event, mainEventCallback);
              this._connection.on(event, mainEventCallback);
          }
      };
      /**
       * Allow the caller to unsubscribe from a specific event
       * @param event MercuryEvent
       * @param callback
       */
      Channel.prototype.unsubscribe = function (event, callback) {
          var listeners = this._listeners.get(event);
          if (listeners) {
              // remove this callback from the list
              // tslint:disable-next-line: no-increment-decrement
              for (var i = 0; i < listeners.length; i++) {
                  if (listeners[i] === callback) {
                      Logger.log("Channel: Unsubscribing interest in " + event);
                      listeners.splice(i, 1);
                  }
              }
          }
      };
      /**
       * Send a Message on this Channel with a messageDataMap field.
       * Calls Channel.sendMessage()
       * @param message
       * @param unique unique id of the message
       * @param messageDataMap Map of <String, String>
       * @param visibility array of participant ids
       * @returns a Promise with a string response
       */
      Channel.prototype.sendMessageWithDataMap = function (message, unique, messageDataMap, visibility) {
          if (visibility === void 0) { visibility = []; }
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.sendMessage(message, unique, visibility, messageDataMap)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Send a Message on this Channel
       * @param message
       * @param unique unique id of the message
       * @param visibility array of participant ids
       * @param messageDataMap Map of <String, String>
       * @returns a Promise with a string response
       */
      Channel.prototype.sendMessage = function (message, unique, visibility, messageDataMap) {
          if (visibility === void 0) { visibility = []; }
          if (messageDataMap === void 0) { messageDataMap = new Map(); }
          return __awaiter(this, void 0, void 0, function () {
              var mercuryMessage;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (message === null || message === '') {
                              throw new Error('Message must contain a value');
                          }
                          mercuryMessage = new Message();
                          mercuryMessage.body = message;
                          mercuryMessage.type = exports.MessageType.TEXT;
                          mercuryMessage.unique = unique;
                          mercuryMessage.visibility = visibility;
                          mercuryMessage.messageDataMap = messageDataMap;
                          return [4 /*yield*/, this._connection.sendMessage(this.sessionToken, this.identifier, mercuryMessage)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Send a File attachment on this Channel
       * @param fileAttachmentList
       */
      Channel.prototype.sendAttachment = function (fileAttachmentList) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this._connection.sendAttachment(this.sessionToken, this.identifier, fileAttachmentList)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Update/Set a context entry
       * @param contextItem
       */
      Channel.prototype.setContext = function (contextItem) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (contextItem === null) {
                              throw new Error('Context item must be supplied');
                          }
                          return [4 /*yield*/, this._connection.setContext(this.sessionToken, this.identifier, contextItem)];
                      case 1:
                          _a.sent();
                          if (contextItem.name === exports.ChannelContextNameType.FIRST_NAME || contextItem.name === exports.ChannelContextNameType.LAST_NAME) {
                              this.updateName(contextItem);
                          }
                          else {
                              // We need to update the local copy of the context
                              this.context.set(contextItem.name, contextItem.value);
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Update/Set a context entry
       * @param contextItems
       */
      Channel.prototype.modifyProperties = function (contextItems) {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (contextItems === null) {
                              throw new Error('Context item must be supplied');
                          }
                          return [4 /*yield*/, this._connection.modifyProperties(this.sessionToken, this.identifier, contextItems)];
                      case 1:
                          _a.sent();
                          contextItems.forEach(function (contextItem) {
                              if (contextItem.name === exports.ChannelContextNameType.FIRST_NAME || contextItem.name === exports.ChannelContextNameType.LAST_NAME) {
                                  _this.updateName(contextItem);
                              }
                              else {
                                  // We need to update the local copy of the context
                                  _this.context.set(contextItem.name, contextItem.value);
                              }
                          });
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Set the interaction status of the participant.
       * This sends a signal to all the participants of the current status.
       * Example: LISTENING | RESPONDING
       * @param mode The mode of the interaction
       * @returns a Promise with a 'SUCCESS' response (or error)
       */
      Channel.prototype.setInteractionState = function (mode) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (mode === null) {
                      throw new Error('Mode must contain a value');
                  }
                  return [2 /*return*/, this._connection.setInteractionState(this.sessionToken, this.identifier, mode)];
              });
          });
      };
      /**
       * Accept this Channel assignment
       * @param assignmentType
       * @returns a Promise with a string response
       */
      Channel.prototype.accept = function (assignmentType) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (assignmentType === null || !exports.AssignmentType[assignmentType]) {
                      throw new Error('Assignment type must contain a value');
                  }
                  return [2 /*return*/, this._connection.acceptChannel(this.sessionToken, this.identifier, assignmentType)];
              });
          });
      };
      /**
       * Leave a channel which is a conference
       */
      Channel.prototype.leave = function () {
          return __awaiter(this, void 0, void 0, function () {
              var error_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          _a.trys.push([0, 2, , 3]);
                          return [4 /*yield*/, this._connection.leaveChannel(this.sessionToken, this.identifier)];
                      case 1:
                          _a.sent();
                          this.hasLeft = true;
                          // unsubscribe events with the _connection Handler
                          this.unsubscribeConnectionListeners();
                          // tell anyone listening that we have closed the channel
                          // the session should remove this channel from the channel list
                          if (this.stateListener) {
                              this.stateListener(this.identifier, 'CLOSED');
                          }
                          return [3 /*break*/, 3];
                      case 2:
                          error_1 = _a.sent();
                          Logger.warn("Failed to leave channel [" + this.identifier + "] with response:[" + error_1 + "]");
                          throw error_1;
                      case 3: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Conclude the channel
       * This ends the chat (if it is one)
       */
      Channel.prototype.conclude = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this._connection.concludeChannel(this.sessionToken, this.identifier)];
              });
          });
      };
      /**
       * close the channel
       */
      Channel.prototype.close = function () {
          var _a;
          return __awaiter(this, void 0, void 0, function () {
              var role;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          role = (_a = this.myParticipant) === null || _a === void 0 ? void 0 : _a.role;
                          if (!role) {
                              // We have not been able to locate our participant or role
                              // This has been happening because of LV-12060
                              // Default to LEAD, the server will validate
                              role = exports.ParticipationRoleType.LEAD;
                          }
                          return [4 /*yield*/, this._connection.closeChannel(this.sessionToken, this.identifier, role)];
                      case 1:
                          _b.sent();
                          // ==============================================
                          // unsubscribe events with the _connection Handler
                          // ==============================================
                          this.unsubscribeConnectionListeners();
                          // ============================================================
                          // tell anyone listening that we have closed the channel
                          // the session should remove this channel from the channel list
                          // ============================================================
                          if (this.stateListener) {
                              this.stateListener(this.identifier, 'CLOSED');
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      Channel.prototype.registerStateListener = function (stateListener) {
          this.stateListener = stateListener;
      };
      /**
       * Cancel an Invitation
       * <br>NOTE: This can only be done before the recipient
       * has accepted the offer
       */
      Channel.prototype.cancelInvitation = function (type, recipientId) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (type === null) {
                      throw new Error('Assignment type must contain a value');
                  }
                  if (recipientId === null) {
                      throw new Error('Transfer recipient must contain a value');
                  }
                  return [2 /*return*/, this._connection.cancelInvitation(this.sessionToken, this.identifier, type, recipientId)];
              });
          });
      };
      /**
       * Switch supervisor into the coach role.  Calls v1/coach endpoint.
       */
      Channel.prototype.joinToAssist = function () {
          return __awaiter(this, void 0, void 0, function () {
              var updateNotification;
              return __generator(this, function (_a) {
                  updateNotification = this._connection.joinToAssist(this.sessionToken, this.identifier);
                  this.changeParticipantRoleType(exports.ParticipationRoleType.COACH);
                  return [2 /*return*/, updateNotification];
              });
          });
      };
      /**
       * Switch supervisor into conferee role.  Calls v1/joinChat endpoint.
       */
      Channel.prototype.joinWork = function () {
          return __awaiter(this, void 0, void 0, function () {
              var updateNotification;
              return __generator(this, function (_a) {
                  updateNotification = this._connection.joinWork(this.sessionToken, this.identifier);
                  this.changeParticipantRoleType(exports.ParticipationRoleType.CONFEREE);
                  return [2 /*return*/, updateNotification];
              });
          });
      };
      /**
       * Get the list of destination that can be used in a transfer operation
       * @returns the array of destinations
       */
      Channel.prototype.listTransferDestinations = function () {
          return __awaiter(this, void 0, void 0, function () {
              var destinations;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this._connection.listTransferDestinations(this.sessionToken, this.identifier)];
                      case 1:
                          destinations = _a.sent();
                          if (destinations.length > 0) {
                              destinations = RetrieveAgentsAndQueuesResponse.revive(destinations);
                          }
                          return [2 /*return*/, destinations];
                  }
              });
          });
      };
      /**
       * Transfer a channel
       * @param destination The transfer destination.  Can be a Resource or a Queue
       */
      Channel.prototype.transfer = function (destination) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (destination === null) {
                      throw new Error('Destination type must contain a value');
                  }
                  return [2 /*return*/, this._connection.transferChannel(this.sessionToken, this.identifier, destination)];
              });
          });
      };
      /**
       * Assign a new role to a participant of the channel
       * @param role The participation role being granted
       * @param participant The participant receiving the role
       */
      Channel.prototype.assignRole = function (role, participant) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (role === null) {
                              throw new Error('role must contain a value');
                          }
                          if (participant === null) {
                              throw new Error('participant must contain a value');
                          }
                          return [4 /*yield*/, this._connection.assignRole(this.sessionToken, this.identifier, role, participant)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Conference a Resource into the channel
       * @param invitee The resource you are inviting into the channel
       */
      Channel.prototype.conference = function (invitee) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  if (invitee === null) {
                      throw new Error('Invitee must contain a value');
                  }
                  return [2 /*return*/, this._connection.conference(this.sessionToken, this.identifier, invitee)];
              });
          });
      };
      /**
       * Re-fetch the messages for this channel
       */
      Channel.prototype.refreshMessages = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, this._connection.refreshMessages(this.sessionToken, this.identifier)];
              });
          });
      };
      /**
       * Record my own participant object
       * @param clientIdentifier my identifier
       */
      Channel.prototype.recordMyParticipation = function (clientIdentifier) {
          this.myParticipant = this.findMyParticipant(clientIdentifier);
      };
      /**
       * Change myParticipant ParticipationRoleType and raise an event
       * @param newRole
       */
      Channel.prototype.changeParticipantRoleType = function (newRole) {
          var payload = {
              channelIdentifier: this.identifier,
              role: newRole,
          };
          this._connection.publishEvent(exports.MercuryEventType.ROLE_CHANGE, payload);
      };
      /**
       * Close/Log out of the Channel
       * @param myIdentifier The identifier of the caller (not the Channel identifier)
       * @param forced default false
       */
      /*
      public closeONHOLD(myIdentifier: string, forced = false): Promise<ChannelEnded> {
        return new Promise((resolve, reject) => {
          // Determine my role within the channel
          const myParticipation = this.findMyParticipant(myIdentifier);
    
          switch (myParticipation.role) {
            case ParticipationRole.CONFEREE:
            case ParticipationRole.MONITOR: {
              this.leave()
                .then(response => {
                  Logger.debug(`Left channel [${this.identifier}] successfully`);
                })
                .catch(error => {
                  Logger.warn(`Failed to leave channel [${this.identifier}] with response:[${error}]`);
                });
              break;
            }
            case ParticipationRole.LEAD: {
              return this._connection.leaveChannel(this.sessionToken, this.identifier);
              break;
    
              // THIS IS THE LEGACY CODE FOR THIS ACTION
              case 'LEAD':
                if ((activechats.hasProcessingAgent(engId) || activechats.hasViewingAgent(engId))) {
                  var rsData = activechats.getRemoteSupportInfo(engId);
                  var clientId = activechats.currentChats[engId].clientIdTransferred;
                  if (rsData.hasOwnProperty('assignmentType') && clientId > 0) {
                    function cancelAssignmentInvitationSuccess(response) {
                      response = utilities.convertNumberToString(response);
                      eventcallback.cancelAssignmentInvitationSuccess(evt, response);
                    }
    
                    var assignmentType = rsData.assignmentType === "CONFERENCE" ? 'CONFERENCE' : 'TRANSFER';
                    var evt = {
                      'engagementId': engId,
                      'clientId': clientId,
                      'type': assignmentType
                    };
                    chatservice.postData('cancelAssignmentInvitation', evt,
                    cancelAssignmentInvitationSuccess, eventcallback.failCancelAssignmentInvitation);
                  }
                }
                break;
            }
          }
        });
      }
      */
      /**
       * Register connection listeners
       *
       * @param event Event to register a listener for
       * @param callback The callback to execute in case the event gets fired
       */
      Channel.prototype.registerConnectionListener = function (event, callback) {
          var connectionListeners = Channel._connectionListeners.get(event + "_" + this.identifier);
          if (connectionListeners) {
              var matchingListener = connectionListeners.find(function (listener) { return listener === callback; });
              if (!matchingListener) {
                  // has not been registered already, include this callback for this event
                  connectionListeners.push(callback);
              }
          }
          else {
              Channel._connectionListeners.set(event + "_" + this.identifier, [callback]);
          }
      };
      /**
       * Unsubscribe all connection listeners for the current channel
       */
      Channel.prototype.unsubscribeConnectionListeners = function () {
          var _this = this;
          Object.values(exports.MercuryEventType).forEach(function (mercuryEventType) {
              var eventListeners = Channel._connectionListeners.get(mercuryEventType + "_" + _this.identifier);
              if (eventListeners) {
                  eventListeners.forEach(function (callback) {
                      _this._connection.unsubscribe(mercuryEventType, callback);
                  });
                  Channel._connectionListeners.delete(mercuryEventType + "_" + _this.identifier);
              }
          });
      };
      Channel.prototype.updateName = function (contextItem) {
          // Now, IF the name context has changed, we need to update the end-user.
          // While we only support a single end-user, this operation will be fine, BUT if we ever support
          // multiple end-users we will need to change the approach
          var endUsers = this.endUsersPresent;
          if (endUsers && endUsers.length === 1) {
              var endUser = endUsers[0];
              var human = new HumanResource();
              Object.assign(human, endUser.resource);
              if (contextItem.name === exports.ChannelContextNameType.FIRST_NAME) {
                  human.setFirstName(contextItem.value);
              }
              else if (contextItem.name === exports.ChannelContextNameType.LAST_NAME) {
                  human.setLastName(contextItem.value);
              }
              Logger.log("new name is: [" + human.name + "]");
              endUser.resource = human;
          }
          else {
              Logger.error("Unable to update the end-user name because we have [" + endUsers.length + "] end users");
          }
      };
      /**
       * Listener for all registered events
       * @param incomingEvent
       * @param message
       */
      Channel.prototype.mainEventListener = function (incomingEvent, message) {
          // ==============================================
          // We need to filter the messages so that we only
          // process messages for this channel/engagement
          // ==============================================
          var e_2, _a;
          if (message.channelIdentifier === this.identifier) {
              // It's a message for this channel
              // Get the callbacks
              var callbacks = this._listeners.get(incomingEvent);
              try {
                  for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
                      var listener = callbacks_1_1.value;
                      listener(incomingEvent, message);
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
      };
      /**
       * Find my participation within this Channel
       * @param clientIdentifier My Identifier
       */
      Channel.prototype.findMyParticipant = function (clientIdentifier) {
          var me = this.members.find(function (member) { return member.resource.identifier === clientIdentifier; });
          return me;
      };
      /**
       * If someone joins who is a LEAD, make the current participant a CONFEREE
       * @param incomingEvent
       * @param joinedMessage
       */
      Channel.prototype.handleMemberJoined = function (incomingEvent, joinedMessage) {
          // Update role or add them to the member's list if they are not already there
          var isNewMember = true;
          for (var i = 0; i < this.members.length; i++) {
              if (this.members[i].identifier === joinedMessage.participant.identifier) {
                  this.members[i].role = joinedMessage.participant.role;
                  this.members[i].isConnected = true;
                  isNewMember = false;
                  break;
              }
          }
          if (isNewMember) {
              // we need to add them to the member list
              var newMember = Participant.convert(joinedMessage.participant);
              this.members.push(newMember);
          }
          // ==============================
          // Now check my leadership status
          // ==============================
          var sendEvent = false;
          if (this.isSupervisor) {
              return;
          }
          else if (joinedMessage.participant.role === exports.ParticipationRoleType.LEAD) {
              var myNewRole = void 0;
              if (joinedMessage.participant.identifier === this.myParticipant.identifier) {
                  // I am now the lead
                  myNewRole = exports.ParticipationRoleType.LEAD;
              }
              else {
                  // I'm now a conferee
                  myNewRole = exports.ParticipationRoleType.CONFEREE;
              }
              this.myParticipant.role = myNewRole;
              sendEvent = true;
          }
          else if (joinedMessage.participant.identifier === this.myParticipant.identifier) {
              // Case where I was previously the Lead on a Chat and was conferenced back in
              this.myParticipant.role = exports.ParticipationRoleType.CONFEREE;
              sendEvent = true;
          }
          if (sendEvent) {
              // Raise an event telling people of the change
              var payload = {
                  channelIdentifier: joinedMessage.channelIdentifier,
                  role: this.myParticipant.role,
              };
              this._connection.publishEvent(exports.MercuryEventType.ROLE_CHANGE, payload);
          }
      };
      /**
       * Process MEMBER_LEFT messages
       * @param incomingEvent
       * @param message
       */
      Channel.prototype.handleMemberLeft = function (incomingEvent, disconnectMessage) {
          // ==================================================
          // We need to remove the participant from the channel
          // ==================================================
          var disconnectingMember = this.members.find(function (member) { return member.resource.identifier === disconnectMessage.member.resource.identifier; });
          if (!disconnectingMember) {
              Logger.error("LOGIC ERROR: disconnecting member " + disconnectMessage.member.resource.identifier + " not found in channel member list " + JSON.stringify(this.members));
          }
          else {
              // =====================================================
              // Now check that it is not ME - I can have > 1 sessions
              // =====================================================
              if (disconnectingMember === this.myParticipant) {
                  // It's me, I left the chat in the other session.
                  // The APP using the library will need to dispose of the channel
                  Logger.debug('Received disconnect message for myself - another session?');
              }
              // Mark them as disconnected
              disconnectingMember.isConnected = false;
          }
      };
      /**
       * Process the  context updates
       * @param contextUpdate
       */
      Channel.prototype.handleContextUpdate = function (contextUpdate) {
          // We need to update the context map
          if (this.context.has(contextUpdate.name)) {
              this.context.set(contextUpdate.name, contextUpdate.value);
          }
          else {
              // might be one of the custom fields
              var customFields = this.context.get('customFields');
              if (customFields) {
                  var foundItem = customFields === null || customFields === void 0 ? void 0 : customFields.find(function (field) { return field.name === contextUpdate.name; });
                  if (foundItem) {
                      // we need to update it
                      foundItem.value = contextUpdate.value;
                  }
                  else {
                      // We need to add it
                      customFields.push({ name: contextUpdate.name, value: contextUpdate.value });
                  }
              }
          }
          // Now update the end user's name
          var endUser;
          var endUsers = this.endUsersPresent;
          if (endUsers.length > 0) {
              endUser = endUsers[0].resource; // We only support 1 single end user at the moment
          }
          if (contextUpdate.name === exports.ChannelContextNameType.FIRST_NAME && endUser) {
              endUser.setFirstName(contextUpdate.value);
          }
          else if (contextUpdate.name === exports.ChannelContextNameType.LAST_NAME && endUser) {
              endUser.setLastName(contextUpdate.value);
          }
      };
      Channel._connectionListeners = new Map();
      return Channel;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
    "engagementId": 33,
    "name": "CONTACT_ID",
    "type": "ENGAGEMENT",
    "value": 17,
    "sequenceNumber": 68
  }
  */
  /**
   * This class represents the Channel Context Item details
   */
  var ChannelContextItem = /** @class */ (function () {
      function ChannelContextItem() {
          /** The type of the context item */
          this.type = 'ENGAGEMENT';
      }
      return ChannelContextItem;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  function setPool(pool) {
      if (pool === void 0) { pool = '?pool=353:1'; }
      return {
          connection: {
              http: {
                  endpoints: {
                      assignmentAcknowledgement: '/v1/assignmentAcknowledgement',
                      cancelAssignmentInvitation: '/v1/cancelAssignmentInvitation',
                      coach: '/v1/coach',
                      concludeChat: '/v1/concludeChat',
                      conferenceChat: '/v1/conferenceChat',
                      createAgentSession: '/v2/createAgentSession',
                      createAgentSessionWorkObjects: '/v3/createAgentSession',
                      createSupervisorSession: '/v1/createSupervisorSession',
                      getMessages: '/v1/getMessages' + pool,
                      joinChat: '/v1/joinChat',
                      leadReassignment: '/v1/leadReassignment',
                      leaveChat: '/v1/leaveChat',
                      logoff: '/v1/logoff' + pool,
                      logonOSVC: '/v1/createAgentSession' + pool,
                      modifyProperties: '/v1/modifyProperties',
                      monitor: '/v1/monitor',
                      postMessage: '/v1/postMessage' + pool,
                      refreshMessages: '/v1/refreshMessages' + pool,
                      releaseChat: '/v1/releaseChat',
                      requestAssignment: '/v1/requestAssignment' + pool,
                      retrieveAgentsAndQueues: '/v1/retrieveAgentsAndQueues',
                      sendAttachment: '/v1/multipleFileAttachmentTransfer' + pool,
                      setActivityStatus: '/v1/setActivityStatus' + pool,
                      setAvailability: '/v1/setAvailability',
                      setCustomAvailability: '/v2/setAvailability',
                      setEngagementProperty: '/v1/setEngagementProperty',
                      setInteractionStatus: '/v1/setInteractionStatus' + pool,
                      transferChat: '/v1/transferChat',
                  },
                  reconnectAttemptTimer: 5,
                  reconnectAttempts: 2,
                  reconnectTimer: 240,
                  timeBetweenGetAttempts: 0.5,
              },
          },
      };
  }
  var ChatConfig = /** @class */ (function () {
      function ChatConfig() {
      }
      ChatConfig.setPool = function (pool) {
          ChatConfig.configMap = setPool(pool);
      };
      ChatConfig.configMap = setPool();
      return ChatConfig;
  }());

  var RequestTypes;
  (function (RequestTypes) {
      RequestTypes["refreshMessages"] = "refreshMessages";
      RequestTypes["setActivityStatus"] = "setActivityStatus";
      RequestTypes["makeOSVCLogin"] = "makeOSVCLogin";
      RequestTypes["requestAssignment"] = "requestAssignment";
      RequestTypes["modifyProperties"] = "modifyProperties";
      RequestTypes["busRequestAcknowledgement"] = "busRequestAcknowledgement";
      RequestTypes["setAvailability"] = "setAvailability";
      RequestTypes["makeLoginRequest"] = "makeLoginRequest";
      RequestTypes["makeLoginRequestSupervisor"] = "makeLoginRequestSupervisor";
      RequestTypes["makeLoginRequestWorkObjects"] = "makeLoginRequestWorkObjects";
      RequestTypes["endSession"] = "endSession";
      RequestTypes["post"] = "post";
      RequestTypes["sendMessage"] = "sendMessage";
      RequestTypes["sendAttachment"] = "sendAttachment";
      RequestTypes["setContext"] = "setContext";
      RequestTypes["get"] = "get";
      RequestTypes["startListening"] = "startListening";
      RequestTypes["stopListening"] = "stopListening";
      RequestTypes["setCustomAvailability"] = "setCustomAvailability";
      RequestTypes["setInteractionState"] = "setInteractionState";
      RequestTypes["acceptChannel"] = "acceptChannel";
      RequestTypes["leaveChannel"] = "leaveChannel";
      RequestTypes["concludeChannel"] = "concludeChannel";
      RequestTypes["closeChannel"] = "closeChannel";
      RequestTypes["transferChannel"] = "transferChannel";
      RequestTypes["conference"] = "conference";
      RequestTypes["cancelInvitation"] = "cancelInvitation";
      RequestTypes["listTransferDestinations"] = "listTransferDestinations";
      RequestTypes["on"] = "on";
      RequestTypes["unsubscribe"] = "unsubscribe";
      RequestTypes["respondToOffer"] = "respondToOffer";
      RequestTypes["monitor"] = "monitor";
      RequestTypes["joinToAssist"] = "joinToAssist";
      RequestTypes["joinWork"] = "joinWork";
      RequestTypes["assignRole"] = "assignRole";
      RequestTypes["publishEvent"] = "publishEvent";
      RequestTypes["EventNotification"] = "EventNotification";
      RequestTypes["MasterDown"] = "MasterDown";
      RequestTypes["MasterAlive"] = "MasterAlive";
      RequestTypes["RegisterClient"] = "RegisterClient";
  })(RequestTypes || (RequestTypes = {}));

  var EventCallbackStore = /** @class */ (function () {
      function EventCallbackStore() {
      }
      EventCallbackStore.registerListeners = function (event, listener, priority) {
          var listeners = EventCallbackStore._eventMap.get(event);
          if (listeners) {
              var matchingListener = listeners.find(function (callback) { return callback === listener; });
              if (!matchingListener) {
                  if (priority) {
                      listeners.unshift(listener);
                  }
                  else {
                      listeners.push(listener);
                  }
              }
          }
          else {
              EventCallbackStore._eventMap.set(event, [listener]);
          }
      };
      EventCallbackStore.removeListeners = function (event, callback) {
          var listeners = EventCallbackStore._eventMap.get(event);
          if (listeners) {
              for (var i = listeners.length - 1; i > -1; i--) {
                  if (listeners[i] === callback) {
                      Logger.log("Unsubscribing interest in " + event);
                      listeners.splice(i, 1);
                  }
              }
          }
      };
      EventCallbackStore.invokeListeners = function (type, payload) {
          var e_1, _a;
          if (EventCallbackStore._eventMap.has(type)) {
              Logger.log('###### Listener for event => ' + type + ' Found Firing the call');
              var listeners = EventCallbackStore._eventMap.get(type);
              if (listeners) {
                  try {
                      for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
                          var listener = listeners_1_1.value;
                          listener(type, payload);
                      }
                  }
                  catch (e_1_1) { e_1 = { error: e_1_1 }; }
                  finally {
                      try {
                          if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return)) _a.call(listeners_1);
                      }
                      finally { if (e_1) throw e_1.error; }
                  }
              }
          }
      };
      EventCallbackStore.getEventMap = function () {
          return EventCallbackStore._eventMap;
      };
      EventCallbackStore._eventMap = new Map();
      return EventCallbackStore;
  }());

  /**
   * This represents a Work offer
   */
  var MercuryOffer = /** @class */ (function () {
      function MercuryOffer(identifier, externalWorkId, type, workTypeCode, fusionChannelId, conversationId, created) {
          this.context = new Map();
          this.identifier = identifier;
          this.externalIdString = externalWorkId;
          this.channelIdentifier = this.identifier;
          this.type = type;
          this.workTypeCode = workTypeCode;
          this.fusionChannelId = fusionChannelId;
          this.conversationId = conversationId;
          this.created = new Date(created);
      }
      MercuryOffer.convert = function (mercuryOffer) {
          var offer = new MercuryOffer(mercuryOffer.identifier, mercuryOffer.externalIdString, mercuryOffer.type, mercuryOffer.workTypeCode, mercuryOffer.fusionChannelId, mercuryOffer.conversationId, new Date(mercuryOffer.created).getTime());
          offer.from = mercuryOffer.from;
          offer.context = mercuryOffer.context;
          offer.created = mercuryOffer.created;
          offer.assignmentType = mercuryOffer.assignmentType;
          return offer;
      };
      return MercuryOffer;
  }());

  var Status;
  (function (Status) {
      Status["PENDING"] = "PENDING";
      Status["SUCCESS"] = "SUCCESS";
      Status["FAILURE"] = "FAILURE";
  })(Status || (Status = {}));

  var PromiseStore = /** @class */ (function () {
      function PromiseStore() {
      }
      PromiseStore.createPromiseAndReturn = function (requestId, callback) {
          var resolver;
          var rejectRef;
          var promise = new Promise(function (resolve, reject) {
              resolver = resolve;
              rejectRef = reject;
          });
          PromiseStore.promiseMap.set(requestId, { promiseInstance: promise, resolveRef: resolver, rejectRef: rejectRef });
          if (callback) {
              PromiseStore.callbackRegistry.set(requestId, callback);
          }
          return promise;
      };
      PromiseStore.getPromiseStoreEntry = function (requestId) {
          if (PromiseStore.promiseMap.has(requestId)) {
              return PromiseStore.promiseMap.get(requestId);
          }
          return null;
      };
      PromiseStore.cleanEntry = function (traceID) {
          if (PromiseStore.promiseMap.has(traceID)) {
              PromiseStore.promiseMap.delete(traceID);
              PromiseStore.callbackRegistry.delete(traceID);
          }
      };
      PromiseStore.promiseMap = new Map();
      PromiseStore.callbackRegistry = new Map();
      return PromiseStore;
  }());

  var WorkerConfigurationProvider = /** @class */ (function () {
      function WorkerConfigurationProvider() {
      }
      WorkerConfigurationProvider.getVersion = function () {
          return WorkerConfigurationProvider.version;
      };
      WorkerConfigurationProvider.isProduction = function () {
          return WorkerConfigurationProvider.production;
      };
      // tslint:disable-next-line: quotemark
      WorkerConfigurationProvider.version = "2504.0.1";
      WorkerConfigurationProvider.production = true;
      return WorkerConfigurationProvider;
  }());

  var SharedWorkerConnectionHandler = /** @class */ (function () {
      function SharedWorkerConnectionHandler() {
      }
      SharedWorkerConnectionHandler.initialize = function () {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  if (window && !SharedWorkerConnectionHandler.isInitialized && SharedWorkerConnectionHandler.whenProvisioned === null) {
                      SharedWorkerConnectionHandler.whenProvisioned = new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                          var urlForChatSharedWorker, _a, _b, cdnBasePath, workerFileCDNUrl, response, blob, registerClientRequestEnvelope;
                          return __generator(this, function (_c) {
                              switch (_c.label) {
                                  case 0:
                                      urlForChatSharedWorker = localStorage.getItem('chatSharedWorkerURL');
                                      _a = !urlForChatSharedWorker;
                                      if (_a) return [3 /*break*/, 3];
                                      _b = urlForChatSharedWorker;
                                      if (!_b) return [3 /*break*/, 2];
                                      return [4 /*yield*/, SharedWorkerConnectionHandler.isValidFile(urlForChatSharedWorker)];
                                  case 1:
                                      _b = !(_c.sent());
                                      _c.label = 2;
                                  case 2:
                                      _a = (_b);
                                      _c.label = 3;
                                  case 3:
                                      if (!_a) return [3 /*break*/, 6];
                                      cdnBasePath = 'https://static.oracle.com';
                                      if (!WorkerConfigurationProvider.isProduction()) {
                                          cdnBasePath = 'https://static-stage.oracle.com';
                                      }
                                      workerFileCDNUrl = cdnBasePath + "/cdn/omnicn/mercury/clientLib/" + WorkerConfigurationProvider.getVersion() + "/package/dist/worker/oracle-mercury-client-worker.js";
                                      return [4 /*yield*/, fetch(workerFileCDNUrl)];
                                  case 4:
                                      response = _c.sent();
                                      return [4 /*yield*/, response.blob()];
                                  case 5:
                                      blob = _c.sent();
                                      urlForChatSharedWorker = URL.createObjectURL(blob);
                                      localStorage.setItem('chatSharedWorkerURL', urlForChatSharedWorker);
                                      _c.label = 6;
                                  case 6:
                                      if (!SharedWorkerConnectionHandler.workerInstance) {
                                          // tslint:disable-next-line: no-string-literal
                                          SharedWorkerConnectionHandler.workerInstance = new window['SharedWorker'](urlForChatSharedWorker, 'ChatSharedWorker');
                                      }
                                      if (!SharedWorkerConnectionHandler.isInitialized) {
                                          registerClientRequestEnvelope = SharedWorkerConnectionHandler.constructRegisterMessageEnvelope();
                                          SharedWorkerConnectionHandler.firePostMessage(registerClientRequestEnvelope);
                                          SharedWorkerConnectionHandler.isInitialized = true;
                                          SharedWorkerConnectionHandler.startListeningToWorkerEvents();
                                          SharedWorkerConnectionHandler.myChatSharedWorkerURL = urlForChatSharedWorker;
                                          window.addEventListener('storage', function () {
                                              var localStorageChatSharedWorkerURL = localStorage.getItem('chatSharedWorkerURL');
                                              if (!localStorageChatSharedWorkerURL ||
                                                  localStorageChatSharedWorkerURL !== SharedWorkerConnectionHandler.myChatSharedWorkerURL) {
                                                  Logger.warn("chatSharedWorkerURL has been removed from or modified in localStorage. Restoring chatSharedWorkerURL to " + SharedWorkerConnectionHandler.myChatSharedWorkerURL);
                                                  localStorage.setItem('chatSharedWorkerURL', SharedWorkerConnectionHandler.myChatSharedWorkerURL);
                                              }
                                          });
                                      }
                                      resolve();
                                      return [2 /*return*/];
                              }
                          });
                      }); });
                  }
                  return [2 /*return*/, SharedWorkerConnectionHandler.whenProvisioned];
              });
          });
      };
      SharedWorkerConnectionHandler.sendRequest = function (request, skipWait) {
          if (skipWait === void 0) { skipWait = false; }
          var traceId = new Date().getTime().toString();
          var promise = PromiseStore.createPromiseAndReturn(traceId);
          var messageEnvelop = {
              request: request,
              requestTraceId: traceId,
              requestType: request.requestType,
              responseFor: null,
              sourceChannelId: ClientStore.getCommunicationChannelId(),
              sourceWindow: window.name,
              status: Status.PENDING,
              targetChannelId: 'chatSharedWorker',
          };
          if (skipWait) {
              Logger.log('### Send Immediate Request => ' + request.requestType);
              SharedWorkerConnectionHandler.firePostMessage(messageEnvelop);
          }
          else {
              Logger.log('### Send  Request after connection established => ' + request.requestType);
              SharedWorkerConnectionHandler.initialize().then(function () {
                  Logger.log('### firing  Request since connection established => ' + request.requestType);
                  SharedWorkerConnectionHandler.firePostMessage(messageEnvelop);
              });
          }
          return promise;
      };
      SharedWorkerConnectionHandler.startListeningToWorkerEvents = function () {
          SharedWorkerConnectionHandler.workerInstance.port.addEventListener('message', function (event) {
              var messageEnvelope = event.data;
              var requestType = messageEnvelope.requestType;
              var status = messageEnvelope.status;
              SharedWorkerConnectionHandler.resolveExistingPromiseForRequest(messageEnvelope, status);
              if (requestType === RequestTypes.EventNotification) {
                  SharedWorkerConnectionHandler.invokeEventListeners(messageEnvelope);
              }
          });
          SharedWorkerConnectionHandler.workerInstance.port.start();
      };
      SharedWorkerConnectionHandler.invokeEventListeners = function (messageEnvelope) {
          Logger.log('### Executing callback for => ' + messageEnvelope.response.type);
          if (messageEnvelope.response.type === exports.MercuryEventType.WORK_OFFER) {
              var offer = MercuryOffer.convert(messageEnvelope.response.payload);
              if (offer.context.has('queueId')) {
                  offer.context.set('QUEUE_NAME', QueueStore.getQueueName(offer.context.get('queueId')));
              }
              messageEnvelope.response.payload = offer;
          }
          Logger.log(messageEnvelope.response.payload);
          EventCallbackStore.invokeListeners(messageEnvelope.response.type, messageEnvelope.response.payload);
      };
      SharedWorkerConnectionHandler.firePostMessage = function (messageEnvelop) {
          var _a, _b;
          if (((_a = messageEnvelop.request) === null || _a === void 0 ? void 0 : _a.requestType) in [RequestTypes.on, RequestTypes.unsubscribe]) {
              if (messageEnvelop.request) {
                  messageEnvelop.request.callback = null;
              }
          }
          Logger.log('### REQUEST TYPE FIRED  =>=>=> ' + ((_b = messageEnvelop.request) === null || _b === void 0 ? void 0 : _b.requestType));
          SharedWorkerConnectionHandler.workerInstance.port.postMessage(messageEnvelop);
      };
      SharedWorkerConnectionHandler.resolveExistingPromiseForRequest = function (messageEnvelope, status) {
          var promiseStoreEntry = PromiseStore.getPromiseStoreEntry(messageEnvelope.requestTraceId);
          if (promiseStoreEntry !== null) {
              Logger.log("### Promise entry found => " + messageEnvelope.requestType + " => " + messageEnvelope.responseFor);
              Logger.log(messageEnvelope.response);
              if (status === Status.SUCCESS) {
                  promiseStoreEntry.resolveRef(messageEnvelope.response);
              }
              else {
                  promiseStoreEntry.rejectRef(messageEnvelope.response);
              }
              PromiseStore.cleanEntry(messageEnvelope.requestTraceId);
          }
      };
      SharedWorkerConnectionHandler.isValidFile = function (blobURL) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          var sharedWorker = null;
                          try {
                              var timeoutRef_1 = null;
                              // tslint:disable-next-line: no-string-literal
                              sharedWorker = new window['SharedWorker'](blobURL, 'ChatSharedWorker');
                              sharedWorker.onerror = function (event) {
                                  resolve(false);
                                  if (timeoutRef_1) {
                                      clearTimeout(timeoutRef_1);
                                  }
                              };
                              timeoutRef_1 = setTimeout(function () {
                                  SharedWorkerConnectionHandler.workerInstance = sharedWorker;
                                  resolve(true);
                              }, 500);
                          }
                          catch (e) {
                              Logger.error("Not able to restore shared worker", e);
                              resolve(false);
                          }
                      })];
              });
          });
      };
      SharedWorkerConnectionHandler.constructRegisterMessageEnvelope = function () {
          var traceId = new Date().getTime().toString();
          return {
              request: {
                  clientId: ClientStore.getCommunicationChannelId(),
              },
              requestTraceId: traceId,
              requestType: RequestTypes.RegisterClient,
              responseFor: null,
              sourceChannelId: ClientStore.getCommunicationChannelId(),
              sourceWindow: window.name,
              status: Status.PENDING,
              targetChannelId: 'chatSharedWorker',
          };
      };
      SharedWorkerConnectionHandler.whenProvisioned = null;
      SharedWorkerConnectionHandler.isInitialized = false;
      return SharedWorkerConnectionHandler;
  }());

  // tslint:disable: object-literal-sort-keys
  var ChatCommunicator = /** @class */ (function () {
      function ChatCommunicator(configuration) {
          this.clientConfiguration = configuration;
      }
      ChatCommunicator.prototype.refreshMessages = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.refreshMessages,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.setActivityStatus = function (sessionToken, status) {
          var requestEnvelop = {
              requestType: RequestTypes.setActivityStatus,
              request: {
                  sessionToken: sessionToken,
                  status: status,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.makeOSVCLogin = function (jwt, delayGetMessages) {
          var requestEnvelop = {
              requestType: RequestTypes.makeOSVCLogin,
              request: {
                  jwt: jwt,
                  delayGetMessages: delayGetMessages,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.requestAssignment = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.requestAssignment,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.modifyProperties = function (sessionToken, channelIdentifier, contextItems) {
          var requestEnvelop = {
              requestType: RequestTypes.modifyProperties,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  contextItems: contextItems,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.acceptChannel = function (sessionToken, channelIdentifier, assignmentType) {
          var requestEnvelop = {
              requestType: RequestTypes.acceptChannel,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  assignmentType: assignmentType,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.assignRole = function (sessionToken, channelIdentifier, role, participant) {
          var requestEnvelop = {
              requestType: RequestTypes.assignRole,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  role: role,
                  participant: participant,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.cancelInvitation = function (sessionToken, channelIdentifier, type, recipientId) {
          var requestEnvelop = {
              requestType: RequestTypes.cancelInvitation,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  type: type,
                  recipientId: recipientId,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.closeChannel = function (sessionToken, channelIdentifier, participationRole) {
          var requestEnvelop = {
              requestType: RequestTypes.closeChannel,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  participationRole: participationRole,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.concludeChannel = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.concludeChannel,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.conference = function (sessionToken, channelIdentifier, invitee) {
          var requestEnvelop = {
              requestType: RequestTypes.conference,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  invitee: invitee,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.endSession = function (sessionToken, forced) {
          var requestEnvelop = {
              requestType: RequestTypes.endSession,
              request: {
                  sessionToken: sessionToken,
                  forced: forced,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.get = function (sessionId, url, payload) {
          var requestEnvelop = {
              requestType: RequestTypes.get,
              request: {
                  sessionId: sessionId,
                  url: url,
                  payload: payload,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.joinToAssist = function (sessionToken, interactionID) {
          var requestEnvelop = {
              requestType: RequestTypes.joinToAssist,
              request: {
                  sessionToken: sessionToken,
                  interactionID: interactionID,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.joinWork = function (sessionToken, interactionID) {
          var requestEnvelop = {
              requestType: RequestTypes.joinWork,
              request: {
                  sessionToken: sessionToken,
                  interactionID: interactionID,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.leaveChannel = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.leaveChannel,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.listTransferDestinations = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.listTransferDestinations,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.makeLoginRequest = function (jwt, delayGetMessages) {
          var requestEnvelop = {
              requestType: RequestTypes.makeLoginRequest,
              request: {
                  jwt: jwt,
                  delayGetMessages: delayGetMessages,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.makeLoginRequestSupervisor = function (delayGetMessages) {
          var requestEnvelop = {
              requestType: RequestTypes.makeLoginRequestSupervisor,
              request: {
                  delayGetMessages: delayGetMessages,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.makeLoginRequestWorkObjects = function (jwt, delayGetMessages) {
          var requestEnvelop = {
              requestType: RequestTypes.makeLoginRequestWorkObjects,
              request: {
                  jwt: jwt,
                  delayGetMessages: delayGetMessages,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.monitor = function (sessionToken, interactionID) {
          var requestEnvelop = {
              requestType: RequestTypes.monitor,
              request: {
                  sessionToken: sessionToken,
                  interactionID: interactionID,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.on = function (event, listener, priority) {
          EventCallbackStore.registerListeners(event, listener, priority);
      };
      ChatCommunicator.prototype.post = function (sessionId, url, messageType, payload, maintainOrder) {
          var requestEnvelop = {
              requestType: RequestTypes.post,
              request: {
                  sessionToken: sessionId,
                  url: url,
                  messageType: messageType,
                  payload: payload,
                  maintainOrder: maintainOrder,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.publishEvent = function (type, payload) {
          EventCallbackStore.invokeListeners(type, payload);
      };
      ChatCommunicator.prototype.respondToOffer = function (sessionToken, offer, action, responseType) {
          var requestEnvelop = {
              requestType: RequestTypes.respondToOffer,
              request: {
                  sessionToken: sessionToken,
                  offer: offer,
                  action: action,
                  responseType: responseType,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.sendMessage = function (sessionToken, channelIdentifier, message) {
          var requestEnvelop = {
              requestType: RequestTypes.sendMessage,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  message: message,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.sendAttachment = function (sessionToken, channelIdentifier, fileAttachmentList) {
          var requestEnvelop = {
              requestType: RequestTypes.sendAttachment,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  fileAttachmentList: fileAttachmentList,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.setAvailability = function (sessionToken, availability) {
          var requestEnvelop = {
              requestType: RequestTypes.setAvailability,
              request: {
                  sessionToken: sessionToken,
                  availability: availability,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.setContext = function (sessionToken, channelIdentifier, contextItem) {
          var requestEnvelop = {
              requestType: RequestTypes.setContext,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  contextItem: contextItem,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.setCustomAvailability = function (sessionToken, customAvailabilityStateId) {
          var requestEnvelop = {
              requestType: RequestTypes.setCustomAvailability,
              request: {
                  sessionToken: sessionToken,
                  customAvailabilityStateId: customAvailabilityStateId,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.setInteractionState = function (sessionToken, channelIdentifier, activityMode) {
          var requestEnvelop = {
              requestType: RequestTypes.setInteractionState,
              request: {
                  sessionToken: sessionToken,
                  activityMode: activityMode,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.startListening = function (sessionToken, channelIdentifier) {
          var requestEnvelop = {
              requestType: RequestTypes.startListening,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.stopListening = function () {
          var requestEnvelop = {
              requestType: RequestTypes.stopListening,
              request: {
                  clientConfiguration: this.clientConfiguration,
              },
          };
          SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.transferChannel = function (sessionToken, channelIdentifier, destination) {
          var requestEnvelop = {
              requestType: RequestTypes.transferChannel,
              request: {
                  sessionToken: sessionToken,
                  channelIdentifier: channelIdentifier,
                  destination: destination,
                  clientConfiguration: this.clientConfiguration,
              },
          };
          return SharedWorkerConnectionHandler.sendRequest(requestEnvelop);
      };
      ChatCommunicator.prototype.unsubscribe = function (event, callback) {
          EventCallbackStore.removeListeners(event, callback);
      };
      return ChatCommunicator;
  }());

  var MercuryError = /** @class */ (function (_super) {
      __extends(MercuryError, _super);
      function MercuryError(type, message, reason) {
          var _this = _super.call(this, message) || this;
          _this.name = type;
          _this.reason = reason;
          return _this;
      }
      return MercuryError;
  }(Error));
  (function (MercuryErrorType) {
      MercuryErrorType["INCOMPATIBLE_BROWSER"] = "INCOMPATIBLE_BROWSER";
      MercuryErrorType["COMMUNICATION_ERROR"] = "COMMUNICATION_ERROR";
      MercuryErrorType["COMMUNICATION_LOST"] = "COMMUNICATION_LOST";
      MercuryErrorType["SEVERE_ERROR"] = "SEVERE_ERROR";
      MercuryErrorType["CLIENT_ERROR"] = "CLIENT_ERROR";
      MercuryErrorType["RESOURCE_UNAVAILABLE"] = "RESOURCE_UNAVAILABLE";
  })(exports.MercuryErrorType || (exports.MercuryErrorType = {}));
  (function (ErrorReason) {
      ErrorReason["CONFLICTING_SESSION"] = "CONFLICTING_SESSION";
      ErrorReason["CONNECTION_ERROR"] = "CONNECTION_ERROR";
      ErrorReason["UNKNOWN_ERROR"] = "UNKOWN_ERROR";
      ErrorReason["INCOMPATIBLE_BROWSER"] = "INCOMPATIBLE_BROWSER";
  })(exports.ErrorReason || (exports.ErrorReason = {}));

  /**
   * The encapsulates the response from the 'setAvailability' call
   */
  var SetAvailabilityResponse = /** @class */ (function () {
      function SetAvailabilityResponse(map) {
          this.currentAvailibilty = new Map();
          if (map) {
              this.currentAvailibilty = map;
          }
      }
      /**
       * Sets the availability state for a specific work type
       * @param type Type of work this availability state relates to
       * @param availability availability state
       */
      SetAvailabilityResponse.prototype.setAvailibilty = function (type, availability) {
          this.currentAvailibilty.set(type, availability);
      };
      return SetAvailabilityResponse;
  }());

  /**
   * The encapsulates the response from the 'v2/setAvailability' call
   */
  var SetCustomAvailabilityResponse = /** @class */ (function (_super) {
      __extends(SetCustomAvailabilityResponse, _super);
      function SetCustomAvailabilityResponse(customAvailabilityStateId) {
          var _this = _super.call(this) || this;
          if (customAvailabilityStateId) {
              _this.customAvailabilityStateId = customAvailabilityStateId;
          }
          return _this;
      }
      /**
       * Sets the custom availability state id
       * @param customAvailabilityStateId availability state id
       */
      SetCustomAvailabilityResponse.prototype.setCustomAvailibiltyStateId = function (customAvailabilityStateId) {
          this.customAvailabilityStateId = customAvailabilityStateId;
      };
      return SetCustomAvailabilityResponse;
  }(SetAvailabilityResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (OfferActionType) {
      OfferActionType["ACCEPT"] = "ACCEPT";
      OfferActionType["DECLINE"] = "DECLINE";
      OfferActionType["NONE"] = "NONE";
  })(exports.OfferActionType || (exports.OfferActionType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
                  'name': 'David Stowell',
                  'type': 'END_USER',
                  'id': 144482265487691780,
                  'idString': '144482265487691776',
                  'connectionState': 'ACTIVE',
                  'role': 'END_USER',
                  'accountId': 0,
                  'accountIdString': '0'
              }

  */
  /**
   * This class represents the response from
   * the 'assignmentAcknowledgement' request
   */
  var ClientInfo = /** @class */ (function () {
      function ClientInfo() {
      }
      /**
       * Convert the legacy message format to the new 'Participant' object
       * @param legacyMessage Legacy ClientInfo structure
       */
      ClientInfo.convert = function (legacyMessage, participantQueue) {
          /*
          {
                  "name": "Dave Stowell",
                  "firstName": "Dave",
                  "lastName": "Stowell",
                  "type": "END_USER",
                  "id": 249984893670957056,
                  "idString": "249984893670957056",
                  "connectionState": "ACTIVE",
                  "role": "END_USER",
                  "accountId": 0,
                  "accountIdString": "0"
              }
          */
          var resource = new HumanResource();
          resource.setFirstName(legacyMessage.firstName);
          resource.setLastName(legacyMessage.lastName);
          /**
           * OSVC clientinfo not getting firstname/lastname instead name.
           */
          if (!resource.firstName && legacyMessage.name) {
              resource.setFirstName(legacyMessage.name);
              resource.setLastName('');
          }
          // Because of LV-7525 we need to handle the id in two different fields
          // Remove once LV-7525 is fixed.
          if (legacyMessage.idString) {
              resource.identifier = legacyMessage.idString;
          }
          else {
              resource.identifier = legacyMessage.clientIdString;
          }
          // Look up the Resource Type - END_USER
          var resourceType = exports.ResourceType[legacyMessage.type]; // TODO
          resource.type = resourceType;
          if (resourceType === exports.ResourceType.END_USER) {
              resource.contactInfo = legacyMessage.contactInfo;
          }
          // ===================================
          // Construct the Participant Reference
          // ===================================
          var participant = new Participant(resource);
          // Look up Participation Role - END_USER
          var participationRole = exports.ParticipationRoleType[legacyMessage.role]; // TODO
          participant.role = participationRole;
          participant.queue = participantQueue;
          return participant;
      };
      return ClientInfo;
  }());

  /**
   * This class represents the response from
   * the 'assignmentAcknowledgement' request
   */
  var AssignmentAcknowledgementResponse = /** @class */ (function (_super) {
      __extends(AssignmentAcknowledgementResponse, _super);
      function AssignmentAcknowledgementResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy Channel
       */
      AssignmentAcknowledgementResponse.convert = function (legacyMessage, sessionToken) {
          var e_1, _a;
          var resultObj = legacyMessage.chatAssignmentAcknowledgementResult;
          // First check if this is a DECLINE
          if (resultObj.action === exports.OfferActionType.DECLINE) {
              return undefined;
          }
          // OK, we have an accept
          // ==========================
          // Construct the Participants
          // ==========================
          var participants = [];
          try {
              for (var _b = __values(resultObj.clientList), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var client = _c.value;
                  var participant = ClientInfo.convert(client);
                  // Add to the participants list
                  participants.push(participant);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          // =====================
          // Construct the Channel
          // =====================
          var channel = new Channel(sessionToken, resultObj.engagementIdString);
          channel.members = participants;
          return channel;
      };
      return AssignmentAcknowledgementResponse;
  }(BaseResponse));

  /**
   * This class represents the response from
   * the 'cancelAssignmentInvitation' request
   */
  var CancelAssignmentInvitationResponse = /** @class */ (function (_super) {
      __extends(CancelAssignmentInvitationResponse, _super);
      function CancelAssignmentInvitationResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to a boolean value
       * @param legacyMessage Legacy Channel
       */
      CancelAssignmentInvitationResponse.convert = function (legacyMessage) {
          var resultObj = legacyMessage.chatCancelAssignmentInvitationResult;
          return resultObj.invitationCancelled;
      };
      return CancelAssignmentInvitationResponse;
  }(BaseResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (AsyncResponseType) {
      /** This response is produced when the operation is complete - it can complete immediately */
      AsyncResponseType["COMPLETE"] = "COMPLETE";
      /** This response is produced when the operation is in-flight - it needs acceptance */
      AsyncResponseType["PROCESSING"] = "PROCESSING";
      /** This response is produced when the resource becomes unavilable */
      AsyncResponseType["UNAVAILABLE"] = "UNAVAILABLE";
  })(exports.AsyncResponseType || (exports.AsyncResponseType = {}));

  /**
   * This class represents the response from
   * the 'assignmentAcknowledgement' request
   */
  var ChatTransferEngagementResponse = /** @class */ (function (_super) {
      __extends(ChatTransferEngagementResponse, _super);
      function ChatTransferEngagementResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new response type object
       * @param legacyMessage Legacy Channel
       */
      ChatTransferEngagementResponse.convert = function (legacyMessage) {
          var resultObj = legacyMessage.chatTransferEngagementResult;
          if (resultObj.resultCode === exports.AsyncResponseType.UNAVAILABLE) {
              throw new MercuryError(exports.MercuryErrorType.RESOURCE_UNAVAILABLE, 'Transfer destination is unavailable', exports.ErrorReason.UNKNOWN_ERROR);
          }
          // ===================
          // Return the response
          // ===================
          var responseCode = exports.AsyncResponseType[resultObj.resultCode];
          return responseCode;
      };
      return ChatTransferEngagementResponse;
  }(BaseResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * This class represents the response from
   * the 'conferenceChat' request
   */
  var ConferenceResponse = /** @class */ (function (_super) {
      __extends(ConferenceResponse, _super);
      function ConferenceResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new response type object
       * @param legacyMessage Legacy Channel
       */
      ConferenceResponse.convert = function (legacyMessage) {
          var resultObj = legacyMessage.chatConferenceResult;
          // ===================
          // Return the response
          // ===================
          var responseCode = exports.AsyncResponseType[resultObj.resultCode];
          if (responseCode === exports.AsyncResponseType.UNAVAILABLE) {
              throw new MercuryError(exports.MercuryErrorType.RESOURCE_UNAVAILABLE, 'Resource is unavailable', exports.ErrorReason.UNKNOWN_ERROR);
          }
          return responseCode;
      };
      return ConferenceResponse;
  }(BaseResponse));

  /*
     Object representing the custom availability.
     
     Example:
     {
      "currentStateId": "729ad2c4-62ec-4cee-9749-d1792e28d159",
      "states": [
        {
          "stateId": "729ad2c4-62ec-4cee-9749-d1792e28d159",
          "state": "Chat and SR",
          "baseState": "Available",
          "channels": [
            "CHAT",
            "SVC_SERVICE_REQUESTS"
          ]
        },
        {
          "stateId": "772acedc-d567-4363-82df-8afc3d285bbc",
          "state": "Chat only",
          "baseState": "Available",
          "channels": [
            "CHAT"
          ]
        },
        {
          "stateId": "c8561714-e0f9-4357-9ecc-16982210c1eb",
          "state": "SR Only",
          "baseState": "Available",
          "channels": [
            "SVC_SERVICE_REQUESTS"
          ]
        },
        {
          "stateId": "edca57e5-8442-4ba4-83a1-f40dfaac2087",
          "state": "Out For Lunch",
          "baseState": "Unavailable",
          "channels": []
        },
        {
          "stateId": "a0d3ffc4-ecf1-4088-bbf3-119595674e39",
          "state": "Training",
          "baseState": "Unavailable",
          "channels": []
        },
        {
          "stateId": "bdff3b91-8c0b-4bce-a94d-3c5708a7ec52",
          "state": "Other work",
          "baseState": "Unavailable",
          "channels": []
        }
      ]
    }
   */
  var CustomAvailability = /** @class */ (function () {
      function CustomAvailability(currentStateId, states) {
          this.currentStateId = currentStateId;
          this.states = states;
      }
      return CustomAvailability;
  }());

  var SessionDetails = /** @class */ (function () {
      function SessionDetails() {
          this.channels = [];
          this.availability = new Map();
      }
      return SessionDetails;
  }());

  /* Copyright (c) 2021, Oracle. All rights reserved. */
  /**
   * Represents the work types
   * WARNING: Because customers ca define their own
   * work types, we cannot use an enum
   * This value is here to centralize the well-known
   * value
   */
  var WorkType;
  (function (WorkType) {
      WorkType["CHAT"] = "CHAT";
  })(WorkType || (WorkType = {}));

  /*
  {
              participants: [],
              engagementId: 144482265470914,
              engagementIdString: '144482265470914',
              engagementCreateTime: null,
              engagementCreateTimeString: null,
              engagementFirstEngagedTime: null,
              engagementFirstEngagedTimeString: null,
              secondsEngaged: null,
              secondsEngagedString: null,
              queueId: null,
              queueIdString: null,
              state: null,
              requestSource: null,
              incidentId: null,
              incidentIdString: null
            }
  */
  var Engagement = /** @class */ (function () {
      function Engagement() {
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy ChatEngagementAssignment message
       */
      Engagement.convert = function (sessionToken, legacyMessage) {
          var e_1, _a;
          var channel = new Channel(sessionToken, legacyMessage.engagementIdString);
          try {
              for (var _b = __values(legacyMessage.participants), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var client = _c.value;
                  var participant = ClientInfo.convert(client, legacyMessage.queueIdString);
                  if (participant.role !== 'TRANSIENT') {
                      // Add to the participants list
                      channel.members.push(participant);
                  }
                  if (client.type === 'END_USER') {
                      channel.contactInfo = client.contactInfo;
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          channel.state = exports.ChannelStateType[legacyMessage.state];
          channel.externalIdString = legacyMessage.externalWorkIdString;
          channel.workTypeCode = legacyMessage.workTypeCode;
          channel.fusionChannelId = legacyMessage.fusionChannelId;
          channel.conversationId = legacyMessage.conversationId;
          Logger.log("Client Library - Engagement - externalIdString: [" + channel.externalIdString + "], "
              + ("channel.workTypeCode [" + channel.externalIdString + "], fusionChannelId [" + channel.fusionChannelId + "], ")
              + ("conversationId [" + channel.conversationId + "]"));
          return channel;
      };
      return Engagement;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  EXAMPLE:
  {
      chatLogonResult: {
        engagements: [{
          participants: [],
          engagementId: 144482265470914,
          engagementIdString: '144482265470914',
          engagementCreateTime: null,
          engagementCreateTimeString: null,
          engagementFirstEngagedTime: null,
          engagementFirstEngagedTimeString: null,
          secondsEngaged: null,
          secondsEngagedString: null,
          queueId: null,
          queueIdString: null,
          state: null,
          requestSource: null,
          incidentId: null,
          incidentIdString: null
        }],
        activityStatus: 'UNAVAILABLE',
        subTypeId: 22
      },
      chatSystemError: null,
      clientSendTime: 1580761948854,
      serviceStartTime: 1580761948854,
      serviceFinishTime: 1580761948953,
      sessionId: '144540534486552576',
      clientId: 475573989376,
      clientIdString: '475573989376',
      sequenceNumber: 0,
      sequenceNumberString: '0'
  }
  */
  /**
   * This interface specifies the subset of fields used by us for
   * message mapping purposes
   */
  var CreateAgentSessionResponse = /** @class */ (function (_super) {
      __extends(CreateAgentSessionResponse, _super);
      function CreateAgentSessionResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      CreateAgentSessionResponse.convert = function (legacyMessage) {
          var e_1, _a, e_2, _b, e_3, _c;
          var sessionDetails = new SessionDetails();
          sessionDetails.sessionIdentifier = legacyMessage.sessionId;
          sessionDetails.clientIdentifier = legacyMessage.clientIdString;
          sessionDetails.availability = new Map();
          sessionDetails.workTypeDefinition = new Map();
          if (legacyMessage.customAvailability) {
              var currentStateIdFromResponse = '';
              var statesfromResponse = [];
              try {
                  for (var _d = __values(Object.entries(legacyMessage.customAvailability)), _e = _d.next(); !_e.done; _e = _d.next()) {
                      var _f = __read(_e.value, 2), key = _f[0], value = _f[1];
                      if (key === 'currentStateId') {
                          currentStateIdFromResponse = value;
                      }
                      if (key === 'states') {
                          statesfromResponse = value;
                      }
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
              if (currentStateIdFromResponse !== '' && statesfromResponse.length > 0) {
                  sessionDetails.customAvailability = new CustomAvailability(currentStateIdFromResponse, statesfromResponse);
              }
          }
          if (legacyMessage.availabilityMap) {
              try {
                  for (var _g = __values(Object.entries(legacyMessage.availabilityMap)), _h = _g.next(); !_h.done; _h = _g.next()) {
                      var _j = __read(_h.value, 2), key = _j[0], value = _j[1];
                      var translatedAvailability = exports.AvailabilityType[value];
                      var availabilityType = (translatedAvailability) ? translatedAvailability : exports.AvailabilityType.Uavailable;
                      sessionDetails.availability.set(key, availabilityType);
                  }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                  try {
                      if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                  }
                  finally { if (e_2) throw e_2.error; }
              }
          }
          else {
              // Old style protocol
              var returnedAvailability = legacyMessage.chatLogonResult.activityStatus;
              var serverAvilability = exports.AvailabilityType[returnedAvailability];
              sessionDetails.availability.set(WorkType.CHAT, serverAvilability);
          }
          if (legacyMessage.workTypeDefinition) {
              try {
                  for (var _k = __values(Object.entries(legacyMessage.workTypeDefinition)), _l = _k.next(); !_l.done; _l = _k.next()) {
                      var _m = __read(_l.value, 2), key = _m[0], value = _m[1];
                      sessionDetails.workTypeDefinition.set(key, value);
                  }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                  try {
                      if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                  }
                  finally { if (e_3) throw e_3.error; }
              }
          }
          // Now add all the engagements (known as channels in the 'new' Mercury)
          legacyMessage.chatLogonResult.engagements.forEach(function (engagement) {
              var channel = Engagement.convert(legacyMessage.sessionId, engagement);
              sessionDetails.channels.push(channel);
          });
          return sessionDetails;
      };
      return CreateAgentSessionResponse;
  }(BaseResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ConnectionStateType) {
      /** Un-Contactable */
      ConnectionStateType["ABSENT"] = "ABSENT";
      /** Connected and Contactable */
      ConnectionStateType["ACTIVE"] = "ACTIVE";
      /** Not connected */
      ConnectionStateType["DISCONNECTED"] = "DISCONNECTED";
      /** Unknown state */
      ConnectionStateType["UNKNOWN"] = "UNKNOWN";
  })(exports.ConnectionStateType || (exports.ConnectionStateType = {}));

  /*
    {
      'ChatEngagementUpdateNotification: {
        destinationId: 145935665147998,
        destinationIdString: '145935665147998',
        destinationType: 'ENGAGEMENT',
        senderId: 0,
        senderIdString: '0',
        senderType: 'SYSTEM',
        messageType: 'ENGAGEMENT_UPDATE_NOTIFICATION',
        visibility: 'ALL',
        createdTime: 1581097756779,
        createdTimeString: '1581097756779',
        engagementId: 145935665147998,
        engagementIdString: '145935665147998',
        clientId: 0,
        clientIdString: '0',
        reason: 'PARTICIPANT_UPDATE',

        connectionState: 'ACTIVE',
        count: 2,
        role: 'END_USER',
        secondsToDisconnect: 0

      }
    }
  */
  /**
   * Message indicating the disconnect of a channel member
   * and the reason
   */
  var MemberUpdate = /** @class */ (function () {
      function MemberUpdate() {
          this.connectionState = exports.ConnectionStateType.UNKNOWN;
      }
      return MemberUpdate;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
    EXAMPLE:
  {

    "clientId": 62,                         // DO NOT YOU - ONLY USE THE IdString
    "clientIdString": "62",
    "accountId": 12,                        // DO NOT YOU - ONLY USE THE IdString
    "accountIdString": "12",
    "virtualAgent": false,
    "destinationId": 52,                    // DO NOT YOU - ONLY USE THE IdString
    "destinationIdString": "52",
    "destinationType": "ENGAGEMENT",
    "senderId": 62,                         // DO NOT YOU - ONLY USE THE IdString
    "senderIdString": "62",
    "senderType": "AGENT",
    "messageType": "ENGAGEMENT_ADD_CLIENT",
    "visibility": "ALL",
    "createdTime": 1569564410814,
    "createdTimeString": "1569564410814"

  }
  */
  var BaseMessage = /** @class */ (function () {
      function BaseMessage() {
      }
      return BaseMessage;
  }());

  /*
    EXAMPLE:
    {
      'ChatEngagementUpdateNotification: {
        destinationId: 145935665147998,
        destinationIdString: '145935665147998',
        destinationType: 'ENGAGEMENT',
        senderId: 0,
        senderIdString: '0',
        senderType: 'SYSTEM',
        messageType: 'ENGAGEMENT_UPDATE_NOTIFICATION',
        visibility: 'ALL',
        createdTime: 1581097756779,
        createdTimeString: '1581097756779',
        engagementId: 145935665147998,
        engagementIdString: '145935665147998',
        clientId: 0,
        clientIdString: '0',
        reason: 'PARTICIPANT_UPDATE',

        connectionState: 'ACTIVE',
        count: 2,
        role: 'END_USER',
        secondsToDisconnect: 0

      }
    }
  */
  var ChatEngagementUpdateNotification = /** @class */ (function (_super) {
      __extends(ChatEngagementUpdateNotification, _super);
      /*
       * Initialize an instance of ChatEngagementUpdateNotification
       * @param client
       * @param engagementIdString
       */
      function ChatEngagementUpdateNotification(engagementIdString, role, client) {
          var _this = _super.call(this) || this;
          if (client) {
              _this.clientIdString = client.idString;
              _this.connectionState = client.connectionState;
          }
          _this.role = role;
          _this.engagementIdString = engagementIdString;
          return _this;
      }
      /**
       * Convert the legacy message format to the new format object
       * @param legacyMessage Legacy  message
       */
      ChatEngagementUpdateNotification.convert = function (legacyMessage) {
          // =============================
          // Construct the 'from' resource
          // =============================
          var resource = new Resource();
          resource.identifier = legacyMessage.clientIdString;
          resource.type = exports.ResourceType[legacyMessage.senderType];
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = exports.ParticipationRoleType[legacyMessage.role];
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new MemberUpdate();
          newMessage.channelIdentifier = legacyMessage.engagementIdString;
          newMessage.member = participant;
          newMessage.created = new Date(legacyMessage.createdTime);
          var connectionState = exports.ConnectionStateType[legacyMessage.connectionState];
          if (connectionState) {
              newMessage.connectionState = connectionState;
          }
          newMessage.secondsUntilDisconnect = legacyMessage.secondsToDisconnect;
          return newMessage;
      };
      return ChatEngagementUpdateNotification;
  }(BaseMessage));

  /**
   * This class represents the response from
   * the 'monitor' request
   */
  var JoinEngagementResponse = /** @class */ (function (_super) {
      __extends(JoinEngagementResponse, _super);
      function JoinEngagementResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy Channel
       */
      JoinEngagementResponse.convert = function (legacyMessage) {
          var resultObj = legacyMessage.chatJoinEngagementResult;
          // First check if this is not a SUCCESS
          if (resultObj.resultCode !== 'SUCCESS') {
              return undefined;
          }
          // OK, we have an accept
          // ==========================
          // Construct the ChatEngagementUpdateNotification
          // ==========================
          return new ChatEngagementUpdateNotification(resultObj.engagementIdString, exports.ParticipationRoleType.CONFEREE);
      };
      return JoinEngagementResponse;
  }(BaseResponse));

  /**
   * This class represents the response from
   * the 'monitor' request
   */
  var MonitorCoachEngagementResponse = /** @class */ (function (_super) {
      __extends(MonitorCoachEngagementResponse, _super);
      function MonitorCoachEngagementResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy Channel
       */
      MonitorCoachEngagementResponse.convert = function (legacyMessage) {
          var e_1, _a;
          var resultObj = legacyMessage.chatMonitorResult;
          // First check if this is a DECLINE
          if (resultObj.action === exports.OfferActionType.DECLINE) {
              return undefined;
          }
          try {
              // OK, we have an accept
              // ==========================
              // Construct the ChatEngagementUpdateNotification
              // ==========================
              for (var _b = __values(resultObj.clientList), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var currClient = _c.value;
                  if (currClient.role === 'COACH') {
                      return new ChatEngagementUpdateNotification(resultObj.engagementIdString, exports.ParticipationRoleType.COACH, currClient);
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          // =====================
          // No coach client
          // =====================
          return undefined;
      };
      return MonitorCoachEngagementResponse;
  }(BaseResponse));

  /**
   * This class represents the response from
   * the 'monitor' request
   */
  var MonitorResponse = /** @class */ (function (_super) {
      __extends(MonitorResponse, _super);
      function MonitorResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy Channel
       */
      MonitorResponse.convert = function (legacyMessage, sessionToken) {
          var e_1, _a;
          var resultObj = legacyMessage.chatMonitorResult;
          // First check if this is a DECLINE
          if (resultObj.action === exports.OfferActionType.DECLINE) {
              return undefined;
          }
          // OK, we have an accept
          // ==========================
          // Construct the Participants
          // ==========================
          var participants = [];
          try {
              for (var _b = __values(resultObj.clientList), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var client = _c.value;
                  var participant = ClientInfo.convert(client);
                  // Add to the participants list
                  participants.push(participant);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          // =====================
          // Construct the Channel
          // =====================
          var channel = new Channel(sessionToken, resultObj.engagementIdString);
          channel.members = participants;
          return channel;
      };
      return MonitorResponse;
  }(BaseResponse));

  /*
  {
        ChatActivitySignal: {
          destinationId: 143450140161994,
          destinationIdString: '143450140161994',
          destinationType: 'ENGAGEMENT',
          senderId: 144482265487691780,
          senderIdString: '144482265487691776',
          senderType: 'END_USER',
          messageType: 'ACTIVITY_SIGNAL',
          visibility: 'NOT_ENDUSER',
          createdTime: 1580748089709,
          createdTimeString: '1580748089709',
          engagementId: 143450140161994,
          engagementIdString: '143450140161994',
          clientId: 144482265487691780,
          clientIdString: '144482265487691776',
          mode: 'LISTENING',
          sneakPreviewState: 'DISABLED',
          sneakPreviewInterval: 3000,
          sneakPreview: '',
          sneakPreviewFocus: false
        }
      }
  */
  var ActivityChange = /** @class */ (function () {
      function ActivityChange() {
          this.created = new Date();
      }
      return ActivityChange;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (ActivityType) {
      ActivityType["LISTENING"] = "LISTENING";
      ActivityType["RESPONDING"] = "RESPONDING";
      ActivityType["AGENTS_ONLY_RESPONDING"] = "AGENTS_ONLY_RESPONDING";
  })(exports.ActivityType || (exports.ActivityType = {}));

  /*
  {
        ChatActivitySignal: {
          destinationId: 143450140161994,             // DO NOT YOU - ONLY USE THE IdString
          destinationIdString: '143450140161994',
          destinationType: 'ENGAGEMENT',
          senderId: 144482265487691780,              // DO NOT YOU - ONLY USE THE IdString
          senderIdString: '144482265487691776',
          senderType: 'END_USER',
          messageType: 'ACTIVITY_SIGNAL',
          visibility: 'NOT_ENDUSER',
          createdTime: 1580748089709,
          createdTimeString: '1580748089709',
          engagementId: 143450140161994,            // DO NOT YOU - ONLY USE THE IdString
          engagementIdString: '143450140161994',
          clientId: 144482265487691780,             // DO NOT YOU - ONLY USE THE IdString
          clientIdString: '144482265487691776',
          mode: 'LISTENING',
          sneakPreviewState: 'DISABLED',
          sneakPreviewInterval: 3000,
          sneakPreview: '',
          sneakPreviewFocus: false
        }
      }
  */
  var ChatActivitySignal = /** @class */ (function (_super) {
      __extends(ChatActivitySignal, _super);
      function ChatActivitySignal() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Activity' object
       * @param legacyMessage Legacy ChatActivitySignal message
       */
      ChatActivitySignal.convert = function (legacyMessage) {
          // ======================
          // Construct the resource
          // ======================
          var resource = new HumanResource();
          resource.identifier = legacyMessage.senderIdString;
          resource.type = exports.ResourceType[legacyMessage.senderType];
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          // ======================
          // Construct the Activity
          // ======================
          var message = new ActivityChange();
          message.channelIdentifier = legacyMessage.engagementIdString;
          message.fromParticipant = participant;
          message.mode = exports.ActivityType[legacyMessage.mode];
          message.created = new Date(legacyMessage.createdTime);
          return message;
      };
      return ChatActivitySignal;
  }(BaseMessage));

  /*
  EXAMPLE:
  {
      "ChatEngagementAssignment": {
          "contactInfo": {
              "customFields": [{
                      "name": "text_field",
                      "value": "",
                      "id": 1
                  },
                  {
                      "name": "date_field",
                      "value": "",
                      "id": 2
                  },
                  {
                      "name": "integer",
                      "value": "",
                      "id": 3
                  },
                  {
                      "name": "menu",
                      "value": "",
                      "id": 4
                  },
                  {
                      "name": "text_area",
                      "value": "",
                      "id": 5
                  },
                  {
                      "name": "yes_no",
                      "value": "",
                      "id": 6
                  },
                  {
                      "name": "date_time",
                      "value": "",
                      "id": 7
                  }
              ],
              "firstName": "Test",
              "lastName": "Test",
              "emailAddress": "Test@abc.com",
              "interfaceId": 1,
              "interfaceLanguageCode": "en_US",
              "contactId": 0,
              "contactIdString": "0",
              "orgId": -1,
              "orgIdString": "-1",
              "sessionId": "O3BQDTpo",
              "question": "Test Chat",
              "productId": -1,
              "productIdString": "-1",
              "categoryId": -1,
              "categoryIdString": "-1",
              "queueId": 3,
              "queueNames": {
                  "en_US": "Q3"
              },
              "browser": "Chrome 77",
              "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36",
              "ipAddress": "10.191.253.218",
              "operatingSystem": "Mac OS X",
              "coBrowseEnabled": true,
              "visitorId": null,
              "engagementEngineId": null,
              "referrerUrl": "https://day102-191100-sql-201h.qa.lan/app/results/kw/dd/page/1",
              "engagementEngineSessionId": null,
              "coBrowsePremiumSupported": 0,
              "mediaList": [{
                      "type": "CHAT",
                      "environmentErrorList": [],
                      "autoInitiate": true
                  },
                  {
                      "type": "COBROWSE",
                      "environmentErrorList": [],
                      "autoInitiate": false
                  },
                  {
                      "type": "VIDEO",
                      "environmentErrorList": [],
                      "autoInitiate": false
                  }
              ],
              "estaraFsguid": null
          },
          "agentInfo": null,
          "engagementId": 52,
          "engagementIdString": "52",
          "engagementCreateTime": 1569564403565,
          "engagementCreateTimeString": "1569564403565",
          "engagementFirstEngagedTime": 1569564403617,
          "engagementFirstEngagedTimeString": "1569564403617",
          "secondsEngaged": 0,
          "secondsEngagedString": "0",
          "queueId": 3,
          "queueIdString": "3",
          "type": "LEAD",
          "requestSource": "CONDITIONAL_LINK",
          "incidentId": null,
          "incidentIdString": null,
          "destinationId": 62,
          "destinationIdString": "62",
          "destinationType": "AGENT",
          "senderId": 52,
          "senderIdString": "52",
          "senderType": "ENGAGEMENT",
          "messageType": "ENGAGEMENT_ASSIGNMENT",
          "visibility": "ALL",
          "createdTime": 1569564403600,
          "createdTimeString": "1569564403600"
      }
   }
  */
  /**
   * This class specifies the subset of fields used by us for
   * message mapping purposes
   */
  var ChatAssignmentAcknowledgementResponse = /** @class */ (function (_super) {
      __extends(ChatAssignmentAcknowledgementResponse, _super);
      function ChatAssignmentAcknowledgementResponse() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Channel' object
       * @param legacyMessage Legacy ChatAssignmentAcknowledgementResponse message
       */
      ChatAssignmentAcknowledgementResponse.convert = function (legacyMessage, sessionToken) {
          var e_1, _a;
          var channel = new Channel(sessionToken, legacyMessage.chatAssignmentAcknowledgementResult.engagementIdString);
          try {
              for (var _b = __values(legacyMessage.chatAssignmentAcknowledgementResult.clientList), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var client = _c.value;
                  // =============================
                  // Construct the 'from' resource
                  // =============================
                  var resource = new HumanResource();
                  resource.identifier = client.idString;
                  resource.name = client.name;
                  // =============================
                  // Construct the Participant
                  // =============================
                  var participant = new Participant(resource);
                  participant.role = exports.ParticipationRoleType[client.role];
                  channel.members.push(participant);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return channel;
      };
      return ChatAssignmentAcknowledgementResponse;
  }(BaseResponse));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
      {
          ChatAssignmentInvitationCancelled: {
            engagementId: 473,
            engagementIdString: "473",
            type: "CONFERENCE",
            destinationId: 561,
            destinationIdString: "561",
            destinationType: "AGENT",
            senderId: 559,
            senderIdString: "559",
            senderType: "AGENT",
            messageType: "ASSIGNMENT_INVITATION_CANCELLED",
            visibility: "ALL",
            createdTime: 1595722705709,
            createdTimeString: "1595722705709"
          }
      },
  */
  /**
   * Message indicating the offer has been retracted
   */
  var OfferCancellation = /** @class */ (function () {
      function OfferCancellation() {
          this.created = new Date();
      }
      return OfferCancellation;
  }());

  /*
  {
          ChatAssignmentInvitationCancelled: {
            engagementId: 473,
            engagementIdString: "473",
            type: "CONFERENCE",
            destinationId: 561,
            destinationIdString: "561",
            destinationType: "AGENT",
            senderId: 559,
            senderIdString: "559",
            senderType: "AGENT",
            messageType: "ASSIGNMENT_INVITATION_CANCELLED",
            visibility: "ALL",
            createdTime: 1595722705709,
            createdTimeString: "1595722705709"
          }
  }
  */
  var ChatAssignmentInvitationCancelled = /** @class */ (function (_super) {
      __extends(ChatAssignmentInvitationCancelled, _super);
      function ChatAssignmentInvitationCancelled() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Activity' object
       * @param legacyMessage Legacy ChatActivitySignal message
       */
      ChatAssignmentInvitationCancelled.convert = function (legacyMessage) {
          var message = new OfferCancellation();
          message.channelIdentifier = legacyMessage.engagementIdString;
          message.type = legacyMessage.messageType;
          message.created = new Date(legacyMessage.createdTime);
          return message;
      };
      return ChatAssignmentInvitationCancelled;
  }(BaseMessage));

  /*
    {
      'ChatDisconnectNotification: {
        'destinationId: 145935665147998,
        'destinationIdString: '145935665147998',
        'destinationType: 'ENGAGEMENT',
        'senderId: 0,
        'senderIdString: '0',
        'senderType: 'SYSTEM',
        'messageType: 'DISCONNECT_NOTIFICATION',
        'visibility: 'ALL',
        'createdTime: 1581097756779,
        'createdTimeString: '1581097756779',
        'engagementId: 145935665147998,
        'engagementIdString: '145935665147998',
        'clientId: 0,
        'clientIdString: '0',
        'reason: 'PARTICIPANT_LEFT'
      }
    }
  */
  /**
   * Message indicating the disconnect of a channel member
   * and the reason
   */
  var MemberDisconnect = /** @class */ (function () {
      function MemberDisconnect() {
          this.created = new Date();
      }
      return MemberDisconnect;
  }());

  /*
    EXAMPLE:
  /*
    {
      'ChatDisconnectNotification: {
        'destinationId: 145935665147998,
        'destinationIdString: '145935665147998',
        'destinationType: 'ENGAGEMENT',
        'senderId: 0,
        'senderIdString: '0',
        'senderType: 'SYSTEM',
        'messageType: 'DISCONNECT_NOTIFICATION',
        'visibility: 'ALL',
        'createdTime: 1581097756779,
        'createdTimeString: '1581097756779',
        'engagementId: 145935665147998,
        'engagementIdString: '145935665147998',
        'clientId: 0,
        'clientIdString: '0',
        'reason: 'PARTICIPANT_LEFT'
      }
    }
  */
  var ChatDisconnectNotification = /** @class */ (function (_super) {
      __extends(ChatDisconnectNotification, _super);
      function ChatDisconnectNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Offer' object
       * @param legacyMessage Legacy ChatDisconnectNotification message
       */
      ChatDisconnectNotification.convert = function (legacyMessage) {
          // =============================
          // Construct the 'from' resource
          // =============================
          var resource = new Resource();
          resource.identifier = legacyMessage.clientIdString;
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = exports.ParticipationRoleType[legacyMessage.role];
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new MemberDisconnect();
          newMessage.channelIdentifier = legacyMessage.engagementIdString;
          newMessage.member = participant;
          newMessage.created = new Date(legacyMessage.createdTime);
          newMessage.reason = legacyMessage.reason;
          return newMessage;
      };
      return ChatDisconnectNotification;
  }(BaseMessage));

  /*
  EXAMPLE:
  {
      "ChatEngagementAssignment": {
          "contactInfo": {
              "customFields": [{
                      "name": "text_field",
                      "value": "",
                      "id": 1
                  },
                  {
                      "name": "date_field",
                      "value": "",
                      "id": 2
                  },
                  {
                      "name": "integer",
                      "value": "",
                      "id": 3
                  },
                  {
                      "name": "menu",
                      "value": "",
                      "id": 4
                  },
                  {
                      "name": "text_area",
                      "value": "",
                      "id": 5
                  },
                  {
                      "name": "yes_no",
                      "value": "",
                      "id": 6
                  },
                  {
                      "name": "date_time",
                      "value": "",
                      "id": 7
                  }
              ],
              "firstName": "Test",
              "lastName": "Test",
              "emailAddress": "Test@abc.com",
              "interfaceId": 1,
              "interfaceLanguageCode": "en_US",
              "contactId": 0,
              "contactIdString": "0",
              "orgId": -1,
              "orgIdString": "-1",
              "sessionId": "O3BQDTpo",
              "question": "Test Chat",
              "productId": -1,
              "productIdString": "-1",
              "categoryId": -1,
              "categoryIdString": "-1",
              "offerTimeOut": "30",
              "queueId": 3,
              "queueIdString": "3",
              "browser": "Chrome 77",
              "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36",
              "ipAddress": "10.191.253.218",
              "operatingSystem": "Mac OS X",
              "coBrowseEnabled": true,
              "visitorId": null,
              "engagementEngineId": null,
              "referrerUrl": "https://day102-191100-sql-201h.qa.lan/app/results/kw/dd/page/1",
              "engagementEngineSessionId": null,
              "coBrowsePremiumSupported": 0,
              "mediaList": [{
                      "type": "CHAT",
                      "environmentErrorList": [],
                      "autoInitiate": true
                  },
                  {
                      "type": "COBROWSE",
                      "environmentErrorList": [],
                      "autoInitiate": false
                  },
                  {
                      "type": "VIDEO",
                      "environmentErrorList": [],
                      "autoInitiate": false
                  }
              ],
              "estaraFsguid": null
          },
          "agentInfo": null,
          "engagementId": 52,
          "engagementIdString": "52",
          "engagementCreateTime": 1569564403565,
          "engagementCreateTimeString": "1569564403565",
          "engagementFirstEngagedTime": 1569564403617,
          "engagementFirstEngagedTimeString": "1569564403617",
          "secondsEngaged": 0,
          "secondsEngagedString": "0",
          "queueId": 3,
           "queueIdString": "3",
          "queueNames": {
              "en_US": "Q3"
          },
          "type": "LEAD",
          "requestSource": "CONDITIONAL_LINK",
          "incidentId": null,
          "incidentIdString": null,
          "destinationId": 62,
          "destinationIdString": "62",
          "destinationType": "AGENT",
          "senderId": 52,
          "senderIdString": "52",
          "senderType": "ENGAGEMENT",
          "messageType": "ENGAGEMENT_ASSIGNMENT",
          "visibility": "ALL",
          "createdTime": 1569564403600,
          "createdTimeString": "1569564403600"
      }
   }
  */
  /**
   * This interface specifies the subset of fields used by us for
   * message mapping purposes
   */
  var ChatEngagementAssignment = /** @class */ (function (_super) {
      __extends(ChatEngagementAssignment, _super);
      function ChatEngagementAssignment() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message frmat to the new 'Offer' object
       * @param legacyMessage Legacy ChatEngagementAssignment message
       */
      ChatEngagementAssignment.convert = function (legacyMessage, localeString) {
          var contactInfo = legacyMessage.contactInfo;
          // =============================
          // Construct the 'from' resource
          // =============================
          var fromResource = new HumanResource();
          fromResource.setFirstName(contactInfo.firstName);
          fromResource.setLastName(contactInfo.lastName);
          fromResource.emailAddress = contactInfo.emailAddress;
          // =============================
          // Construct the Participant
          // =============================
          var fromParticipate = new Participant(fromResource);
          fromParticipate.resource = fromResource;
          fromParticipate.role = exports.ParticipationRoleType.END_USER;
          // =============================
          // Construct the Offer
          // =============================
          var offer = new MercuryOffer(legacyMessage.engagementIdString, legacyMessage.externalWorkIdString, 'CHAT', legacyMessage.workTypeCode, legacyMessage.channelId, legacyMessage.conversationId, legacyMessage.createdTime);
          offer.from = fromParticipate;
          offer.assignmentType = exports.AssignmentType[legacyMessage.type];
          // Transfer the context object
          offer.context = this.getContextObject(contactInfo);
          offer.context.set(exports.ChannelContextNameType.OFFER_TIMEOUT, legacyMessage.offerTimeOut);
          offer.context.set(exports.ChannelContextNameType.INCIDENT_ID, legacyMessage.incidentIdString);
          // Add the Queue names to the context
          offer.context.set(exports.ChannelContextNameType.QUEUE_NAMES, legacyMessage.queueNames);
          try {
              offer.context.set(exports.ChannelContextNameType.QUEUE_NAME, QueueStore.getQueueName(+legacyMessage.contactInfo.queueIdString));
          }
          catch (e) {
              Logger.log(e);
          }
          return offer;
      };
      /**
       * Collect the Work context attributes and return them as a map
       * @param contactInfo original CntactInfo structure
       */
      ChatEngagementAssignment.getContextObject = function (contactInfo) {
          var context = new Map();
          context.set(exports.ChannelContextNameType.FIRST_NAME, contactInfo.firstName);
          context.set(exports.ChannelContextNameType.LAST_NAME, contactInfo.lastName);
          context.set(exports.ChannelContextNameType.EMAIL, contactInfo.emailAddress);
          context.set(exports.ChannelContextNameType.QUESTION, contactInfo.question);
          context.set(exports.ChannelContextNameType.PRODUCT_ID, contactInfo.productIdString);
          context.set(exports.ChannelContextNameType.CATEGORY_ID, contactInfo.categoryIdString);
          context.set(exports.ChannelContextNameType.CONTACT_ID, contactInfo.contactIdString);
          context.set(exports.ChannelContextNameType.QUEUE_ID, contactInfo.queueIdString);
          // Custom fields look like: {name: 'date_field', value: '', id: 2}
          context.set('customFields', contactInfo.customFields);
          context.set('fileAttachmentsSupported', contactInfo.fileAttachmentsSupported);
          return context;
      };
      /**
       * Given a name hash, find the name that matches the current language
       * @param queueNames
       * @param localeString
       */
      ChatEngagementAssignment.getQueueName = function (queueNames, localeString) {
          var returnedName;
          var lowerLocaleString = localeString.toLowerCase();
          var languageMap = new Map();
          // First convert into a MAP - should have been a map anyway!!
          var keys = Object.keys(queueNames);
          for (var i = 0; i < keys.length; i++) {
              languageMap.set(keys[i].toLowerCase(), Object.values(queueNames)[i]);
          }
          if (languageMap.size === 1) {
              // just return it
              returnedName = Object.values(queueNames)[0];
          }
          else {
              // The server sends the language codes in 'java format' i.e. en_us
              // instead of browser format i.e. en-us We need to normalize
              var serverFormatLocale = lowerLocaleString.replace('-', '_');
              // =================================
              // we need to do some fuzzy matching
              // =================================
              returnedName = languageMap.get(serverFormatLocale);
              if (!returnedName) {
                  // ========================
                  // No exact match was found
                  // ========================
                  // Need to use fuzzy matching
                  // drop the country from the test and try again
                  var parts = serverFormatLocale.split('_');
                  returnedName = languageMap.get(parts[0]);
                  if (!returnedName) {
                      Logger.error("unable to find locale match with [" + serverFormatLocale + "] and [" + JSON.stringify(queueNames) + "]");
                  }
              }
          }
          return returnedName;
      };
      return ChatEngagementAssignment;
  }(BaseMessage));

  /**
   * This class represents the Participant
   * added event - a participant added to
   * a channel
   */
  var ParticipantAdded = /** @class */ (function () {
      function ParticipantAdded() {
      }
      return ParticipantAdded;
  }());

  /*
    EXAMPLE:
  {
      "ChatEngagementParticipantAdded": {
          "name": "Rainey Kellogg",
          "greeting": "Hi, my name is Rainey Kellogg. How may I help you?",
          "engagementId": 52,
          "engagementIdString": "52",
          "clientId": 62,
          "clientIdString": "62",
          "role": "LEAD",
          "accountId": 12,
          "accountIdString": "12",
          "virtualAgent": false,
          "destinationId": 52,
          "destinationIdString": "52",
          "destinationType": "ENGAGEMENT",
          "senderId": 62,
          "senderIdString": "62",
          "senderType": "AGENT",
          "messageType": "ENGAGEMENT_ADD_CLIENT",
          "visibility": "ALL",
          "createdTime": 1569564410814,
          "createdTimeString": "1569564410814"
      }
  }
  */
  var ChatEngagementParticipantAdded = /** @class */ (function (_super) {
      __extends(ChatEngagementParticipantAdded, _super);
      function ChatEngagementParticipantAdded() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Offer' object
       * @param legacyMessage Legacy ChatEngagementParticipantAdded message
       */
      ChatEngagementParticipantAdded.convert = function (legacyMessage) {
          // ======================
          // Construct the resource
          // ======================
          var resource = new HumanResource();
          resource.setFirstName(legacyMessage.name);
          resource.identifier = legacyMessage.clientIdString;
          resource.name = legacyMessage.name;
          if (legacyMessage.resourceType) {
              resource.type = exports.ResourceType[legacyMessage.resourceType];
          }
          else {
              resource.type = exports.ResourceType[legacyMessage.senderType];
          }
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = exports.ParticipationRoleType[legacyMessage.role];
          // ===============================
          // Construct the Channel Reference
          // ===============================
          var channelIdentifier = legacyMessage.engagementIdString;
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new ParticipantAdded();
          newMessage.participant = participant;
          newMessage.greeting = legacyMessage.greeting;
          newMessage.channelIdentifier = channelIdentifier;
          newMessage.created = new Date(legacyMessage.createdTime);
          return newMessage;
      };
      ChatEngagementParticipantAdded.generateFakePost = function (legacyMessage) {
          // ======================
          // Construct the resource
          // ======================
          var resource = new HumanResource();
          resource.identifier = legacyMessage.clientIdString;
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = exports.ParticipationRoleType[legacyMessage.role];
          var message = new Message();
          message.sender = participant;
          message.identifier = legacyMessage.messageType + "_" + legacyMessage.clientIdString;
          message.body = legacyMessage.greeting;
          message.type = exports.MessageType.TEXT;
          message.channelIdentifier = legacyMessage.destinationIdString;
          message.created = new Date(legacyMessage.createdTime);
          if (legacyMessage.visibility === 'NOT_ENDUSER') {
              message.isAgentsOnly = true;
          }
          return message;
      };
      return ChatEngagementParticipantAdded;
  }(BaseMessage));

  /*
      {
          "ChatFileAttachNotification": {
              "status": "RECEIVED",
              "engagementId": 55,
              "engagementIdString": "55",
              "localFName": "xYu8oMday102-191100-sql-201h.qa.lan",
              "userFName": "prov_log",
              "contentType": "application/octet-stream",
              "fileSize": 297131,
              "fileSizeString": "297131",
              "destinationId": 55,
              "destinationIdString": "55",
              "destinationType": "ENGAGEMENT",
              "senderId": 55,
              "senderIdString": "55",
              "senderType": "ENGAGEMENT",
              "messageType": "FILE_ATTACH_UPLOAD",
              "visibility": "ALL",
              "createdTime": 1569566478286,
              "createdTimeString": "1569566478286"
          }
      }
  */
  var UploadCompleted = /** @class */ (function () {
      function UploadCompleted() {
          this.created = new Date();
      }
      return UploadCompleted;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * This class represents the file details
   */
  var FileDetails = /** @class */ (function () {
      function FileDetails() {
      }
      return FileDetails;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (UploadStatusType) {
      /** Upload has started */
      UploadStatusType["STARTED"] = "STARTED";
      /** Upload is complete */
      UploadStatusType["RECEIVED"] = "RECEIVED";
  })(exports.UploadStatusType || (exports.UploadStatusType = {}));

  /*
    EXAMPLE:
      {
          "ChatFileAttachNotification": {
              "status": "RECEIVED",
              "engagementId": 55,
              "engagementIdString": "55",
              "localFName": "xYu8oMday102-191100-sql-201h.qa.lan",
              "userFName": "prov_log",
              "contentType": "application/octet-stream",
              "fileSize": 297131,
              "fileSizeString": "297131",
              "destinationId": 55,
              "destinationIdString": "55",
              "destinationType": "ENGAGEMENT",
              "senderId": 55,
              "senderIdString": "55",
              "senderType": "ENGAGEMENT",
              "messageType": "FILE_ATTACH_UPLOAD",
              "visibility": "ALL",
              "createdTime": 1569566478286,
              "createdTimeString": "1569566478286"
          }
      }
  */
  var ChatFileAttachNotification = /** @class */ (function (_super) {
      __extends(ChatFileAttachNotification, _super);
      function ChatFileAttachNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'UploadComplete' object
       * NOTE: The legacy message does NOT attribute the upload to a specific
       * participant the message destination and sender is the engagement itself
       *
       * THIS SHOULD BE FIXED WITHIN MERCURY
       *
       * @param legacyMessage Legacy ChatFileAttachNotification message
       */
      ChatFileAttachNotification.convert = function (legacyMessage) {
          // ==========================
          // Construct the file details
          // ==========================
          var fileDetails = new FileDetails();
          fileDetails.localReference = legacyMessage.localFName;
          fileDetails.userFileName = legacyMessage.userFName;
          fileDetails.contentType = legacyMessage.contentType;
          fileDetails.fileSize = legacyMessage.fileSize;
          var resource = new HumanResource();
          if (legacyMessage.senderType !== 'AGENT') {
              resource.identifier = legacyMessage.endUserClientIdString || legacyMessage.senderIdString;
          }
          else {
              resource.identifier = legacyMessage.senderIdString;
          }
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = legacyMessage.senderType !== 'AGENT' ? exports.ParticipationRoleType.END_USER : exports.ParticipationRoleType[legacyMessage.senderType];
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new UploadCompleted();
          newMessage.channelIdentifier = legacyMessage.engagementIdString;
          newMessage.status = exports.UploadStatusType[legacyMessage.status];
          newMessage.fileDetails = fileDetails;
          newMessage.created = new Date(legacyMessage.createdTime);
          newMessage.sender = participant;
          return newMessage;
      };
      return ChatFileAttachNotification;
  }(BaseMessage));

  /*
      {
          "ChatFileAttachStatusNotification": {
              "status": "STARTED",
              "engagementId": 55,
              "engagementIdString": "55",
              "destinationId": 55,
              "destinationIdString": "55",
              "destinationType": "ENGAGEMENT",
              "senderId": 55,
              "senderIdString": "55",
              "senderType": "ENGAGEMENT",
              "messageType": "FILE_ATTACH_UPLOAD_NOTIFICATION",
              "visibility": "ALL",
              "createdTime": 1569566476082,
              "createdTimeString": "1569566476082"
          }
      }
  */
  /**
   * This class represents the upload
   * status event - the current status of
   * an upload operation
   */
  var UploadStatus = /** @class */ (function () {
      function UploadStatus() {
      }
      return UploadStatus;
  }());

  /*
    EXAMPLE:
      {
          "ChatFileAttachStatusNotification": {
              "status": "STARTED",
              "engagementId": 55,
              "engagementIdString": "55",
              "destinationId": 55,
              "destinationIdString": "55",
              "destinationType": "ENGAGEMENT",
              "senderId": 55,
              "senderIdString": "55",
              "senderType": "ENGAGEMENT",
              "messageType": "FILE_ATTACH_UPLOAD_NOTIFICATION",
              "visibility": "ALL",
              "createdTime": 1569566476082,
              "createdTimeString": "1569566476082"
          }
      }
  */
  var ChatFileAttachStatusNotification = /** @class */ (function (_super) {
      __extends(ChatFileAttachStatusNotification, _super);
      function ChatFileAttachStatusNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'UploadStatus' object
       * NOTE: The legacy message does NOT attribute the upload to a specific
       * participant the message destination and sender is the engagement itself
       *
       * THIS SHOULD BE FIXED WITHIN MERCURY
       *
       * @param legacyMessage Legacy ChatFileAttachStatusNotification message
       */
      ChatFileAttachStatusNotification.convert = function (legacyMessage) {
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new UploadStatus();
          newMessage.channelIdentifier = legacyMessage.engagementIdString;
          newMessage.status = exports.UploadStatusType[legacyMessage.status];
          return newMessage;
      };
      return ChatFileAttachStatusNotification;
  }(BaseMessage));

  /*
      {
          ChatInvitationStatusNotification: {
            assignmentType: "TRANSFER",
            status: "ACCEPTED",
            clientId: 94,
            clientIdString: "94",
            engagementId: 89,
            engagementIdString: "89",
            destinationId: 96,
            destinationIdString: "96",
            destinationType: "AGENT",
            senderId: -1,
            senderIdString: "-1",
            senderType: "SYSTEM",
            messageType: "TRANSFER_STATUS_NOTIFICATION",
            visibility: "ALL",
            createdTime: 1588286057627,
            createdTimeString: "1588286057627"
          }
      },
  */
  /**
   * Message indicating the status of an Offer
   */
  var OfferStatus = /** @class */ (function () {
      function OfferStatus() {
          this.created = new Date();
      }
      return OfferStatus;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (OfferStatusTypes) {
      OfferStatusTypes["NONE"] = "NONE";
      OfferStatusTypes["ACCEPTED"] = "ACCEPTED";
      OfferStatusTypes["DECLINED"] = "DECLINED";
      OfferStatusTypes["AVAILABLE"] = "AVAILABLE";
      OfferStatusTypes["UNAVAILABLE"] = "UNAVAILABLE";
      OfferStatusTypes["TIMEOUT"] = "TIMEOUT";
  })(exports.OfferStatusTypes || (exports.OfferStatusTypes = {}));

  /*
    EXAMPLE:
  /*
      {
          ChatInvitationStatusNotification: {
            assignmentType: "TRANSFER",
            status: "ACCEPTED",
            clientId: 94,
            clientIdString: "94",
            engagementId: 89,
            engagementIdString: "89",
            destinationId: 96,
            destinationIdString: "96",
            destinationType: "AGENT",
            senderId: -1,
            senderIdString: "-1",
            senderType: "SYSTEM",
            messageType: "TRANSFER_STATUS_NOTIFICATION",
            visibility: "ALL",
            createdTime: 1588286057627,
            createdTimeString: "1588286057627"
          }
      },
  */
  var ChatInvitationStatusNotification = /** @class */ (function (_super) {
      __extends(ChatInvitationStatusNotification, _super);
      function ChatInvitationStatusNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Offer' object
       * @param legacyMessage Legacy ChatInvitationStatusNotification message
       */
      ChatInvitationStatusNotification.convert = function (legacyMessage) {
          // =============================
          // Construct the 'from' resource
          // =============================
          var resource = new Resource();
          resource.identifier = legacyMessage.clientIdString;
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new OfferStatus();
          newMessage.channelIdentifier = legacyMessage.engagementIdString;
          newMessage.member = participant;
          newMessage.assignmentType = exports.AssignmentType[legacyMessage.assignmentType];
          newMessage.status = exports.OfferStatusTypes[legacyMessage.status];
          newMessage.created = new Date(legacyMessage.createdTime);
          return newMessage;
      };
      return ChatInvitationStatusNotification;
  }(BaseMessage));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
      "ChatPostMessage": {
          "body": "Hi I\u2019m the Customer",
          "vaResponse": null,
          "offTheRecord": false,
          "richText": true,
          "messageId": null,
          "destinationId": 152,
          "destinationIdString": "152",
          "destinationType": "ENGAGEMENT",
          "senderId": 705,
          "senderIdString": "705",
          "senderType": "END_USER",
          "messageType": "TEXT",
          "visibility": "ALL",
          "createdTime": 1568965776859,
          "createdTimeString": "1568965776859",
          "messageDataMap" : {
                               "type" : "ODA",
                               "json" : "{\"messagePayload\":{\"text\":\"I couldn't find any articles about that.
                                         Try rephrasing your  question (or you can ask to speak to a live agent).\",
                                         \"type\":\"text\"},\"userId\":\"466909374874427392\"}"
                             }
      }
   }
  */
  var ChatPostMessage = /** @class */ (function (_super) {
      __extends(ChatPostMessage, _super);
      function ChatPostMessage() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'Message' object
       * @param legacyMessage Legacy ChatPostMessage message
       */
      ChatPostMessage.convert = function (legacyMessage) {
          // ======================
          // Construct the resource
          // ======================
          var resource = new HumanResource();
          resource.identifier = legacyMessage.senderIdString;
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          participant.role = exports.ParticipationRoleType[legacyMessage.senderType];
          var message = new Message();
          message.sender = participant;
          message.identifier = legacyMessage.messageId;
          message.body = legacyMessage.body;
          message.offTheRecord = legacyMessage.offTheRecord;
          message.richText = legacyMessage.richText;
          message.type = exports.MessageType[legacyMessage.messageType];
          message.channelIdentifier = legacyMessage.destinationIdString;
          message.preserve = !legacyMessage.offTheRecord;
          message.created = new Date(legacyMessage.createdTime);
          message.messageDataMap = legacyMessage.messageDataMap;
          if (legacyMessage.visibility === 'NOT_ENDUSER') {
              message.isAgentsOnly = true;
          }
          return message;
      };
      return ChatPostMessage;
  }(BaseMessage));

  /**
   * This class represents the Channel close event
   */
  var ChannelClose = /** @class */ (function () {
      function ChannelClose() {
          this.created = new Date();
      }
      return ChannelClose;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
    EXAMPLE:
    {
      'ChatReleaseNotification: {
        createdTime: 1581097756779,
        engagementId: '145935665147998',
        clientId: '0',
      }
    }
  */
  var ChatReleaseNotification = /** @class */ (function () {
      function ChatReleaseNotification() {
      }
      /**
       * Convert the legacy message format to the new format object
       * @param legacyMessage Legacy  message
       */
      ChatReleaseNotification.convert = function (legacyMessage) {
          // =============================
          // Construct the 'from' resource
          // =============================
          var resource = new Resource();
          resource.identifier = legacyMessage.clientId;
          // =============================
          // Construct the Participant
          // =============================
          var participant = new Participant(resource);
          // =========================
          // Construct the new Message
          // =========================
          var newMessage = new ChannelClose();
          newMessage.channelIdentifier = legacyMessage.engagementId;
          newMessage.initiator = participant;
          newMessage.created = new Date(legacyMessage.createdTime);
          return newMessage;
      };
      return ChatReleaseNotification;
  }());

  /**
   * Object representing a role change
   */
  var RoleChange = /** @class */ (function () {
      function RoleChange() {
      }
      return RoleChange;
  }());

  /*
  {
          ChatRoleChangeNotification: {
            destinationId: 980152897536,
            destinationIdString: "980152897536",
            destinationType: "ENGAGEMENT",
            senderId: 980152897536,
            senderIdString: "980152897536",
            senderType: "ENGAGEMENT",
            messageType: "ROLE_CHANGE_NOTIFICATION",
            visibility: "ALL",
            createdTime: 1604679064099,
            createdTimeString: "1604679064099",
            engagementId: 980152897536,
            engagementIdString: "980152897536",
            leadClientId: 737582419968,
            leadClientIdString: "737582419968",
            confereeClientId: 737582419968,
            confereeClientIdString: "737582419968",
            contactInfo: {
              customFields: [],
              firstName: "Dave",
              lastName: "Stowell",
              emailAddress: "davestowell@aaaa.com",
              interfaceId: 1,
              interfaceLanguageCode: "",
              contactId: 0,
              contactIdString: "0",
              orgId: -1,
              orgIdString: "-1",
              sessionId: "eU0I_QSQ0ps7RJ4eSbPI0IEklMq3VrnG~fkqqtiXuNsk_ZXdmpyzf45p8g",
              question: "ds",
              productId: -1,
              productIdString: "-1",
              categoryId: -1,
              categoryIdString: "-1",
              queueId: 1,
              queueIdString: "1",
              browser: "",
              userAgent: "",
              ipAddress: "10.154.140.60",
              operatingSystem: "",
              coBrowseEnabled: false,
              visitorId: "",
              engagementEngineId: "",
              referrerUrl: "",
              eStaraFsguid: "",
              engagementEngineSessionId: "",
              coBrowsePremiumSupported: -1,
              mediaList: []
            }
          }
  */
  var ChatRoleChangeNotification = /** @class */ (function (_super) {
      __extends(ChatRoleChangeNotification, _super);
      function ChatRoleChangeNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'RoleChange' object
       * @param legacyMessage Legacy ChatRoleChangeNotification message
       */
      ChatRoleChangeNotification.convert = function (legacyMessage, participantId) {
          var newRole = null;
          if (legacyMessage.leadClientIdString === participantId) {
              // we are the LEAD
              newRole = exports.ParticipationRoleType.LEAD;
          }
          else if (legacyMessage.confereeClientIdString === participantId) {
              newRole = exports.ParticipationRoleType.CONFEREE;
          }
          // =========================
          // Construct the Role Change
          // =========================
          var message = new RoleChange();
          message.channelIdentifier = legacyMessage.engagementIdString;
          message.role = newRole;
          return message;
      };
      return ChatRoleChangeNotification;
  }(BaseMessage));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
      EngagementPropertyUpdateNotification: {
        engagementId: 681148362752,
        engagementIdString: "681148362752",
        propertyName: "firstName",
        propertyValue: "FRED"
      }
  */
  /**
   * Message indicating the context has been updated
   */
  var ContextUpdate = /** @class */ (function () {
      function ContextUpdate() {
      }
      return ContextUpdate;
  }());

  /*
      EngagementPropertyUpdateNotification: {
        engagementId: 681148362752,
        engagementIdString: "681148362752",
        propertyName: "firstName",
        propertyValue: "FRED"
      }
  */
  var EngagementPropertyUpdateNotification = /** @class */ (function (_super) {
      __extends(EngagementPropertyUpdateNotification, _super);
      function EngagementPropertyUpdateNotification() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'ContextUpdate' object
       * @param legacyMessage Legacy EngagementPropertyUpdateNotification message
       */
      EngagementPropertyUpdateNotification.convert = function (legacyMessage) {
          var message = new ContextUpdate();
          message.channelIdentifier = legacyMessage.engagementIdString;
          message.name = legacyMessage.propertyName;
          message.value = legacyMessage.propertyValue;
          return message;
      };
      return EngagementPropertyUpdateNotification;
  }(BaseMessage));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  var AvailabilityChange = /** @class */ (function () {
      function AvailabilityChange() {
          this.availability = new Map();
          this.created = new Date();
      }
      return AvailabilityChange;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
    ResourceAvailabilityChange: {
      'availability': [{
        'availabilityType': 'AVAILABLE',
        'workType': 'CHAT'
      }],
      clientId: '143450140161994',
      createdTime: 1569566478286
    }
  }
  */
  var ResourceAvailabilityChange = /** @class */ (function () {
      function ResourceAvailabilityChange() {
      }
      /**
       * Convert the legacy message format to the new 'Message' object
       * @param legacyMessage Legacy ChatPostMessage message
       */
      ResourceAvailabilityChange.convert = function (legacyMessage) {
          // ===========================
          // Construct the change object
          // ===========================
          var availabilityChangeObject = new AvailabilityChange();
          availabilityChangeObject.created = new Date(legacyMessage.createdTime);
          legacyMessage.availability.forEach(function (entry) {
              var translatedAvailability = exports.AvailabilityType[entry.availabilityType];
              availabilityChangeObject.availability.set(entry.workType, translatedAvailability);
          });
          return availabilityChangeObject;
      };
      return ResourceAvailabilityChange;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (WorkOfferBehaviorType) {
      WorkOfferBehaviorType["Manual"] = "Manual";
      /** When the offer timeout expires, the offer is considered accepted */
      WorkOfferBehaviorType["TimedAutoAccept"] = "TimedAutoAccept";
      /** When the offer timeout expires, the offer is considered rejected */
      WorkOfferBehaviorType["TimedAutoReject"] = "TimedAutoReject";
      /** This 'Offer' is really just a notification - the offer has already been accepted */
      WorkOfferBehaviorType["ForcedAccept"] = "ForcedAccept";
  })(exports.WorkOfferBehaviorType || (exports.WorkOfferBehaviorType = {}));

  /*
  EXAMPLE:
      "WorkOfferMessage": {
    "workId": "19",
    "destinationId": "2",
    "workInformation": {
      "workId": "19",
      "workType": "Chat",
      "workBehavior": "Asynchronous",
      "subject": "chat question",
      "incidentId": ""
    },
    "createdTime": 1608250827909,
    "offerTimeOut": 0,
    "offerBehavior": "ForcedAccept",
    "queueId": null,
    "queueNames": {},
    "contactInfo": {
      "customFields": [
        {
          "name": "ProdGroupId",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "value",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "ContextObjectName",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "Priority",
          "type": "STRING",
          "value": "1",
          "menuItemLabel": ""
        },
        {
          "name": "InventoryItemId",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "InventoryOrgId",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "ContextObjectType",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        },
        {
          "name": "BuOrgId",
          "type": "STRING",
          "value": "value",
          "menuItemLabel": ""
        }
      ],
      "firstName": "End",
      "lastName": "User",
      "emailAddress": "ckent@dailyplanet.com",
      "interfaceId": 0,
      "interfaceLanguageCode": "",
      "contactId": 0,
      "contactIdString": "",
      "orgId": 0,
      "orgIdString": "",
      "sessionId": "123456789",
      "question": "chat question",
      "productId": 0,
      "productIdString": "",
      "categoryId": 0,
      "categoryIdString": "",
      "queueId": 0,
      "queueIdString": "",
      "browser": "Firefox",
      "userAgent": "Hugh Morris",
      "ipAddress": "4.3.2.1",
      "operatingSystem": "BeOS",
      "coBrowseEnabled": false,
      "visitorId": "vID",
      "engagementEngineId": "eID",
      "referrerUrl": "www.oracle.com",
      "eStaraFsguid": "estaraFsguid",
      "engagementEngineSessionId": "eSessionId",
      "coBrowsePremiumSupported": 0,
      "mediaList": []
    },
    "agentInfo": null,
    "offerType": "LEAD",
    "messageType": "ENGAGEMENT_ASSIGNMENT"
  }
  */
  /**
   * This interface specifies the subset of fields used by us for
   * message mapping purposes
   */
  var WorkOfferMessage = /** @class */ (function (_super) {
      __extends(WorkOfferMessage, _super);
      function WorkOfferMessage() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message frmat to the new 'Offer' object
       * @param legacyMessage Legacy WorkOfferMessage message
       */
      WorkOfferMessage.convert = function (legacyMessage, localeString) {
          var contactInfo = legacyMessage.contactInfo;
          // =============================
          // Construct the 'from' resource
          // =============================
          var fromResource = new HumanResource();
          fromResource.setFirstName(contactInfo.firstName);
          fromResource.setLastName(contactInfo.lastName);
          fromResource.emailAddress = contactInfo.emailAddress;
          // =============================
          // Construct the Participant
          // =============================
          var fromParticipate = new Participant(fromResource);
          fromParticipate.resource = fromResource;
          fromParticipate.role = exports.ParticipationRoleType.END_USER;
          // =============================
          // Construct the Offer
          // =============================
          var offer = new MercuryOffer(legacyMessage.workInformation.workId, legacyMessage.externalWorkId, legacyMessage.workInformation.workType, legacyMessage.workTypeCode, legacyMessage.channelId, legacyMessage.conversationId, legacyMessage.createdTime);
          offer.behavior = exports.WorkOfferBehaviorType[legacyMessage.offerBehavior];
          offer.timeout = legacyMessage.offerTimeOut;
          offer.from = fromParticipate;
          offer.assignmentType = exports.AssignmentType[legacyMessage.type];
          // Transfer the context object
          offer.context = this.getContextObject(contactInfo);
          offer.context.set(exports.ChannelContextNameType.OFFER_TIMEOUT, legacyMessage.offerTimeOut);
          offer.context.set(exports.ChannelContextNameType.INCIDENT_ID, legacyMessage.incidentIdString);
          // Add the Queue names to the context
          offer.context.set(exports.ChannelContextNameType.QUEUE_NAMES, legacyMessage.queueNames);
          offer.context.set(exports.ChannelContextNameType.QUEUE_NAME, this.getQueueName(legacyMessage.queueNames, localeString));
          return offer;
      };
      /**
       * Collect the Work context attributes and return them as a map
       * @param contactInfo original CntactInfo structure
       */
      WorkOfferMessage.getContextObject = function (contactInfo) {
          var context = new Map();
          context.set(exports.ChannelContextNameType.FIRST_NAME, contactInfo.firstName);
          context.set(exports.ChannelContextNameType.LAST_NAME, contactInfo.lastName);
          context.set(exports.ChannelContextNameType.EMAIL, contactInfo.emailAddress);
          context.set(exports.ChannelContextNameType.QUESTION, contactInfo.question);
          context.set(exports.ChannelContextNameType.PRODUCT_ID, contactInfo.productIdString);
          context.set(exports.ChannelContextNameType.CATEGORY_ID, contactInfo.categoryIdString);
          context.set(exports.ChannelContextNameType.CONTACT_ID, contactInfo.contactIdString);
          context.set(exports.ChannelContextNameType.QUEUE_ID, contactInfo.queueIdString);
          // Custom fields look like: {name: 'date_field', value: '', id: 2}
          context.set('customFields', contactInfo.customFields);
          return context;
      };
      /**
       * Given a name hash, find the name that matches the current language
       * @param queueNames
       * @param localeString
       */
      WorkOfferMessage.getQueueName = function (queueNames, localeString) {
          var returnedName;
          var lowerLocaleString = localeString.toLowerCase();
          var languageMap = new Map();
          // First convert into a MAP - should have been a map anyway!!
          var keys = Object.keys(queueNames);
          for (var i = 0; i < keys.length; i++) {
              languageMap.set(keys[i].toLowerCase(), Object.values(queueNames)[i]);
          }
          if (languageMap.size === 1) {
              // just return it
              returnedName = Object.values(queueNames)[0];
          }
          else {
              // The server sends the language codes in 'java format' i.e. en_us
              // instead of browser format i.e. en-us We need to normalize
              var serverFormatLocale = lowerLocaleString.replace('-', '_');
              // =================================
              // we need to do some fuzzy matching
              // =================================
              returnedName = languageMap.get(serverFormatLocale);
              if (!returnedName) {
                  // ========================
                  // No exact match was found
                  // ========================
                  // Need to use fuzzy matching
                  // drop the country from the test and try again
                  var parts = serverFormatLocale.split('_');
                  returnedName = languageMap.get(parts[0]);
                  if (!returnedName) {
                      Logger.error("unable to find locale match with [" + serverFormatLocale + "] and [" + JSON.stringify(queueNames) + "]");
                  }
              }
          }
          return returnedName;
      };
      return WorkOfferMessage;
  }(BaseMessage));

  /*
          "WorkOfferStatus": {
              "clientList": [{
                  "name": "Dave Stowell",
                  "type": "END_USER",
                  "id": 232204885174861824,
                  "idString": "232204885174861824",
                  "connectionState": "ACTIVE",
                  "role": "END_USER",
                  "accountId": 0,
                  "accountIdString": "0"
              }, {
                  "name": "LoadUser1",
                  "type": "AGENT",
                  "id": 653566259200,
                  "idString": "653566259200",
                  "connectionState": "ACTIVE",
                  "role": "LEAD",
                  "accountId": 228,
                  "accountIdString": "228"
              }],
              "engagementId": 885099364352,
              "engagementIdString": "885099364352",
              "action": "ACCEPT",
              "sessionId": "232204421908668416"
          }

  */
  var WorkOfferStatus = /** @class */ (function (_super) {
      __extends(WorkOfferStatus, _super);
      function WorkOfferStatus() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * Convert the legacy message format to the new 'OfferStatus' object
       * @param legacyMessage Legacy WorkOfferStatus message
       */
      WorkOfferStatus.convert = function (legacyMessage, sessionToken) {
          var e_1, _a;
          var translatedAction;
          var message = new OfferStatus();
          message.channelIdentifier = legacyMessage.engagementIdString;
          switch (legacyMessage.action) {
              case exports.OfferActionType.DECLINE:
              case exports.OfferStatusTypes.DECLINED: {
                  translatedAction = exports.OfferStatusTypes.DECLINED;
                  break;
              }
              default: {
                  translatedAction = exports.OfferStatusTypes.ACCEPTED;
              }
          }
          message.status = translatedAction;
          if (message.status === exports.OfferStatusTypes.ACCEPTED) {
              // ==========================
              // Construct the Participants
              // ==========================
              var participants = [];
              try {
                  for (var _b = __values(legacyMessage.clientList), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var client = _c.value;
                      var participant = ClientInfo.convert(client);
                      // Add to the participants list
                      participants.push(participant);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
              // =====================
              // Construct the Channel
              // =====================
              var channel = new Channel(sessionToken, legacyMessage.engagementIdString);
              channel.members = participants;
              message.channel = channel;
          }
          return message;
      };
      return WorkOfferStatus;
  }(BaseResponse));

  /* Copyright (c) 2022', Oracle. All rights reserved. */
  var PostMessageTypes;
  (function (PostMessageTypes) {
      PostMessageTypes["ACTIVITY_SIGNAL"] = "ACTIVITY_SIGNAL";
      PostMessageTypes["ACTIVITY_STATUS_UPDATE"] = "ACTIVITY_STATUS_UPDATE";
      PostMessageTypes["AGENT_AVAILABLE_MESSAGE"] = "AGENT_AVAILABLE_MESSAGE";
      // AGENT_CANCEL_CHAT_REQUEST_MESSAGE = 'AGENT_CANCEL_CHAT_REQUEST_MESSAGE',
      PostMessageTypes["AGENT_CHANNELS_UPDATED"] = "AGENT_CHANNELS_UPDATED";
      PostMessageTypes["AGENT_CHAT_ACCEPTED_MESSAGE"] = "AGENT_CHAT_ACCEPTED_MESSAGE";
      PostMessageTypes["AGENT_GROUP_STATS_UPDATE"] = "AGENT_GROUP_STATS_UPDATE";
      PostMessageTypes["AGENT_LOGIN_MESSAGE"] = "AGENT_LOGIN_MESSAGE";
      PostMessageTypes["AGENT_LOGOUT_MESSAGE"] = "AGENT_LOGOUT_MESSAGE";
      // AGENT_REQUEST_CHAT_MESSAGE = 'AGENT_REQUEST_CHAT_MESSAGE',
      PostMessageTypes["AGENT_STATS_UPDATE"] = "AGENT_STATS_UPDATE";
      PostMessageTypes["AGENT_UNAVAILABLE_MESSAGE"] = "AGENT_UNAVAILABLE_MESSAGE";
      PostMessageTypes["ASSIGNMENT_INVITATION_CANCELLED"] = "ASSIGNMENT_INVITATION_CANCELLED";
      PostMessageTypes["COBROWSE_INVITATION"] = "COBROWSE_INVITATION";
      // COBROWSE_PREMIUM_INVITATION = 'COBROWSE_PREMIUM_INVITATION
      PostMessageTypes["COBROWSE_STATUS_NOTIFICATION"] = "COBROWSE_STATUS_NOTIFICATION";
      PostMessageTypes["CONFERENCE_INVITATION"] = "CONFERENCE_INVITATION";
      PostMessageTypes["DISCONNECT_NOTIFICATION"] = "DISCONNECT_NOTIFICATION";
      PostMessageTypes["ENGAGEMENT_ADD_CLIENT"] = "ENGAGEMENT_ADD_CLIENT";
      PostMessageTypes["ENGAGEMENT_ASSIGNMENT"] = "ENGAGEMENT_ASSIGNMENT";
      PostMessageTypes["ENGAGEMENT_TERMINATION"] = "ENGAGEMENT_TERMINATION";
      PostMessageTypes["ENGAGEMENT_UPDATE_NOTIFICATION"] = "ENGAGEMENT_UPDATE_NOTIFICATION";
      PostMessageTypes["FILE_ATTACH_UPLOAD"] = "FILE_ATTACH_UPLOAD";
      PostMessageTypes["FILE_ATTACH_UPLOAD_NOTIFICATION"] = "FILE_ATTACH_UPLOAD_NOTIFICATION";
      PostMessageTypes["OUT_OF_BAND_DATA"] = "OUT_OF_BAND_DATA";
      PostMessageTypes["QUEUE_POSITION_NOTIFICATION"] = "QUEUE_POSITION_NOTIFICATION";
      PostMessageTypes["QUEUE_STATS_UPDATE"] = "QUEUE_STATS_UPDATE";
      PostMessageTypes["ROLE_CHANGE_NOTIFICATION"] = "ROLE_CHANGE_NOTIFICATION";
      PostMessageTypes["SESSION_STATS_UPDATE"] = "SESSION_STATS_UPDATE";
      PostMessageTypes["STATS_ITEM_REMOVAL_NOTIFICATION"] = "STATS_ITEM_REMOVAL_NOTIFICATION";
      /**
       * A standard post message - should have been called POST!!
       */
      PostMessageTypes["TEXT"] = "TEXT";
      PostMessageTypes["TRANSFER_STATUS_NOTIFICATION"] = "TRANSFER_STATUS_NOTIFICATION";
      // URL = 'URL'
  })(PostMessageTypes || (PostMessageTypes = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  var MessageFailed = /** @class */ (function () {
      function MessageFailed() {
      }
      return MessageFailed;
  }());

  var SharedWorkerToClientCommunicator = /** @class */ (function () {
      function SharedWorkerToClientCommunicator() {
      }
      SharedWorkerToClientCommunicator.sendResponse = function (requestEnvelope, port, requestType, status) {
          var messageEnvelop = {
              request: requestEnvelope.request,
              requestTraceId: requestEnvelope.requestTraceId ? requestEnvelope.requestTraceId : new Date().getTime().toString(),
              requestType: requestType,
              response: requestEnvelope.response,
              responseFor: requestEnvelope.requestType,
              sourceChannelId: requestEnvelope.sourceChannelId,
              sourceWindow: 'chatSharedWorker',
              status: status ? status : Status.SUCCESS,
              targetChannelId: '*',
          };
          Logger.debug("### Sending response from Mercury for " + requestEnvelope.requestType + " with status " + messageEnvelop.status);
          port.postMessage(messageEnvelop);
      };
      SharedWorkerToClientCommunicator.sendEventResponse = function (response) {
          var e_1, _a;
          var messageEnvelop = {
              request: null,
              requestTraceId: new Date().getTime().toString(),
              requestType: RequestTypes.EventNotification,
              response: response,
              responseFor: RequestTypes.publishEvent,
              sourceChannelId: 'chatSharedWorker',
              sourceWindow: 'SharedWorker',
              status: Status.SUCCESS,
              targetChannelId: '*',
          };
          Logger.debug("### firing event notification for  " + response.type + " with payload: " + JSON.stringify(messageEnvelop));
          if (ClientStore.isClientExists()) {
              try {
                  for (var _b = __values(ClientStore.getClients()), _c = _b.next(); !_c.done; _c = _b.next()) {
                      var client = _c.value;
                      SharedWorkerToClientCommunicator.sendResponse(messageEnvelop, client.messagePort, RequestTypes.EventNotification, Status.SUCCESS);
                  }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                  try {
                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
              }
          }
      };
      return SharedWorkerToClientCommunicator;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  var modifyPropertiesCache = new Map();
  /**
   * This is a specific (Legacy chat protocol) implementation of a
   * Connection handler
   */
  var LegacyHttpConnection = /** @class */ (function () {
      function LegacyHttpConnection(configuration) {
          var _this = this;
          this.contactInfoStore = new Map();
          this.activeEngagements = [];
          this.fetchAttempts = 0;
          this.activelyPolling = false;
          this._delayGetMessages = false;
          this._nonMercuryOSVC = false;
          this._id = new Date().getTime();
          this._sessionListenerMap = new Map();
          this.channelIdentifier = null;
          this._currentSequenceNumberMap = new Map();
          this._isInitialGetMessages = true;
          this._lastPostMessageSequenceNumberMap = new Map();
          /**
           * Indicates if the channel is in the 'concluded' state
           */
          this._concludedMap = new Map();
          /**
           * The current xhr fetching messages
           */
          // private _currentHttpRequest: XMLHttpRequest;
          this.retryCommands = new Map([
              ['assignmentAcknowledgement', { count: 3, maxTimeout: 30000 }],
              ['cancelAssignmentInvitation', { count: 3, maxTimeout: 30000 }],
              ['cancelAssignmentRequest', { count: 3, maxTimeout: 30000 }],
              ['concludeChat', { count: 3, maxTimeout: 30000 }],
              ['leadReassignment', { count: 3, maxTimeout: 30000 }],
              ['leaveChat', { count: 3, maxTimeout: 30000 }],
              ['logoff', { count: 3, maxTimeout: 30000, keepalive: true }],
              ['postMessage', { count: 10, maxTimeout: 30000, retryDelay: 200 }],
              ['releaseChat', { count: 3, maxTimeout: 30000 }],
              ['requestAssignment', { count: 3, maxTimeout: 30000 }],
              ['setActivityStatus', { count: 3, maxTimeout: 30000, keepalive: true }],
              ['setAvailability', { count: 3, maxTimeout: 30000 }],
              ['setCustomAvailability', { count: 3, maxTimeout: 30000 }],
              ['setEngagementProperty', { count: 3, maxTimeout: 30000 }],
              ['transferChat', { count: 3, maxTimeout: 30000 }],
              ['modifyProperties', { count: 3, maxTimeout: 30000 }],
          ]);
          this.retryQueue = new Map();
          this.contextEngItemsReducer = function (engagementId) {
              return function (object, contextItem) {
                  /**
                   * If it is already set do not call add to payload
                   */
                  if (_this.isAlreadySet(contextItem, 'ENG', engagementId)) {
                      return object;
                  }
                  if (_this.isCtxEngProperty(contextItem.name)) {
                      object.propertiesMap[_this.isCtxEngProperty(contextItem.name)] = contextItem.value;
                  }
                  Logger.log("Trying to reduce Eng props " + Object.keys(object.propertiesMap).length);
                  return object;
              };
          };
          this.contextUserItemsReducer = function (engagementId) {
              return function (object, contextItem) {
                  /**
                   * If it is already set do not call add to payload
                   */
                  if (_this.isAlreadySet(contextItem, 'USER', engagementId)) {
                      return object;
                  }
                  if (_this.isCtxUserProperty(contextItem.name)) {
                      object.propertiesMap[_this.isCtxUserProperty(contextItem.name)] = contextItem.value;
                  }
                  else {
                      object.customFields.push({
                          name: contextItem.name,
                          type: 'string',
                          value: contextItem.value,
                      });
                  }
                  Logger.log("Trying to reduce Eng props " + Object.keys(object.propertiesMap).length + ", & custom fields " + object.customFields.length);
                  return object;
              };
          };
          this._clientConfiguration = configuration;
          try {
              configuration.endPoint = configuration.endPoint.replace(/\/v\d\/$/, '');
          }
          catch (e) {
              Logger.log('Invalid URL');
          }
          ChatConfig.setPool(configuration.pool);
          this._preferences = this._clientConfiguration.preferences || new Map();
          this._userPreferences = this._clientConfiguration.userPreferences;
          this._mercuryServiceEndpoint = this._clientConfiguration.endPoint;
          this._connectionConfig = ChatConfig.configMap.connection.http;
          this._connectionEndPoints = this._connectionConfig.endpoints;
          this._localeString = this._connectionConfig.locale;
          // 	If connection is lost, retry every X seconds (Default: 5)
          if (!this._preferences.get('EC_CHAT_CLIENT_RECONNECT_DELAY')) {
              this._preferences.set('EC_CHAT_CLIENT_RECONNECT_DELAY', this._connectionConfig.reconnectAttemptTimer);
          }
          // If connection is lost, retry X times (default 2)
          if (!this._preferences.get('EC_CHAT_CLIENT_RECONNECT_ATTEMPTS')) {
              this._preferences.set('EC_CHAT_CLIENT_RECONNECT_ATTEMPTS', this._connectionConfig.reconnectAttempts);
          }
          // If connection is lost, retry for X seconds (Default: 240)
          if (!this._preferences.get('EC_CHAT_CLIENT_RECONNECT_PERIOD')) {
              this._preferences.set('EC_CHAT_CLIENT_RECONNECT_PERIOD', this._connectionConfig.reconnectTimer);
          }
          // The time in seconds between retries (Default: 0.5) - for POST commands not getMessages
          if (!this._preferences.get('EC_CHAT_CLIENT_GET_DELAY')) {
              this._preferences.set('EC_CHAT_CLIENT_GET_DELAY', this._connectionConfig.timeBetweenGetAttempts);
          }
          // ========================
          // getmessages retry limits
          // ========================
          this._timeBetweenNormalGetsMilli = this._preferences.get('EC_CHAT_CLIENT_GET_DELAY') * 1000;
          this._timeBetweenAttemptsReconnectMilli = this._preferences.get('EC_CHAT_CLIENT_RECONNECT_DELAY') * 1000;
          this._maxFetchAttempts = Math.ceil(this._preferences.get('EC_CHAT_CLIENT_RECONNECT_PERIOD') / this._preferences.get('EC_CHAT_CLIENT_RECONNECT_DELAY'));
          this._warnFetchAttempts = Math.ceil(this._preferences.get('EC_CHAT_CLIENT_RECONNECT_PERIOD') / this._preferences.get('EC_CHAT_CLIENT_RECONNECT_DELAY') / 4);
          if (!this._localeString) {
              if (this._userPreferences && this._userPreferences.locale && this._userPreferences.territory) {
                  this._localeString = this._userPreferences.locale + '-' + this._userPreferences.territory;
              }
              else if (navigator && navigator.language) {
                  this._localeString = navigator.language;
              }
          }
      }
      LegacyHttpConnection.getInstance = function (configuration) {
          if (!LegacyHttpConnection.instance) {
              LegacyHttpConnection.instance = new LegacyHttpConnection(configuration);
          }
          return LegacyHttpConnection.instance;
      };
      LegacyHttpConnection.removeInstance = function () {
          LegacyHttpConnection.instance = undefined;
      };
      /*
        NOTE: This call can return with
        {
          'exceptionCode' : 'BAD_REQUEST',
          'message' : 'Engagement is no longer available. This may be due to the visitor choosing to leave the queue.',
          'method' : 'acknowledgeAssignment',
          'siteName' : 'mercurypsr-day117-20200',
          'o:errorPath' : '/engagement/api/agent/mercurypsr-day117-20200/v1/acknowledgeAssignment'
        }
      */
      LegacyHttpConnection.prototype.acceptChannel = function (sessionToken, channelIdentifier, assignmentType) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              var _this = this;
              return __generator(this, function (_a) {
                  // Increment the message sequence
                  LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                  requestMessage = {
                      action: 'ACCEPT',
                      actionType: 'MANUAL',
                      assignmentType: assignmentType,
                      engagementId: channelIdentifier,
                      sequenceNumber: LegacyHttpConnection._messageSequence,
                  };
                  Logger.log("assignmentAcknowledgement", requestMessage);
                  return [2 /*return*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.assignmentAcknowledgement, 'assignmentAcknowledgement', requestMessage, false).then(function (response) {
                          if (response.exceptionCode) {
                              // There is an application error
                              Logger.warn("Application Error " + response.exceptionCode + " [" + response.method + ": " + channelIdentifier + "] " + response.message);
                              return Promise.reject(response.message);
                          }
                          _this.addEngagement(channelIdentifier, sessionToken);
                          // ====================================
                          // Call Success
                          // Now construct the new Channel object
                          // ====================================
                          var channel = ChatAssignmentAcknowledgementResponse.convert(response, sessionToken);
                          return channel;
                      }).catch(function (message) {
                          return Promise.reject(message);
                      })];
              });
          });
      };
      /**
       * Call monitor agent endpoint and return interaction object.
       * @param sessionToken Session Token
       * @param interactionID engagementId string
       */
      LegacyHttpConnection.prototype.monitor = function (sessionToken, interactionID) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              return __generator(this, function (_a) {
                  LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                  requestMessage = {
                      engagementId: interactionID,
                      sequenceNumber: LegacyHttpConnection._messageSequence,
                  };
                  return [2 /*return*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.monitor, 'monitor', requestMessage, false).then(function (response) {
                          if (response.exceptionCode) {
                              // There is an application error
                              Logger.warn("Application Error " + response.exceptionCode + " [" + response.method + ": " + interactionID + "] " + response.message);
                              return Promise.reject(response.message);
                          }
                          // ============
                          // Call Success
                          // ============
                          // Convert the legacy response to a channel (if we accepted)
                          var channel = MonitorResponse.convert(response, sessionToken);
                          return channel;
                      }).catch(function (message) {
                          return Promise.reject(message);
                      })];
              });
          });
      };
      /**
       * Call v1/coach endpoint to switch Supervisor into coach role.
       */
      LegacyHttpConnection.prototype.joinToAssist = function (sessionToken, interactionID) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              return __generator(this, function (_a) {
                  LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                  requestMessage = {
                      engagementId: interactionID,
                      sequenceNumber: LegacyHttpConnection._messageSequence,
                  };
                  return [2 /*return*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.coach, 'coach', requestMessage, false).then(function (response) {
                          if (response.exceptionCode) {
                              // There is an application error
                              Logger.warn("Application Error " + response.exceptionCode + " [" + response.method + ": " + interactionID + "] " + response.message);
                              return Promise.reject(response.message);
                          }
                          // ============
                          // Call Success
                          // ============
                          // Convert the legacy response to a ChatEngagementUpdateNotification
                          return MonitorCoachEngagementResponse.convert(response);
                      }).catch(function (message) {
                          return Promise.reject(message);
                      })];
              });
          });
      };
      /**
       * Call v1/joinChat endpoint to switch Supervisor into coach role.
       */
      LegacyHttpConnection.prototype.joinWork = function (sessionToken, interactionID) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              return __generator(this, function (_a) {
                  LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                  requestMessage = {
                      engagementId: interactionID,
                      sequenceNumber: LegacyHttpConnection._messageSequence,
                  };
                  return [2 /*return*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.joinChat, 'coach', requestMessage, false).then(function (response) {
                          if (response.exceptionCode) {
                              // There is an application error
                              Logger.warn("Application Error " + response.exceptionCode + " [" + response.method + ": " + interactionID + "] " + response.message);
                              return Promise.reject(response.message);
                          }
                          // ============
                          // Call Success
                          // ============
                          // Convert the legacy response to a ChatEngagementUpdateNotification
                          return JoinEngagementResponse.convert(response);
                      }).catch(function (message) {
                          return Promise.reject(message);
                      })];
              });
          });
      };
      LegacyHttpConnection.prototype.leaveChannel = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, message_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              engagementId: channelIdentifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          Logger.log("leaveChat", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.leaveChat, 'leaveChat', requestMessage, false)];
                      case 2:
                          _a.sent();
                          this.removeEngagement(channelIdentifier, sessionToken);
                          return [3 /*break*/, 4];
                      case 3:
                          message_1 = _a.sent();
                          Logger.error("Message could not be sent due to '" + message_1 + "'");
                          return [3 /*break*/, 4];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.concludeChannel = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              engagementId: channelIdentifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          // Mark the Channel as concluded
                          this._concludedMap.set(channelIdentifier, true);
                          Logger.log("concludeChat", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.concludeChat, 'concludeChat', requestMessage, false).then(function () {
                                  _this.removeEngagement(channelIdentifier, sessionToken);
                              }).catch(function (message) {
                                  Logger.error("Message could not be sent due to '" + message + "'");
                                  _this._concludedMap.set(channelIdentifier, false);
                              })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.closeChannel = function (sessionToken, channelIdentifier, participationRole) {
          return __awaiter(this, void 0, void 0, function () {
              var _a, error_1;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          _a = participationRole;
                          switch (_a) {
                              case exports.ParticipationRoleType.CONFEREE: return [3 /*break*/, 1];
                              case exports.ParticipationRoleType.MONITOR: return [3 /*break*/, 1];
                              case exports.ParticipationRoleType.LEAD: return [3 /*break*/, 5];
                          }
                          return [3 /*break*/, 7];
                      case 1:
                          _b.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.leaveChannel(sessionToken, channelIdentifier)];
                      case 2:
                          _b.sent();
                          Logger.debug("Left channel [" + channelIdentifier + "] successfully");
                          return [3 /*break*/, 4];
                      case 3:
                          error_1 = _b.sent();
                          Logger.warn("Failed to leave channel [" + channelIdentifier + "] with response:[" + error_1 + "]");
                          throw error_1;
                      case 4: return [3 /*break*/, 9];
                      case 5: return [4 /*yield*/, this.closeChannelAsLead(sessionToken, channelIdentifier)];
                      case 6:
                          _b.sent();
                          return [3 /*break*/, 9];
                      case 7:
                          Logger.error("Unknown participation role passed to closeChannel [" + participationRole + "]");
                          // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                          // FOR NOW (UNTIL CLIENTID FIX IS IN PLACE) WE WILL TREAT ALL UNREGONIZED PARTICIPANTS AS 'LEADS'
                          // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                          return [4 /*yield*/, this.closeChannelAsLead(sessionToken, channelIdentifier)];
                      case 8:
                          // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                          // FOR NOW (UNTIL CLIENTID FIX IS IN PLACE) WE WILL TREAT ALL UNREGONIZED PARTICIPANTS AS 'LEADS'
                          // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                          _b.sent();
                          _b.label = 9;
                      case 9: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.listTransferDestinations = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response, destinations, e_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              id: 0,
                              includeAgentInformation: true,
                              includeQueueInformation: true,
                              includeQueueStatistics: true,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              type: 'GROUP',
                              visibility: 'NONE',
                          };
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.retrieveAgentsAndQueues, 'retrieveAgentsAndQueues', requestMessage, false)];
                      case 2:
                          response = _a.sent();
                          destinations = RetrieveAgentsAndQueuesResponse.convert(response, this._localeString);
                          return [2 /*return*/, destinations];
                      case 3:
                          e_1 = _a.sent();
                          return [2 /*return*/, []];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Assign a new role to a participant
       * <br> NOTE: we only support reassignment of LEAD at this point
       * @param sessionToken
       * @param channelIdentifier
       * @param role
       * @param participant
       */
      LegacyHttpConnection.prototype.assignRole = function (sessionToken, channelIdentifier, role, participant) {
          var _a;
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response;
              return __generator(this, function (_b) {
                  switch (_b.label) {
                      case 0:
                          if (role !== exports.ParticipationRoleType.LEAD) {
                              throw new RangeError('Only reassignment of LEAD is supported at the moment');
                          }
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              engagementId: channelIdentifier,
                              newLeadClientId: participant.identifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          Logger.log("leadReassignment", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.leadReassignment, 'leadReassignment', requestMessage, false)];
                      case 1:
                          response = (_b.sent());
                          if (((_a = response.chatLeadReassignmentResult) === null || _a === void 0 ? void 0 : _a.resultCode) !== 'SUCCESS') {
                              // an error occurred
                              throw new Error(response.message);
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.transferChannel = function (sessionToken, channelIdentifier, destination) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          if (destination.destinationType === exports.ChannelDestinationType.RESOURCE) {
                              requestMessage = {
                                  clientId: destination.identifier,
                                  engagementId: channelIdentifier,
                                  sequenceNumber: LegacyHttpConnection._messageSequence,
                              };
                          }
                          else {
                              // a Queue
                              requestMessage = {
                                  engagementId: channelIdentifier,
                                  queueId: destination.identifier,
                                  sequenceNumber: LegacyHttpConnection._messageSequence,
                              };
                          }
                          Logger.log("transferChat", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.transferChat, 'transferChat', requestMessage, false)];
                      case 1:
                          response = (_a.sent());
                          if (requestMessage.queueId) {
                              this.removeEngagement(channelIdentifier, sessionToken);
                          }
                          return [2 /*return*/, ChatTransferEngagementResponse.convert(response)];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.cancelInvitation = function (sessionToken, channelIdentifier, type, recipientId) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              clientId: recipientId,
                              engagementId: channelIdentifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              type: type,
                          };
                          Logger.log("cancelAssignmentInvitation", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.cancelAssignmentInvitation, 'cancelAssignmentInvitation', requestMessage, false)];
                      case 1:
                          response = (_a.sent());
                          if (!CancelAssignmentInvitationResponse.convert(response)) {
                              throw new Error('cancelInvitation posted v1/cancelAssignmentInvitation, but call was unsuccessful');
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.conference = function (sessionToken, channelIdentifier, invitee) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          if (invitee.destinationType === exports.ChannelDestinationType.RESOURCE) {
                              requestMessage = {
                                  clientId: invitee.identifier,
                                  engagementId: channelIdentifier,
                                  sequenceNumber: LegacyHttpConnection._messageSequence,
                              };
                          }
                          else {
                              // a Queue
                              requestMessage = {
                                  engagementId: channelIdentifier,
                                  queueId: invitee.identifier,
                                  sequenceNumber: LegacyHttpConnection._messageSequence,
                              };
                          }
                          Logger.log("conferenceChat", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.conferenceChat, 'conferenceChat', requestMessage, false)];
                      case 1:
                          response = (_a.sent());
                          return [2 /*return*/, ConferenceResponse.convert(response)];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.setAvailability = function (sessionToken, availability) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response, realMap, _a, _b, _c, key, value, responseObj;
              var e_2, _d;
              return __generator(this, function (_e) {
                  switch (_e.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              availabilityMap: availability,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          Logger.log("setAvailability", requestMessage);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.setAvailability, 'setAvailability', requestMessage, false)];
                      case 1:
                          response = (_e.sent());
                          realMap = new Map();
                          try {
                              for (_a = __values(Object.entries(response.availabilityMap)), _b = _a.next(); !_b.done; _b = _a.next()) {
                                  _c = __read(_b.value, 2), key = _c[0], value = _c[1];
                                  realMap.set(key, value);
                              }
                          }
                          catch (e_2_1) { e_2 = { error: e_2_1 }; }
                          finally {
                              try {
                                  if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                              }
                              finally { if (e_2) throw e_2.error; }
                          }
                          responseObj = new SetAvailabilityResponse(realMap);
                          return [2 /*return*/, responseObj];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.setActivityStatus = function (sessionToken, status) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, activityStatusChangeResult, message_2;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              status: status === LegacyHttpConnection.AVAILABLE_STATUS_CODE ? 'AVAILABLE' : 'UNAVAILABLE',
                              subTypeId: status,
                          };
                          Logger.log("setActivityStatus", requestMessage);
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 5, , 6]);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.setActivityStatus, 'setActivityStatus', requestMessage, null)];
                      case 2:
                          activityStatusChangeResult = _a.sent();
                          this.publishEvent(exports.MercuryEventType.ACTIVITY_STATUS_CHANGE, activityStatusChangeResult);
                          if (!(status === LegacyHttpConnection.AVAILABLE_STATUS_CODE)) return [3 /*break*/, 4];
                          return [4 /*yield*/, this.requestAssignment(sessionToken, null, false)];
                      case 3:
                          _a.sent();
                          _a.label = 4;
                      case 4: return [2 /*return*/, activityStatusChangeResult];
                      case 5:
                          message_2 = _a.sent();
                          throw new Error(message_2);
                      case 6: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.requestAssignment = function (sessionToken, channelIdentifier, assignRequest) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, res, message_3;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              assignmentRequested: assignRequest,
                              idleSessionCount: (this.getMaxActiveChats() - this.getActiveChats()),
                              maxActiveSessions: this.getMaxActiveChats(),
                              maxSessionCount: this.getMaxChats(),
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          Logger.log('Request body for assignment =>', requestMessage);
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.requestAssignment, 'requestAssignment', requestMessage, null)];
                      case 2:
                          res = _a.sent();
                          return [3 /*break*/, 4];
                      case 3:
                          message_3 = _a.sent();
                          throw new Error(message_3);
                      case 4: return [2 /*return*/, res];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.setCustomAvailability = function (sessionToken, customAvailabilityStateId) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response, responseObj;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              stateId: customAvailabilityStateId,
                          };
                          Logger.debug("JSON: [{$json}]");
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.setCustomAvailability, 'setCustomAvailability', requestMessage, false)];
                      case 1:
                          response = (_a.sent());
                          responseObj = new SetCustomAvailabilityResponse(response.customAvailabilityStateId);
                          return [2 /*return*/, responseObj];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.setInteractionState = function (sessionToken, channelIdentifier, activityMode) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage;
              return __generator(this, function (_a) {
                  // Increment the message sequence
                  LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                  requestMessage = {
                      clientId: this.sessionDetails.clientIdentifier,
                      engagementId: channelIdentifier,
                      mode: activityMode === exports.ActivityType.AGENTS_ONLY_RESPONDING ? exports.ActivityType.RESPONDING : activityMode,
                      sequenceNumber: LegacyHttpConnection._messageSequence,
                      sneakPreviewFocus: true,
                      visibility: activityMode === exports.ActivityType.AGENTS_ONLY_RESPONDING ? 'NOT_ENDUSER' : 'ALL',
                  };
                  return [2 /*return*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.setInteractionStatus, 'setInteractionStatus', requestMessage, false).then(function () {
                          // Call Success
                          return 'SUCCESS';
                      }).catch(function () {
                          return 'FAILURE';
                      })];
              });
          });
      };
      LegacyHttpConnection.prototype.respondToOffer = function (sessionToken, offer, action, responseType) {
          return __awaiter(this, void 0, void 0, function () {
              var assignmentType, requestMessage, response, channel, message_4;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          assignmentType = offer.assignmentType;
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              action: action,
                              actionType: responseType,
                              assignmentType: assignmentType,
                              engagementId: offer.identifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          Logger.log("assignmentAcknowledgement", requestMessage);
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.assignmentAcknowledgement, 'assignmentAcknowledgement', requestMessage, false)];
                      case 2:
                          response = _a.sent();
                          if (response.exceptionCode) {
                              // There is an application error
                              Logger.warn("Application Error " + response.exceptionCode + " [" + response.method + ": " + offer.identifier + "] " + response.message);
                              throw new Error(response.message);
                          }
                          channel = AssignmentAcknowledgementResponse.convert(response, sessionToken);
                          if (action === exports.OfferActionType.ACCEPT) {
                              this.addEngagement(channel.identifier, sessionToken);
                              this.publishEvent(exports.MercuryEventType.NEW_CHANNEL, { channel: channel, offer: offer });
                          }
                          return [2 /*return*/, channel];
                      case 3:
                          message_4 = _a.sent();
                          throw new Error(message_4);
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.sendMessage = function (sessionToken, channelIdentifier, message) {
          return __awaiter(this, void 0, void 0, function () {
              var formattedPayload;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          formattedPayload = {
                              body: message.body,
                              destinationId: channelIdentifier,
                              destinationType: 'ENGAGEMENT',
                              messageDataMap: message.messageDataMap,
                              messageType: PostMessageTypes.TEXT,
                              offTheRecord: !message.preserve,
                              richText: true,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              stdTextId: 0,
                              timeCreated: message.created.getTime,
                              unique: message.unique,
                              visibility: message.visibility.length === 0 ? 'ALL' : 'NOT_ENDUSER',
                          };
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.postMessage, 'postMessage', formattedPayload, true)
                                  .catch(function (errorMessage) {
                                  Logger.error("Message could not be sent due to '" + errorMessage + "'");
                              })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.sendAttachment = function (sessionToken, channelIdentifier, fileAttachmentDetail) {
          return __awaiter(this, void 0, void 0, function () {
              var fileAttachmentList, formattedPayload;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          fileAttachmentList = fileAttachmentDetail.map(function (file) {
                              var fileDetails = new FileDetails();
                              Object.assign(fileDetails, { contentType: file.contentType, fileSize: file.fileSize, localFileName: file.localFileName, statusCode: 'RECEIVED',
                                  userFileName: file.userFileName });
                              return fileDetails;
                          });
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          formattedPayload = {
                              engagementId: channelIdentifier,
                              fileAttachmentList: fileAttachmentList,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              timeCreated: 0,
                              visibility: 'ALL',
                          };
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.sendAttachment, 'postMessage', formattedPayload, true)
                                  .catch(function (errorMessage) {
                                  var attachErrorPayload = {
                                      channelIdentifier: channelIdentifier,
                                      fileAttachmentDetail: fileAttachmentDetail,
                                  };
                                  _this.publishEvent(exports.MercuryEventType.ATTACHMENT_MESSAGE_FAILED, attachErrorPayload);
                                  Logger.error("Attachment Message could not be sent due to '" + errorMessage + "'");
                              })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.setContext = function (sessionToken, channelIdentifier, contextItem) {
          return __awaiter(this, void 0, void 0, function () {
              var url, formattedPayload;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          url = "" + this._mercuryServiceEndpoint + this._connectionEndPoints.setEngagementProperty;
                          formattedPayload = {
                              engagementId: channelIdentifier,
                              name: contextItem.name,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                              type: contextItem.type,
                              value: contextItem.value,
                          };
                          Logger.log(this._nonMercuryOSVC ? 'modifyProperties' : 'setEngagementProperty', formattedPayload);
                          return [4 /*yield*/, this.post(sessionToken, url, this._nonMercuryOSVC ? 'modifyProperties' : 'setEngagementProperty', formattedPayload, true).catch(function (message) {
                                  Logger.error("Message could not be sent due to '" + message + "'");
                              })];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.isCtxEngProperty = function (propertyName) {
          var propertyNameMap = {};
          propertyNameMap[exports.ChannelContextNameType.CONTACT_ID] = 'CONTACT_ID';
          propertyNameMap[exports.ChannelContextNameType.INCIDENT_ID] = 'INCIDENT_ID';
          return propertyNameMap[propertyName];
      };
      LegacyHttpConnection.prototype.isCtxUserProperty = function (propertyName) {
          var propertyNameMap = {};
          propertyNameMap[exports.ChannelContextNameType.FIRST_NAME] = 'FIRST_NAME';
          propertyNameMap[exports.ChannelContextNameType.LAST_NAME] = 'LAST_NAME';
          propertyNameMap[exports.ChannelContextNameType.EMAIL] = 'EMAIL';
          propertyNameMap[exports.ChannelContextNameType.QUESTION] = 'QUESTION';
          propertyNameMap[exports.ChannelContextNameType.PRODUCT_ID] = 'PRODUCT_ID';
          propertyNameMap[exports.ChannelContextNameType.CONTACT_ID] = 'CONTACT_ID';
          return propertyNameMap[propertyName];
      };
      LegacyHttpConnection.prototype.modifyProperties = function (sessionToken, channelIdentifier, contextItems) {
          return __awaiter(this, void 0, void 0, function () {
              var url, formattedEngPayload, formattedUserPayload;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          url = "" + this._mercuryServiceEndpoint + this._connectionEndPoints.modifyProperties;
                          formattedEngPayload = __assign(__assign({}, contextItems.reduce(this.contextEngItemsReducer(channelIdentifier), {
                              customFields: [],
                              propertiesMap: {},
                          })), { engagementId: channelIdentifier, type: 'ENGAGEMENT' });
                          if (!(Object.keys(formattedEngPayload.propertiesMap).length > 0)) return [3 /*break*/, 2];
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          formattedEngPayload.sequenceNumber = LegacyHttpConnection._messageSequence;
                          return [4 /*yield*/, this.post(sessionToken, url, 'modifyProperties', formattedEngPayload, true)];
                      case 1:
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          formattedUserPayload = __assign(__assign({}, contextItems.reduce(this.contextUserItemsReducer(channelIdentifier), {
                              customFields: [],
                              propertiesMap: {},
                          })), { engagementId: channelIdentifier, type: 'USER' });
                          if (!(Object.keys(formattedUserPayload.propertiesMap).length > 0 ||
                              formattedUserPayload.customFields.length > 0)) return [3 /*break*/, 4];
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          formattedUserPayload.sequenceNumber = LegacyHttpConnection._messageSequence;
                          Logger.log("modifyProperties", formattedUserPayload);
                          return [4 /*yield*/, this.post(sessionToken, url, 'modifyProperties', formattedUserPayload, true)
                                  .catch(function (message) {
                                  Logger.error("Message could not be sent due to '" + message + "'");
                              })];
                      case 3:
                          _a.sent();
                          _a.label = 4;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.refreshMessages = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  this._isInitialGetMessages = true;
                  if (this._delayGetMessages) {
                      this._delayGetMessages = false;
                      this.startListening(sessionToken, channelIdentifier);
                  }
                  else {
                      this.messagePoller(sessionToken, channelIdentifier);
                  }
                  return [2 /*return*/];
              });
          });
      };
      LegacyHttpConnection.prototype.post = function (sessionToken, url, messageType, payload, maintainOrder) {
          var _this = this;
          // Map the new interface to the 'old' postData interface
          var requestData = {
              chatCommand: messageType,
              evtData: payload,
              headers: this.getHeaders(sessionToken),
              url: url,
          };
          // tslint:disable-next-line: typedef
          return new Promise(function (resolve, reject) {
              // tslint:disable-next-line: typedef
              _this.postData(requestData, function (xhrStatus, xhrResponseText) {
                  // This is the callback function
                  if (xhrStatus === 200) {
                      var response = JSON.parse(xhrResponseText);
                      if (response.chatSystemError) {
                          var errorObj = response.chatSystemError;
                          // =============================
                          // There is an application error
                          // =============================
                          Logger.log("System Error " + errorObj.errorCondition + " " + errorObj.text + " " + errorObj.type);
                          reject(errorObj.text);
                      }
                      else {
                          // ==============
                          // Clean response
                          // ==============
                          resolve(JSON.parse(xhrResponseText));
                      }
                  }
                  else {
                      // ===========================
                      // There is a connection error
                      // ===========================
                      reject("URL: " + url + " returned status " + xhrStatus + " and response " + xhrResponseText);
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.get = function (sessionToken, url, payload) {
          throw new Error('Method not implemented.');
      };
      LegacyHttpConnection.prototype.on = function (event, listener, priority) {
          if (priority === void 0) { priority = false; }
          EventCallbackStore.registerListeners(event, listener, priority);
      };
      /**
       * Allow the caller to unsubscribe from a specific event
       * @param event MercuryEvent
       * @param callback
       */
      LegacyHttpConnection.prototype.unsubscribe = function (event, callback) {
          EventCallbackStore.removeListeners(event, callback);
      };
      LegacyHttpConnection.prototype.startListening = function (sessionToken, channelIdentifier) {
          if (this._delayGetMessages) {
              return;
          }
          if (this.fetchAttempts >= this._maxFetchAttempts) {
              this.fetchAttempts = 0;
          }
          this._sessionListenerMap.set(sessionToken, true);
          this.messagePoller(sessionToken, channelIdentifier);
      };
      LegacyHttpConnection.prototype.stopListening = function () {
          var _a;
          if ((_a = this.sessionDetails) === null || _a === void 0 ? void 0 : _a.sessionIdentifier) {
              this._sessionListenerMap.delete(this.sessionDetails.sessionIdentifier);
          }
          if (this._currentHttpRequest) {
              this._currentHttpRequest.abort();
          }
          this.activelyPolling = false;
      };
      LegacyHttpConnection.prototype.makeOSVCLogin = function (identityToken, delayGetMessages) {
          var _this = this;
          this._authenticationToken = identityToken;
          this._delayGetMessages = delayGetMessages;
          // ** stop message poller
          this.activelyPolling = false;
          this._sessionListenerMap.clear();
          // Aborting current req
          if (this._currentHttpRequest && this._currentHttpRequest.readyState !== 4) {
              this._currentHttpRequest.abort();
          }
          return new Promise(function (resolve, reject) {
              var authSite = "" + _this._mercuryServiceEndpoint + _this._connectionEndPoints.logonOSVC;
              var req = new Request(authSite, {
                  body: JSON.stringify({
                      sequenceNumber: ++LegacyHttpConnection._messageSequence,
                  }),
                  headers: __assign({ 'Content-Type': 'application/json;charset=utf-8' }, _this.getHeaders(null)),
                  method: 'post',
              }).clone();
              return fetch(req)
                  .then(function (res) {
                  return res.json();
              }).catch(function (e) {
                  reject(e);
              })
                  .then(function (responseObj) {
                  if (responseObj) {
                      _this.sessionDetails = CreateAgentSessionResponse.convert(responseObj);
                      _this.populateEngagements(_this.sessionDetails.channels, _this.sessionDetails.sessionIdentifier);
                      _this.sessionDetails.channels.forEach(function (channel) {
                          channel.contactInfo = channel.contactInfo ? channel.contactInfo : _this.contactInfoStore.get(channel.identifier);
                      });
                      Logger.log('### Firing Session Changed', _this.sessionDetails);
                      _this.publishEvent(exports.MercuryEventType.SESSION_CHANGED, _this.sessionDetails);
                      resolve(_this.sessionDetails);
                  }
                  else {
                      Logger.log('Unable to connect to chat server');
                      reject('Unable to connect to chat server');
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.makeLoginRequest = function (identityToken, delayGetMessages) {
          var _this = this;
          // tslint:disable-next-line: typedef
          return new Promise(function (resolve, reject) {
              // ====================================================
              // Now we are authenticated we can now create a session
              // ====================================================
              _this._authenticationToken = identityToken;
              _this._delayGetMessages = delayGetMessages;
              var url = "" + _this._mercuryServiceEndpoint + _this._connectionEndPoints.createAgentSession;
              var xhr = _this.getRequestObject('POST', url);
              xhr.onerror = function (event) {
                  Logger.log("Failed to CreateAgentSession.  Connection error", event);
                  reject(event);
              };
              xhr.onload = function () {
                  var responseObj = {};
                  var errorResponse = {
                      errorCondition: 'ACCESS_ERROR',
                      status: xhr.status,
                      text: xhr.responseText ? xhr.responseText : '',
                  };
                  try {
                      if (xhr.responseText) {
                          responseObj = JSON.parse(xhr.responseText);
                      }
                      if (xhr.status === 200 && !responseObj.chatSystemError) {
                          // ===================================================
                          // Convert the Legacy response to a new Session Object
                          // ===================================================
                          _this.sessionDetails = CreateAgentSessionResponse.convert(responseObj);
                          // Return the new Session object
                          resolve(_this.sessionDetails);
                          return;
                      }
                  }
                  catch (err) {
                      errorResponse.text = err;
                      errorResponse.errorCondition = 'RESPONSE_FORMAT_ERROR';
                  }
                  if (responseObj.chatSystemError) {
                      // Just Reject with the Error Response From Mercury
                      errorResponse = responseObj.chatSystemError;
                      errorResponse.status = xhr.status;
                  }
                  reject(errorResponse);
              };
              var sendBuffer = _this._userPreferences ? JSON.stringify(_this._userPreferences) : '{}';
              xhr.send(sendBuffer);
          });
      };
      /*
       * Call v1/createSupervisorSession without setting an Authentication Header.
       * This method is called from createSupervisor.
       */
      LegacyHttpConnection.prototype.makeLoginRequestSupervisor = function (delayGetMessages) {
          var _this = this;
          // tslint:disable-next-line: typedef
          return new Promise(function (resolve, reject) {
              // ====================================================
              // Now we are authenticated we can now create a session
              // ====================================================
              _this._delayGetMessages = delayGetMessages;
              var url = "" + _this._mercuryServiceEndpoint + _this._connectionEndPoints.createSupervisorSession;
              var xhr = _this.getRequestObjectSupervisor('POST', url);
              xhr.onerror = function (event) {
                  Logger.log("Failed to CreateAgentSession.  Connection error", event);
                  reject(event);
              };
              xhr.onload = function () {
                  var responseObj = {};
                  var errorResponse = {
                      errorCondition: 'ACCESS_ERROR',
                      status: xhr.status,
                      text: xhr.responseText ? xhr.responseText : '',
                  };
                  try {
                      if (xhr.responseText) {
                          responseObj = JSON.parse(xhr.responseText);
                      }
                      if (xhr.status === 200 && !responseObj.chatSystemError) {
                          // ===================================================
                          // Convert the Legacy response to a new Session Object
                          // ===================================================
                          _this.sessionDetails = CreateAgentSessionResponse.convert(responseObj);
                          // Return the new Session object
                          resolve(_this.sessionDetails);
                          return;
                      }
                  }
                  catch (err) {
                      errorResponse.text = err;
                      errorResponse.errorCondition = 'RESPONSE_FORMAT_ERROR';
                  }
                  if (responseObj.chatSystemError) {
                      // Just Reject with the Error Response From Mercury
                      errorResponse = responseObj.chatSystemError;
                      errorResponse.status = xhr.status;
                  }
                  reject(errorResponse);
              };
              var sendBuffer = _this._userPreferences ? JSON.stringify(_this._userPreferences) : '{}';
              xhr.send(sendBuffer);
          });
      };
      LegacyHttpConnection.prototype.makeLoginRequestWorkObjects = function (identityToken, delayGetMessages) {
          var _this = this;
          // tslint:disable-next-line: typedef
          return new Promise(function (resolve, reject) {
              // ====================================================
              // Now we are authenticated we can now create a session
              // ====================================================
              _this._authenticationToken = identityToken;
              _this._delayGetMessages = delayGetMessages;
              var url = "" + _this._mercuryServiceEndpoint + _this._connectionEndPoints.createAgentSessionWorkObjects;
              var xhr = _this.getRequestObject('POST', url);
              xhr.onerror = function (event) {
                  Logger.log("Failed to CreateAgentSession.  Connection error", event);
                  reject(event);
              };
              xhr.onload = function () {
                  var responseObj = {};
                  var errorResponse = {
                      errorCondition: 'ACCESS_ERROR',
                      status: xhr.status,
                      text: xhr.responseText ? xhr.responseText : '',
                  };
                  try {
                      if (xhr.responseText) {
                          responseObj = JSON.parse(xhr.responseText);
                      }
                      if (xhr.status === 200 && !responseObj.chatSystemError) {
                          // ===================================================
                          // Convert the Legacy response to a new Session Object
                          // ===================================================
                          _this.sessionDetails = CreateAgentSessionResponse.convert(responseObj);
                          // Return the new Session object
                          resolve(_this.sessionDetails);
                          return;
                      }
                  }
                  catch (err) {
                      errorResponse.text = err;
                      errorResponse.errorCondition = 'RESPONSE_FORMAT_ERROR';
                  }
                  if (responseObj.chatSystemError) {
                      // Just Reject with the Error Response From Mercury
                      errorResponse = responseObj.chatSystemError;
                      errorResponse.status = xhr.status;
                  }
                  reject(errorResponse);
              };
              var sendBuffer = _this._userPreferences ? JSON.stringify(_this._userPreferences) : '{}';
              xhr.send(sendBuffer);
          });
      };
      LegacyHttpConnection.prototype.endSession = function (sessionToken, forced) {
          if (forced === void 0) { forced = false; }
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(ClientStore.isLastTab() || !ClientStore.isClientExists())) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.doEndSession(sessionToken, forced)];
                      case 1:
                          _a.sent();
                          return [3 /*break*/, 3];
                      case 2:
                          Logger.log('### Ignore Session LoggOff in master Tab');
                          _a.label = 3;
                      case 3: return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.postData = function (postData, callbackMethod, previousXHR) {
          if (postData.chatCommand === 'postMessage') {
              // let's queue these messages to maintain sequence on retry/failures
              this.addRequestToQueue('POST', postData, callbackMethod, previousXHR);
          }
          else {
              this.makeRequest('POST', postData, callbackMethod);
          }
      };
      LegacyHttpConnection.prototype.publishEvent = function (type, payload) {
          if (ClientStore.isClientExists()) {
              var response = {
                  payload: payload,
                  type: type,
              };
              SharedWorkerToClientCommunicator.sendEventResponse(response);
          }
          else {
              EventCallbackStore.invokeListeners(type, payload);
          }
      };
      LegacyHttpConnection.prototype.setSessionDetails = function (sessionDetails) {
          this.sessionDetails = sessionDetails;
      };
      /**
       * Internal: Release the chat
       * @param sessionToken
       * @param channelIdentifier
       */
      LegacyHttpConnection.prototype.releaseChat = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, message_5;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              engagementId: channelIdentifier,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.releaseChat, 'releaseChat', requestMessage, false)];
                      case 2:
                          _a.sent();
                          return [3 /*break*/, 4];
                      case 3:
                          message_5 = _a.sent();
                          Logger.error("Message could not be sent due to", message_5);
                          return [3 /*break*/, 4];
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Close the channel taking into account whether it has/has not been concluded
       * @param sessionToken
       * @param channelIdentifier
       */
      LegacyHttpConnection.prototype.closeChannelAsLead = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var concluded;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          concluded = this._concludedMap.get(channelIdentifier);
                          if (!!concluded) return [3 /*break*/, 2];
                          // ==========================================
                          // The channel has not been concluded - do it
                          // ==========================================
                          return [4 /*yield*/, this.concludeChannel(sessionToken, channelIdentifier)];
                      case 1:
                          // ==========================================
                          // The channel has not been concluded - do it
                          // ==========================================
                          _a.sent();
                          _a.label = 2;
                      case 2:
                          // ===========================================
                          // The channel has been concluded - release it
                          // ===========================================
                          setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                              return __generator(this, function (_a) {
                                  switch (_a.label) {
                                      case 0: return [4 /*yield*/, this.releaseChat(sessionToken, channelIdentifier)];
                                      case 1:
                                          _a.sent();
                                          return [2 /*return*/];
                                  }
                              });
                          }); }, 1000);
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.generateQueueKey = function (unique, messageType) {
          return unique + "_" + messageType;
      };
      LegacyHttpConnection.prototype.removeRequestFromQueue = function (reqData, unique) {
          var chatCommand = reqData.chatCommand;
          var retryKey = this.generateQueueKey(unique, chatCommand);
          this.retryQueue.delete(retryKey);
      };
      LegacyHttpConnection.prototype.addRequestToQueue = function (reqMethod, reqData, reqCallback, requestObj, unique) {
          var _this = this;
          if (unique === void 0) { unique = reqData.evtData.unique || Date.now().toString(); }
          var chatCommand = reqData.chatCommand;
          var commandInfo = this.retryCommands.get(chatCommand);
          var retryKey = this.generateQueueKey(unique, chatCommand);
          var queueEntry = this.retryQueue.get(retryKey);
          if (queueEntry) {
              // ===================================================
              // We have an entry for this message - up the attempts
              // ===================================================
              queueEntry.attempts += 1;
          }
          else {
              // ================================================
              // We don't have this message in the queue - add it
              // ================================================
              var requestData = {
                  reqCallback: reqCallback,
                  reqData: reqData,
                  reqMethod: reqMethod,
                  requestObj: requestObj,
                  unique: unique,
              };
              this.retryQueue.set(retryKey, {
                  attempts: chatCommand === 'postMessage' ? 0 : 1,
                  requestData: requestData,
                  status: 'None',
              });
          }
          // ==========================
          // Retry sending the messages
          // ==========================
          setTimeout(function () {
              _this.processQueueRequest();
          }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
      };
      LegacyHttpConnection.prototype.processQueueRequest = function () {
          var _this = this;
          var keys = __spread(this.retryQueue.keys());
          keys.sort();
          if (keys.length > 0) {
              var queueEntry = this.retryQueue.get(keys[0]);
              var requestData = queueEntry.requestData;
              var reqMethod = requestData.reqMethod;
              var reqData = requestData.reqData;
              var reqCallback = requestData.reqCallback;
              var requestObj = requestData.requestObj;
              var unique = requestData.unique;
              var chatCommand = reqData.chatCommand;
              var commandInfo = this.retryCommands.get(chatCommand);
              var maxAttempts = (commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.count) ? commandInfo.count : 1;
              var channelIdentifier = reqData.evtData.destinationId;
              if (queueEntry.attempts <= maxAttempts) {
                  // ===================================
                  // We should try to retry this message
                  // ===================================
                  var maxTimeout = (commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.maxTimeout) ? commandInfo.maxTimeout : 0;
                  if (!queueEntry.status || queueEntry.status !== 'Processing') {
                      this.makeRequest(reqMethod, reqData, reqCallback, requestObj, unique);
                  }
              }
              else {
                  // ==============================================================
                  // Retry attempts have failed - remove the message from the queue
                  // ==============================================================
                  Logger.log("Retry for " + chatCommand + " exceeded - discarding message");
                  this.removeRequestFromQueue(reqData, unique);
                  // failed too often, do the callback
                  reqCallback(418, 'Request failed due to network issues.');
                  var messageFailed = new MessageFailed();
                  messageFailed.unique = unique;
                  messageFailed.channelIdentifier = channelIdentifier;
                  this.publishEvent(exports.MercuryEventType.MESSAGE_FAILED, messageFailed);
                  if (this.retryQueue.size > 0) {
                      // We have more messages to send, continue processing them
                      setTimeout(function () {
                          _this.processQueueRequest();
                      }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
                  }
              }
          }
      };
      LegacyHttpConnection.prototype.retryWithTimeout = function (requestMethod, chatCommand, commandInfo, requestData, callbackMethod, xhr, unique) {
          var _this = this;
          Logger.log(requestMethod + "  (" + chatCommand + ") failed due to '" + (navigator.onLine ? 'Unknown Error' : 'No internet connection') + "'.");
          if (commandInfo) {
              // retry command only if it is part of retryable commands.
              setTimeout(function () {
                  _this.addRequestToQueue(requestMethod, requestData, callbackMethod, xhr, unique);
              }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
          }
      };
      LegacyHttpConnection.prototype.makeRequest = function (requestMethod, requestData, callbackMethod, previousXHR, unique) {
          if (unique === void 0) { unique = Date.now().toString(); }
          // if (fetch) {
          //   this.makeFetchRequest(requestMethod, requestData, callbackMethod, unique);
          // } else if (XMLHttpRequest) {
          this.makeXMLHttpRequest(requestMethod, requestData, callbackMethod, unique);
          // }
      };
      LegacyHttpConnection.prototype.makeXMLHttpRequest = function (requestMethod, requestData, callbackMethod, unique) {
          var _this = this;
          if (unique === void 0) { unique = Date.now().toString(); }
          var xhr = new XMLHttpRequest();
          var chatCommand = requestData.chatCommand;
          var commandInfo = this.retryCommands.get(chatCommand);
          var retryKey = this.generateQueueKey(unique, chatCommand);
          var queueEntry = this.retryQueue.get(retryKey);
          var maxTimeout = (commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.maxTimeout) ? commandInfo.maxTimeout : 0;
          if (maxTimeout === undefined) {
              maxTimeout = 0; // default browser behavior
          }
          if ('withCredentials' in xhr) {
              // new browsers
              var async = typeof requestData.async === 'undefined' || requestData.async;
              xhr.open(requestMethod, requestData.url, async);
              xhr.setRequestHeader('Content-Type', 'application/json');
              for (var attr in requestData.headers) {
                  if (requestData.headers.hasOwnProperty(attr)) {
                      xhr.setRequestHeader(attr, requestData.headers[attr]);
                  }
              }
              xhr.onreadystatechange = function () {
                  if ((xhr === null || xhr === void 0 ? void 0 : xhr.readyState) === 4) {
                      if (chatCommand === 'postMessage' && queueEntry) {
                          queueEntry.status = 'Done';
                      }
                      if (xhr.status === 0) {
                          _this.retryWithTimeout(requestMethod, chatCommand, commandInfo, requestData, callbackMethod, xhr, unique);
                      }
                      else {
                          _this.removeRequestFromQueue(requestData, unique);
                          if (_this.retryQueue.size > 0) {
                              setTimeout(function () {
                                  _this.processQueueRequest();
                              }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
                          }
                      }
                      callbackMethod(xhr.status, xhr.responseText);
                  }
              };
              xhr.onerror = function () {
                  var rKey = _this.generateQueueKey(unique, chatCommand);
                  if (chatCommand === 'postMessage' && queueEntry) {
                      queueEntry.status = 'Done';
                  }
                  callbackMethod(xhr.status, requestMethod + "  (" + chatCommand + ") failed due to '" + (navigator.onLine ? 'Unknown Error' : 'No internet connection') + "'.");
              };
              if (commandInfo && async) {
                  xhr.timeout = maxTimeout;
                  xhr.ontimeout = function () {
                      if (chatCommand === 'postMessage' && queueEntry) {
                          queueEntry.status = 'Done';
                      }
                      _this.addRequestToQueue(requestMethod, requestData, callbackMethod, xhr, unique);
                  };
              }
              if (chatCommand === 'postMessage' && queueEntry) {
                  if (!queueEntry.status || queueEntry.status !== 'Processing') {
                      queueEntry.status = 'Processing';
                      var requestBody = requestData.evtData;
                      if (requestBody.messageDataMap) {
                          requestBody.messageDataMap = this.constructMessageDataMapBody(requestBody.messageDataMap);
                      }
                      xhr.send(JSON.stringify(requestBody));
                  }
                  else {
                      setTimeout(function () {
                          _this.processQueueRequest();
                      }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
                  }
              }
              else {
                  var sndBuffer = JSON.stringify(requestData.evtData, this.mapReplacer);
                  xhr.send(sndBuffer);
              }
          }
          else {
              // This version of XHR does not support CORS
              // Handle accordingly
              Logger.log('Communication with chat-server not possible.');
          }
      };
      LegacyHttpConnection.prototype.getFetchHeaders = function (requestHeaders) {
          var e_3, _a;
          var headers = new Headers({
              'Content-Type': 'application/json; charset=utf-8',
          });
          try {
              for (var _b = __values(Object.keys(requestHeaders)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var headerName = _c.value;
                  headers.append(headerName, requestHeaders[headerName]);
              }
          }
          catch (e_3_1) { e_3 = { error: e_3_1 }; }
          finally {
              try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_3) throw e_3.error; }
          }
          return headers;
      };
      LegacyHttpConnection.prototype.makeFetchRequest = function (requestMethod, requestData, callbackMethod, unique) {
          var _this = this;
          if (unique === void 0) { unique = Date.now().toString(); }
          var that = this;
          var chatCommand = requestData.chatCommand;
          var commandInfo = this.retryCommands.get(chatCommand);
          var requestSignal = new AbortController().signal;
          var retryKey = this.generateQueueKey(unique, chatCommand);
          var queueEntry = this.retryQueue.get(retryKey);
          var requestParams = {
              body: JSON.stringify(requestData.evtData),
              credentials: 'include',
              headers: this.getFetchHeaders(requestData.headers),
              keepalive: ((commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.keepalive) === true),
              method: requestMethod,
              mode: 'cors',
              signal: requestSignal,
          };
          var discardQueuedRequest = function () {
              that.removeRequestFromQueue(requestData, unique);
              if (that.retryQueue.size > 0) {
                  setTimeout(function () {
                      that.processQueueRequest();
                  }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
              }
          };
          var fetchSuccessHandler = function (response) {
              if (chatCommand === 'postMessage' && queueEntry) {
                  queueEntry.status = 'Done';
              }
              response.text().then(function (body) {
                  if (response.ok) {
                      discardQueuedRequest();
                  }
                  else {
                      switch (response.status) {
                          case 400:
                          case 403:
                              discardQueuedRequest();
                              Logger.log("Discarding (unrecoverable) failed '" + chatCommand + "' request");
                              break;
                          default:
                              break;
                      }
                  }
                  callbackMethod(response.status, body);
              });
          };
          var fetchFailureHandler = function (error) {
              if (chatCommand === 'postMessage' && queueEntry) {
                  queueEntry.status = 'Done';
              }
              if (error.name !== 'AbortError') {
                  Logger.log(requestMethod + ' (' + chatCommand + ') failed with error: ' + error.message);
                  // retry command only if it is part of retryable commands.
                  if (commandInfo) {
                      setTimeout(function () {
                          that.addRequestToQueue(requestMethod, requestData, callbackMethod, undefined, unique);
                      }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
                  }
                  callbackMethod(0, error.message);
              }
          };
          if (navigator.onLine) {
              if (chatCommand === 'postMessage' && queueEntry) {
                  if (queueEntry.status === 'Processing') {
                      setTimeout(function () {
                          _this.processQueueRequest();
                      }, commandInfo === null || commandInfo === void 0 ? void 0 : commandInfo.retryDelay);
                  }
                  else {
                      queueEntry.status = 'Processing';
                      fetch(requestData.url, requestParams)
                          .then(function (response) { fetchSuccessHandler(response); })
                          .catch(function (error) { fetchFailureHandler(error); });
                  }
              }
              else {
                  fetch(requestData.url, requestParams)
                      .then(function (response) { fetchSuccessHandler(response); })
                      .catch(function (error) { fetchFailureHandler(error); });
              }
          }
          else {
              fetchFailureHandler(new Error('No internet connection...'));
          }
      };
      /**
       * JSON.stringify doesn't handle Maps
       * @param key
       * @param value
       */
      LegacyHttpConnection.prototype.mapReplacer = function (key, value) {
          if (value instanceof Map) {
              var obj_1 = {};
              value.forEach(function (mapValue, mapKey) { return (obj_1[mapKey] = mapValue); });
              return obj_1;
          }
          else {
              return value;
          }
      };
      /**
       * Main message poller for getMessages
       * @param sessionToken
       */
      LegacyHttpConnection.prototype.messagePoller = function (sessionToken, channelIdentifier) {
          return __awaiter(this, void 0, void 0, function () {
              var fetchHadErrors, _loop_1, this_1, message, error_2;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (this.activelyPolling) {
                              // For MSI polling will be always active new polling will be started via refresh message.
                              this.channelIdentifier = channelIdentifier;
                              this._startPollingFromBeginning = true;
                              // Aborting current req
                              if (this._currentHttpRequest && this._currentHttpRequest.readyState !== 4) {
                                  this._currentHttpRequest.abort();
                              }
                              // Do not restart the main loop
                              return [2 /*return*/];
                          }
                          this.activelyPolling = true;
                          Logger.log("*** Starting messagePoller *** ' " + this._id + " for session " + sessionToken);
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 6, , 7]);
                          fetchHadErrors = false;
                          _loop_1 = function () {
                              var getResponse, message, error_3, delayTime;
                              return __generator(this, function (_a) {
                                  switch (_a.label) {
                                      case 0:
                                          Logger.withoutDB('*** Starting fetch of new messages *** ' + sessionToken);
                                          if (this_1.fetchAttempts === 0) {
                                              // first processing of this fetch
                                              LegacyHttpConnection._messageSequence++;
                                          }
                                          this_1.fetchAttempts = this_1.fetchAttempts + 1;
                                          fetchHadErrors = false;
                                          _a.label = 1;
                                      case 1:
                                          _a.trys.push([1, 6, , 7]);
                                          return [4 /*yield*/, this_1.getMessages(this_1.sessionDetails ?
                                                  this_1.sessionDetails.sessionIdentifier : sessionToken)];
                                      case 2:
                                          getResponse = _a.sent();
                                          Logger.withoutDB("*** after getMessages, fetchAttempt: [" + this_1.fetchAttempts + "], status:[" + getResponse.status + "] ##");
                                          if (!(getResponse.status === 200)) return [3 /*break*/, 3];
                                          if (this_1.fetchAttempts > 1) {
                                              // ======================================
                                              // we had a previous connectivity problem
                                              // sent an an 'all clear'
                                              // ======================================
                                              this_1.publishEvent(exports.MercuryEventType.CONNECTION_ESTABLISHED, 'connection reestablished');
                                          }
                                          this_1.fetchAttempts = 0; // good response - reset the attempts
                                          return [3 /*break*/, 5];
                                      case 3: 
                                      // ===============================================
                                      // Wait for the reconnect period and then continue
                                      // ===============================================
                                      // tslint:disable-next-line: typedef
                                      return [4 /*yield*/, new Promise(function (resolve) {
                                              if (_this._startPollingFromBeginning) {
                                                  resolve(null);
                                              }
                                              setTimeout(resolve, _this._timeBetweenAttemptsReconnectMilli);
                                          })];
                                      case 4:
                                          // ===============================================
                                          // Wait for the reconnect period and then continue
                                          // ===============================================
                                          // tslint:disable-next-line: typedef
                                          _a.sent();
                                          _a.label = 5;
                                      case 5:
                                          // =========================
                                          // Process the returned data
                                          // =========================
                                          if (getResponse.response !== '') {
                                              this_1.processResponse(getResponse);
                                          }
                                          if (this_1.fetchAttempts >= this_1._warnFetchAttempts) {
                                              message = "*** Unstable connection.  The chat server is unreachable, attempt #" + this_1.fetchAttempts + " of " + this_1._maxFetchAttempts + " to reconnect...";
                                              Logger.warn(message);
                                              // Publish the error so that the library user can do something
                                              this_1.publishEvent(exports.MercuryEventType.UNSTABLE_CONNECTION, message);
                                          }
                                          return [3 /*break*/, 7];
                                      case 6:
                                          error_3 = _a.sent();
                                          Logger.error("*** Caught error in main fetch loop: [" + error_3 + "]");
                                          Logger.error(error_3);
                                          switch (error_3.name) {
                                              case exports.MercuryErrorType.INCOMPATIBLE_BROWSER:
                                              case exports.MercuryErrorType.SEVERE_ERROR: {
                                                  // Pass it on
                                                  throw error_3;
                                                  break;
                                              }
                                              default: {
                                                  // Handle as a recoverable error - do nothing
                                                  fetchHadErrors = true;
                                              }
                                          }
                                          return [3 /*break*/, 7];
                                      case 7:
                                          Logger.withoutDB('*** Finish fetch of new messages ***');
                                          delayTime = this_1._timeBetweenNormalGetsMilli;
                                          if (fetchHadErrors) {
                                              delayTime = this_1._timeBetweenAttemptsReconnectMilli;
                                          }
                                          // tslint:disable-next-line: typedef
                                          return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, delayTime); })];
                                      case 8:
                                          // tslint:disable-next-line: typedef
                                          _a.sent();
                                          if (this_1._isInitialGetMessages) {
                                              this_1._isInitialGetMessages = false;
                                          }
                                          return [2 /*return*/];
                                  }
                              });
                          };
                          this_1 = this;
                          _a.label = 2;
                      case 2:
                          if (!(this._sessionListenerMap.has(sessionToken) && this.fetchAttempts < this._maxFetchAttempts && this.activelyPolling)) return [3 /*break*/, 4];
                          return [5 /*yield**/, _loop_1()];
                      case 3:
                          _a.sent();
                          return [3 /*break*/, 2];
                      case 4:
                          if (this.fetchAttempts === this._maxFetchAttempts) {
                              message = "Maximum fetch attempts exceeded: " + this._maxFetchAttempts;
                              Logger.error(message);
                              throw new MercuryError(exports.MercuryErrorType.COMMUNICATION_LOST, message, exports.ErrorReason.CONNECTION_ERROR);
                          }
                          // ===============================================
                          // Wait for the reconnect period and then continue
                          // ===============================================
                          // tslint:disable-next-line: typedef
                          return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, _this._timeBetweenAttemptsReconnectMilli); })];
                      case 5:
                          // ===============================================
                          // Wait for the reconnect period and then continue
                          // ===============================================
                          // tslint:disable-next-line: typedef
                          _a.sent();
                          return [3 /*break*/, 7];
                      case 6:
                          error_2 = _a.sent();
                          Logger.log("*** CAUGHT ERROR [" + error_2 + "] name:[" + error_2.name + "], message:[" + error_2.message + "]");
                          switch (error_2.name) {
                              case exports.MercuryErrorType.COMMUNICATION_LOST:
                              case exports.MercuryErrorType.INCOMPATIBLE_BROWSER:
                              case exports.MercuryErrorType.SEVERE_ERROR: {
                                  // This is not going to change - Stop polling
                                  this._sessionListenerMap.delete(sessionToken);
                                  this.activelyPolling = false;
                                  // Publish the error so that the library user can do something
                                  this.publishEvent(exports.MercuryEventType.CONNECTION_ERROR, { error: error_2, reason: error_2.reason });
                                  this.publishEvent(exports.MercuryEventType.ACTIVITY_STATUS_CHANGE, {
                                      status: 'UNAVAILABLE',
                                      subTypeId: 22,
                                  });
                                  break;
                              }
                              default:
                          }
                          return [3 /*break*/, 7];
                      case 7: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Perform the fetch of the messages from the server
       * @param sessionToken Mercury session token
       * @param sequenceNumber
       */
      LegacyHttpConnection.prototype.getMessages = function (sessionToken) {
          return __awaiter(this, void 0, void 0, function () {
              var getMessagesUrl;
              var _this = this;
              return __generator(this, function (_a) {
                  getMessagesUrl = "" + this._mercuryServiceEndpoint + this._connectionEndPoints.getMessages;
                  // Get the additional header to add to the request
                  // tslint:disable-next-line: typedef
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          // ============================
                          // Construct the request object
                          // ============================
                          _this._currentHttpRequest = _this.getRequestObject('POST', getMessagesUrl, sessionToken);
                          if ('withCredentials' in _this._currentHttpRequest) {
                              // =========================
                              // Handle a connection error
                              // =========================
                              _this._currentHttpRequest.onerror = function (event) {
                                  var message = "getMessages failed with Unknown Error: [" + event + "]";
                                  Logger.log(message);
                                  reject({ name: exports.MercuryErrorType.COMMUNICATION_ERROR, message: message });
                              };
                              _this._currentHttpRequest.onabort = function (event) {
                                  if (_this._sessionListenerMap.has(sessionToken)) {
                                      // Abort happens when we need to restart the polling (Session should not be deleted)
                                      // Or a new session is created (Session is deleted in makeOSVCLogin).
                                      // or polling is terminated (Session is deleted in stopPolling)
                                      var message = "getMessages failed with ABORT Error: [" + event.type + "]";
                                      LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                                      Logger.error(message);
                                      reject({ name: exports.MercuryErrorType.COMMUNICATION_ERROR, message: message });
                                  }
                              };
                              // Catch the response
                              _this._currentHttpRequest.onreadystatechange = function () {
                                  if (_this._currentHttpRequest.readyState === 4) {
                                      var callResponse = {
                                          response: _this._currentHttpRequest.responseText,
                                          status: _this._currentHttpRequest.status,
                                      };
                                      resolve(callResponse);
                                  }
                              };
                              var body = { sequenceNumber: LegacyHttpConnection._messageSequence };
                              if (_this._startPollingFromBeginning) {
                                  body.startingSequenceNumber = 1;
                                  _this._startPollingFromBeginning = false;
                              }
                              _this._currentHttpRequest.send(JSON.stringify(body));
                          }
                          else {
                              // This version of XHR does not support CORS
                              // Handle accordingly
                              var message = 'Communication with chat-server not possible.';
                              Logger.error(message);
                              throw new MercuryError(exports.MercuryErrorType.INCOMPATIBLE_BROWSER, message, exports.ErrorReason.INCOMPATIBLE_BROWSER);
                          }
                      })];
              });
          });
      };
      /**
       * Process the getMessages response
       * @param requestResponse
       */
      LegacyHttpConnection.prototype.processResponse = function (requestResponse) {
          var responseObject;
          try {
              responseObject = JSON.parse(requestResponse.response);
              if (this.channelIdentifier) {
                  this.channelIdentifier = null;
              }
          }
          catch (e) {
              Logger.error("Unable to parse response: [" + requestResponse.response + "]");
          }
          /**
           * 500: MODIFY -> example: jsession ID not found (severe, normally: logout user)
           * 400: CANCEL -> example: chat no longer available (handle it)
           * 401: AUTH   -> example: file-upload not allowed (handle it, only file stuff, not applicable now, 1 transfer case)
           * 403: Forbidden -> example: agent logs into chat using an existing session
           * 409: WAIT   -> example: status change did not work just now, please try again (handle it)
           */
          switch (requestResponse.status) {
              case 200: {
                  Logger.withoutDB("getMessages returned -> " + JSON.stringify(requestResponse));
                  // =================================
                  // everything is fine! just continue
                  // =================================
                  if (responseObject) {
                      this.processMessages(responseObject);
                  }
                  break;
              }
              case 403:
              case 404: {
                  var message = "HTTP " + requestResponse.status + "  received in getMessages: [" + requestResponse.response + "]";
                  Logger.error(message);
                  var errorType = exports.MercuryErrorType.CLIENT_ERROR;
                  var reason = exports.ErrorReason.CONNECTION_ERROR;
                  if (responseObject.exceptionCode && 'FORBIDDEN') {
                      errorType = exports.MercuryErrorType.SEVERE_ERROR;
                      reason = exports.ErrorReason.CONFLICTING_SESSION;
                  }
                  throw new MercuryError(errorType, message, reason);
                  break;
              }
              case 500:
              case 502: {
                  var message = "HTTP " + requestResponse.status + " received in getMessages";
                  Logger.error(message);
                  throw new MercuryError(exports.MercuryErrorType.SEVERE_ERROR, message, exports.ErrorReason.CONNECTION_ERROR);
                  break;
              }
              default: {
                  // request did not work (at this time)
                  var message = "Client error (" + requestResponse.status + ")received in get Messages: [" + requestResponse.response + "]";
                  Logger.warn(message);
                  throw new MercuryError(exports.MercuryErrorType.CLIENT_ERROR, message, exports.ErrorReason.UNKNOWN_ERROR);
              }
          }
      };
      LegacyHttpConnection.prototype.getLastPostMessageSequenceNumberMap = function (responseMessages) {
          var _this = this;
          // Extract last postmessage's sequenceNumber for each engagement
          if (this._isInitialGetMessages) {
              var postMessages = responseMessages.filter(function (responseMessage) { return responseMessage.ChatPostMessage; });
              if (postMessages.length) {
                  postMessages.forEach(function (postMessage) {
                      var _a = postMessage.ChatPostMessage, destinationIdString = _a.destinationIdString, sequenceNumber = _a.sequenceNumber;
                      if (sequenceNumber >= (_this._lastPostMessageSequenceNumberMap.get(destinationIdString) || 0)) {
                          _this._lastPostMessageSequenceNumberMap.set(destinationIdString, sequenceNumber);
                      }
                  });
              }
          }
          return this._lastPostMessageSequenceNumberMap;
      };
      LegacyHttpConnection.prototype.isLatestPostMessage = function (channelIdentifier, currentMessageSequenceNumber, lastPostMessageSequenceNumberMap) {
          var isNewMessage = !this.isProcessedResponse(channelIdentifier, currentMessageSequenceNumber);
          var isLastPostAfterBrowserRefresh = currentMessageSequenceNumber === (lastPostMessageSequenceNumberMap.get(channelIdentifier) || 0);
          return isLastPostAfterBrowserRefresh || isNewMessage;
      };
      /**
       * Perform the message specific logic
       * @param response
       */
      LegacyHttpConnection.prototype.processMessages = function (response) {
          var _this = this;
          var responseMessages = response.getResponseTypes;
          if (responseMessages) {
              var lastPostMessageSequenceNumberMap_1 = this.getLastPostMessageSequenceNumberMap(responseMessages);
              responseMessages.forEach(function (message) {
                  var messageType = Object.keys(message)[0];
                  var channelIdentifier = '0';
                  if ((message[messageType].destinationType === 'ENGAGEMENT' && message[messageType].destinationIdString !== undefined)) {
                      channelIdentifier = message[messageType].destinationIdString;
                  }
                  else if (message[messageType].engagementIdString !== undefined) {
                      channelIdentifier = message[messageType].engagementIdString;
                  }
                  var currentMessageSequenceNumber = message[messageType].sequenceNumber || 0;
                  // We have a message to  process
                  if (message.ChatGetTimeout) {
                      // ====================
                      // No returned Messages
                      // ====================
                      Logger.withoutDB('No new Message');
                  }
                  else if (message.ChatSystemError) {
                      // =========================
                      // System Error has occurred
                      // =========================
                      Logger.error('ChatSystemError not implemented');
                  }
                  else if (message.ChatAssignmentInvitationCancelled) {
                      // ====================
                      // Invitation cancelled
                      // ====================
                      var legacyMessage = message.ChatAssignmentInvitationCancelled;
                      var newMessage = ChatAssignmentInvitationCancelled.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.OFFER_CANCELLATION_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.OFFER_CANCELLATION, newMessage);
                      }
                  }
                  else if (message.ChatEngagementParticipantAdded) {
                      // Ignore the message role is TRANSIENT
                      if (message.ChatEngagementParticipantAdded.role === exports.ParticipationRoleType.TRANSIENT) {
                          return;
                      }
                      // ====================
                      // Participant added
                      // ====================
                      // Convert to new Format and send to any listeners
                      var legacyMessage = message.ChatEngagementParticipantAdded;
                      var newMessage = ChatEngagementParticipantAdded.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_JOINED_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_JOINED, newMessage);
                      }
                      // Currently, the greeting message is not send as a separate post message (Screwed up)
                      // So we need to fake the post message
                      // If they have a greeting, fake a new postMessage and publish it
                      // Adding Greeting message only for lead.
                      if (newMessage.greeting && message.ChatEngagementParticipantAdded.role === exports.ParticipationRoleType.LEAD) {
                          var fakePost = ChatEngagementParticipantAdded.generateFakePost(legacyMessage);
                          _this.publishEvent(exports.MercuryEventType.MESSAGE_ADDED, fakePost);
                      }
                  }
                  else if (message.ChatEngagementAssignment) {
                      // =================
                      // New Chat Assigned
                      // =================
                      var assignmentMessage = message.ChatEngagementAssignment;
                      var offer = ChatEngagementAssignment.convert(assignmentMessage, _this._localeString);
                      _this.contactInfoStore.set(assignmentMessage.engagementIdString, assignmentMessage.contactInfo);
                      if (_this.isProcessedResponse(assignmentMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.WORK_OFFER_HISTORY, offer);
                      }
                      else {
                          offer.context.set(exports.ChannelContextNameType.FUSION_ENGAGEMENT_ID, assignmentMessage.engagementIdString + '_' + Date.now());
                          _this.publishEvent(exports.MercuryEventType.WORK_OFFER, offer);
                      }
                  }
                  else if (message.WorkOfferMessage) {
                      // ========================
                      // New Work Offer
                      // ========================
                      var legacyMessage = message.WorkOfferMessage;
                      var offer = WorkOfferMessage.convert(legacyMessage, _this._localeString);
                      if (_this.isProcessedResponse(legacyMessage.channelId, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.WORK_OFFER_HISTORY, offer);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.WORK_OFFER, offer);
                      }
                  }
                  else if (message.ChatPostMessage) {
                      // ================
                      // New Post Message
                      // ================
                      var incomingMessage = message.ChatPostMessage;
                      var mercuryMessage = ChatPostMessage.convert(incomingMessage);
                      mercuryMessage.allowSuggestions = _this.isLatestPostMessage(channelIdentifier, currentMessageSequenceNumber, lastPostMessageSequenceNumberMap_1);
                      if (mercuryMessage.isAgentsOnly) {
                          _this.publishEvent(exports.MercuryEventType.PRIVATE_MESSAGE_ADDED, mercuryMessage);
                      }
                      if (_this.isProcessedResponse(incomingMessage.destinationIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.MESSAGE_ADDED_HISTORY, mercuryMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.MESSAGE_ADDED, mercuryMessage);
                      }
                  }
                  else if (message.ChatMediaInvitationMessage) {
                      // =================
                      // Media Invitation
                      // =================
                      Logger.error('ChatMediaInvitationMessage not implemented');
                  }
                  else if (message.ChatMediaCrashNotification) {
                      // ======================================
                      // Media message when console had crashed
                      // ======================================
                      Logger.error('ChatMediaCrashNotification not implemented');
                  }
                  else if (message.ChatMediaStatusNotification) {
                      // ==========================================
                      // Media engagement status notification event
                      // ==========================================
                      Logger.error('ChatMediaStatusNotification not implemented');
                  }
                  else if (message.ChatMediaTokenMessage) {
                      // =========================================
                      // Media engagement token notification event
                      // =========================================
                      Logger.error('ChatMediaTokenMessage not implemented');
                  }
                  else if (message.ChatDisconnectNotification) {
                      // ===========================
                      // Other party has disconncted
                      // ===========================
                      var disconnectMessage = message.ChatDisconnectNotification;
                      var memberLeftMessage = ChatDisconnectNotification.convert(disconnectMessage);
                      if (_this.isProcessedResponse(disconnectMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_LEFT_HISTORY, memberLeftMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_LEFT, memberLeftMessage);
                      }
                  }
                  else if (message.WorkOfferStatus) {
                      // ========================
                      // Offer status has changed
                      // ========================
                      var legacyMessage = message.WorkOfferStatus;
                      var offerStatus = WorkOfferStatus.convert(legacyMessage, _this.sessionDetails.sessionIdentifier);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.OFFER_STATUS_HISTORY, offerStatus);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.OFFER_STATUS, offerStatus);
                      }
                  }
                  else if (message.ChatRoleChangeNotification) {
                      // ======================
                      // Agent role has changed
                      // ======================
                      var changeMsg = message.ChatRoleChangeNotification;
                      var roleChange = ChatRoleChangeNotification.convert(changeMsg, _this.sessionDetails.clientIdentifier);
                      if (roleChange.role !== null) {
                          if (_this.isProcessedResponse(roleChange.channelIdentifier, currentMessageSequenceNumber)) {
                              _this.publishEvent(exports.MercuryEventType.ROLE_CHANGE_HISTORY, roleChange);
                          }
                          else {
                              _this.publishEvent(exports.MercuryEventType.ROLE_CHANGE, roleChange);
                          }
                      }
                      var payload = {
                          channelIdentifier: changeMsg.engagementIdString,
                          created: new Date(changeMsg.createdTime),
                          newLead: changeMsg.leadClientIdString,
                          oldLead: changeMsg.confereeClientIdString,
                      };
                      if (_this.isProcessedResponse(payload.channelIdentifier, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.LEAD_CHANGE_HISTORY, payload);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.LEAD_CHANGE, payload);
                      }
                  }
                  else if (message.ChatActivitySignal) {
                      // ======================
                      // Activity Message
                      // ======================
                      var activitySignal = message.ChatActivitySignal;
                      var activityMessage = ChatActivitySignal.convert(activitySignal);
                      if (!_this.isProcessedResponse(activitySignal.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.ACTIVITY_CHANGE, activityMessage);
                      }
                  }
                  else if (message.ChatInvitationStatusNotification) {
                      // =================
                      // Invitation Status
                      // =================
                      var legacyMessage = message.ChatInvitationStatusNotification;
                      var newMessage = ChatInvitationStatusNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.OFFER_STATUS_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.OFFER_STATUS, newMessage);
                      }
                  }
                  else if (message.ChatFileAttachStatusNotification) {
                      // ============================
                      // File attachment notification
                      // ============================
                      var legacyMessage = message.ChatFileAttachStatusNotification;
                      var newMessage = ChatFileAttachStatusNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.UPLOAD_STATUS_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.UPLOAD_STATUS, newMessage);
                      }
                  }
                  else if (message.ChatFileAttachNotification) {
                      // ===============================================
                      // file attachment notification, canceled or error
                      // ===============================================
                      var legacyMessage = message.ChatFileAttachNotification;
                      var newMessage = ChatFileAttachNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.UPLOAD_COMPLETED_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.UPLOAD_COMPLETED, newMessage);
                      }
                  }
                  else if (message.ResourceAvailabilityChange) {
                      // ===================
                      // Availability Change
                      // ===================
                      var legacyMessage = message.ResourceAvailabilityChange;
                      var newMessage = ResourceAvailabilityChange.convert(legacyMessage);
                      _this.publishEvent(exports.MercuryEventType.AVAILABILITY_CHANGE, newMessage);
                  }
                  else if (message.ChatEngagementUpdateNotification) {
                      // =================
                      // Engagement Update
                      // =================
                      var legacyMessage = message.ChatEngagementUpdateNotification;
                      var newMessage = ChatEngagementUpdateNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_UPDATED_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.MEMBER_UPDATED, newMessage);
                      }
                  }
                  else if (message.ChatReleaseNotification) {
                      // ================
                      // Channel Released
                      // ================
                      var legacyMessage = message.ChatReleaseNotification;
                      var newMessage = ChatReleaseNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementId, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.CHANNEL_REMOVED_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.CHANNEL_REMOVED, newMessage);
                      }
                  }
                  else if (message.EngagementPropertyUpdateNotification) {
                      // ================
                      // Context Update
                      // ================
                      var legacyMessage = message.EngagementPropertyUpdateNotification;
                      var newMessage = EngagementPropertyUpdateNotification.convert(legacyMessage);
                      if (_this.isProcessedResponse(legacyMessage.engagementIdString, currentMessageSequenceNumber)) {
                          _this.publishEvent(exports.MercuryEventType.CONTEXT_UPDATE_HISTORY, newMessage);
                      }
                      else {
                          _this.publishEvent(exports.MercuryEventType.CONTEXT_UPDATE, newMessage);
                      }
                  }
                  if (channelIdentifier !== '0') {
                      var savedMessageSequenceNumber = _this._currentSequenceNumberMap.get(channelIdentifier) || 0;
                      if (currentMessageSequenceNumber > savedMessageSequenceNumber) {
                          _this._currentSequenceNumberMap.set(channelIdentifier, currentMessageSequenceNumber);
                      }
                  }
              });
          }
      };
      /**
       * Set up the connection http headers
       * @param sessionToken Mercury session token
       */
      LegacyHttpConnection.prototype.getHeaders = function (sessionToken) {
          var addHeaders = { 'x-aid': this._clientConfiguration.accountId }; // TODO remove when server is fixed :chatconfig.loginData.accountId};
          if (sessionToken) {
              // chatconfig.getAgentIsLoggedIn()) {
              addHeaders['X-JSESSIONID'] = sessionToken;
              if (this._previousSessionToken && this._previousSessionToken !== sessionToken) {
                  Logger.log("### Session Token change from " + this._previousSessionToken + " to " + sessionToken + " with id " + this._id);
                  Logger.log('### This is valid, if we received makeOsvcLogin request');
              }
              this._previousSessionToken = sessionToken;
          }
          else {
              var authJWT = this._authenticationToken;
              if (authJWT) {
                  // tslint:disable-next-line: no-string-literal
                  addHeaders['Authorization'] = "Bearer " + authJWT;
              }
          }
          return addHeaders;
      };
      /**
       * Obtain a HTTP request object
       * @param method
       * @param url
       * @param sessionToken optional SessionToken for session based messages
       */
      LegacyHttpConnection.prototype.getRequestObject = function (method, url, sessionToken) {
          Logger.log("*** Creating request for " + url);
          var xhr = new XMLHttpRequest();
          xhr.open(method, url);
          xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
          var headers = this.getHeaders(sessionToken);
          for (var header in headers) {
              if (headers.hasOwnProperty(header)) {
                  xhr.setRequestHeader(header, headers[header]);
              }
          }
          return xhr;
      };
      /**
       * Obtain a HTTP request object for makeLoginRequestSupervisor()
       * @param method
       * @param url
       * @param sessionToken optional SessionToken for session based messages
       */
      LegacyHttpConnection.prototype.getRequestObjectSupervisor = function (method, url) {
          Logger.debug("Creating request for " + url);
          var xhr = new XMLHttpRequest();
          xhr.open(method, url);
          xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
          return xhr;
      };
      LegacyHttpConnection.prototype.doEndSession = function (sessionToken, forced) {
          if (forced === void 0) { forced = false; }
          return __awaiter(this, void 0, void 0, function () {
              var requestMessage, response, errorObj, message;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          // Increment the message sequence
                          LegacyHttpConnection._messageSequence = LegacyHttpConnection._messageSequence + 1;
                          requestMessage = {
                              forceLogoff: forced,
                              sequenceNumber: LegacyHttpConnection._messageSequence,
                          };
                          return [4 /*yield*/, this.post(sessionToken, "" + this._mercuryServiceEndpoint + this._connectionEndPoints.logoff, 'logoff', requestMessage, false)];
                      case 1:
                          response = (_a.sent());
                          // Call Success
                          if (response.chatSystemError) {
                              errorObj = response.chatSystemError;
                              message = "System Error " + errorObj.errorCondition + " " + errorObj.text + " " + errorObj.type;
                              Logger.log(message);
                              throw new Error(message);
                          }
                          return [2 /*return*/];
                  }
              });
          });
      };
      LegacyHttpConnection.prototype.isAlreadySet = function (property, destination, engagementId) {
          if (!modifyPropertiesCache.get(engagementId)) {
              modifyPropertiesCache.set(engagementId, new Map());
              modifyPropertiesCache.get(engagementId).set(destination + property.name, property.value);
              return false;
          }
          if (modifyPropertiesCache.get(engagementId).get(destination + property.name) !== property.value) {
              modifyPropertiesCache.get(engagementId).set(destination + property.name, property.value);
              return false;
          }
          return true;
      };
      LegacyHttpConnection.prototype.isProcessedResponse = function (channelIdentifier, sequenceNumber) {
          var messageSequenceNumber = this._currentSequenceNumberMap.get(channelIdentifier) || 0;
          return messageSequenceNumber > 0 && sequenceNumber <= messageSequenceNumber;
      };
      LegacyHttpConnection.prototype.constructMessageDataMapBody = function (messageDataMap) {
          var mapKeyValueObject = {};
          if (messageDataMap.size > 0) {
              messageDataMap.forEach(function (value, key) {
                  mapKeyValueObject[key] = value;
              });
          }
          return mapKeyValueObject;
      };
      LegacyHttpConnection.prototype.getActiveChats = function () {
          return this.activeEngagements.length;
      };
      LegacyHttpConnection.prototype.getMaxChats = function () {
          return this._clientConfiguration.maxSessions;
      };
      LegacyHttpConnection.prototype.getMaxActiveChats = function () {
          return Math.min(this._clientConfiguration.maxActiveSessions, this.getMaxChats());
      };
      LegacyHttpConnection.prototype.addEngagement = function (engagementId, sessionToken, ignoreRequestAssignment) {
          if (ignoreRequestAssignment === void 0) { ignoreRequestAssignment = false; }
          if (!this.activeEngagements.includes(engagementId)) {
              this.activeEngagements.push(engagementId);
              if (!ignoreRequestAssignment) {
                  this.requestAssignment(sessionToken, null, false);
              }
          }
      };
      LegacyHttpConnection.prototype.removeEngagement = function (engagementId, sessionToken) {
          if (this.activeEngagements.includes(engagementId)) {
              var index = this.activeEngagements.indexOf(engagementId);
              this.activeEngagements.splice(index, 1);
              this.requestAssignment(sessionToken, null, false);
          }
      };
      LegacyHttpConnection.prototype.populateEngagements = function (engagements, sessionToken) {
          var e_4, _a;
          if (engagements && engagements.length > 0) {
              try {
                  for (var engagements_1 = __values(engagements), engagements_1_1 = engagements_1.next(); !engagements_1_1.done; engagements_1_1 = engagements_1.next()) {
                      var engagement = engagements_1_1.value;
                      this.addEngagement(engagement.identifier, sessionToken, true);
                  }
              }
              catch (e_4_1) { e_4 = { error: e_4_1 }; }
              finally {
                  try {
                      if (engagements_1_1 && !engagements_1_1.done && (_a = engagements_1.return)) _a.call(engagements_1);
                  }
                  finally { if (e_4) throw e_4.error; }
              }
          }
      };
      LegacyHttpConnection.AVAILABLE_STATUS_CODE = 21;
      LegacyHttpConnection._messageSequence = 0;
      return LegacyHttpConnection;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
      contactInfo:
      customFields: []
      firstName: "Dave"
      lastName: "Stowell"
      emailAddress: "d@s.com"
      interfaceId: 1
      interfaceLanguageCode: ""
      contactId: -1
      contactIdString: "-1"
      orgId: -1
      orgIdString: "-1"
      sessionId: "eUhGEGdDP8wNsafXELbUGKCvkCY..."
      question: "dstest"
      productId: -1
      productIdString: "-1"
      categoryId: -1
      categoryIdString: "-1"
      queueId: -1
          queueNames: {
              "en_US": "Q3"
          },
      browser: ""
      userAgent: ""
      ipAddress: "10.159.129.86"
      operatingSystem: ""
      coBrowseEnabled: false
      visitorId: ""
      engagementEngineId: ""
      referrerUrl: ""
      eStaraFsguid: ""
      engagementEngineSessionId: ""
      coBrowsePremiumSupported: -1
      mediaList: []

  */
  /**
   * This interface specifies the subset of fields used by us for
   * message mapping purposes
   * This interface maps the 'contactInfo' object of the
   * 'ChatEngagementAssignment' object
   */
  var ContactInfo = /** @class */ (function () {
      function ContactInfo(offerContext) {
          this.firstName = offerContext.get(exports.ChannelContextNameType.FIRST_NAME);
          this.lastName = offerContext.get(exports.ChannelContextNameType.LAST_NAME);
          this.emailAddress = offerContext.get(exports.ChannelContextNameType.EMAIL);
          this.question = offerContext.get(exports.ChannelContextNameType.QUESTION);
          this.productIdString = offerContext.get(exports.ChannelContextNameType.PRODUCT_ID);
          this.categoryIdString = offerContext.get(exports.ChannelContextNameType.CATEGORY_ID);
          this.contactIdString = offerContext.get(exports.ChannelContextNameType.CONTACT_ID);
          this.queueIdString = offerContext.get(exports.ChannelContextNameType.QUEUE_ID);
          this.customFields = offerContext.get('customFields');
          this.fileAttachmentsSupported = offerContext.get('fileAttachmentsSupported');
      }
      return ContactInfo;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (OfferResponseType) {
      OfferResponseType["MANUAL"] = "MANUAL";
      OfferResponseType["AUTO"] = "AUTO";
      OfferResponseType["FORCED"] = "FORCED";
  })(exports.OfferResponseType || (exports.OfferResponseType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /**
   * This class represents the main link to the Mercury server
   * When one wants to communicate with Mercury, they first need to establish a Session
   */
  var Session = /** @class */ (function () {
      function Session(configuration) {
          var _this = this;
          this._availability = new Map();
          this._channels = [];
          this._sessionDetails = null;
          if (configuration.loggingLevel) {
              Logger.level = configuration.loggingLevel;
          }
          Logger.log('Session constructor');
          this._configuration = configuration;
          Logger.setDebugMode(this._configuration.debugEnabled);
          this._isCustomAvailabilityEnabled = false;
          this.isInitialized = new Promise(function (resolve, reject) {
              _this._resolveRef = resolve;
          });
          this.resolveAndCreateConnection();
      }
      Session.createOsvcSession = function (identityToken, configuration) {
          return __awaiter(this, void 0, void 0, function () {
              var mySession;
              return __generator(this, function (_a) {
                  Logger.log('### session create OSVC');
                  mySession = new Session(configuration);
                  if (identityToken == null || identityToken === '') {
                      throw new Error('identityToken must contain a value');
                  }
                  mySession._sessionIdentifier = identityToken;
                  return [2 /*return*/, mySession];
              });
          });
      };
      /**
       * Based on the authentication token, allocate a session connects to OSVC sites
       * @param identityToken Identity token (JWT)
       * @param configuration Configuration values
       * @returns a Session object
       */
      Session.createNonMercuryOsvc = function (identityToken, configuration) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  return [2 /*return*/, Session.create(identityToken, configuration, true)];
              });
          });
      };
      /**
       * Based on the authentication token, allocate a session
       * @param identityToken Identity token (JWT)
       * @param configuration Configuration values
       * @returns a Session object
       */
      Session.create = function (identityToken, configuration, nonMercuryOSVC) {
          if (nonMercuryOSVC === void 0) { nonMercuryOSVC = false; }
          var _a, _b;
          return __awaiter(this, void 0, void 0, function () {
              var mySession, sessionDetails, _c;
              return __generator(this, function (_d) {
                  switch (_d.label) {
                      case 0:
                          Logger.log('Session create');
                          try {
                              configuration.endPoint = configuration.endPoint.replace(/\/v\d\/$/, '');
                          }
                          catch (e) {
                              Logger.log('Invalid URL');
                          }
                          ChatConfig.setPool(configuration.pool);
                          mySession = new Session(configuration);
                          if (identityToken == null || identityToken === '') {
                              throw new Error('identityToken must contain a value');
                          }
                          if (((_a = configuration === null || configuration === void 0 ? void 0 : configuration.queues) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                              configuration.queues.forEach(function (queue) {
                                  QueueStore.populateQueue(queue.id, queue);
                              });
                          }
                          return [4 /*yield*/, mySession.isInitialized];
                      case 1:
                          _d.sent();
                          if (!nonMercuryOSVC) return [3 /*break*/, 3];
                          return [4 /*yield*/, mySession._connection.makeOSVCLogin(identityToken, configuration.delayGetMessages)];
                      case 2:
                          _c = _d.sent();
                          return [3 /*break*/, 5];
                      case 3: return [4 /*yield*/, mySession._connection.makeLoginRequest(identityToken, configuration.delayGetMessages)];
                      case 4:
                          _c = _d.sent();
                          _d.label = 5;
                      case 5:
                          sessionDetails = _c;
                          // Populate the Session object
                          mySession._sessionDetails = sessionDetails;
                          mySession._sessionIdentifier = sessionDetails.sessionIdentifier;
                          mySession._clientIdentifier = sessionDetails.clientIdentifier;
                          // =================================================================
                          // Add any Channels - these will exist if we are rejoining a session
                          // =================================================================
                          (_b = sessionDetails.channels) === null || _b === void 0 ? void 0 : _b.forEach(function (channel) {
                              channel = Channel.convert(channel);
                              // We only get a skeleton of the channel - only a few attributes
                              channel.connection(mySession._connection);
                              channel.recordMyParticipation(mySession._clientIdentifier);
                              mySession.addChannel(channel);
                          });
                          // ============================================
                          // Synchronize the server availability settings
                          // ============================================
                          mySession._isCustomAvailabilityEnabled = false;
                          mySession._availability = sessionDetails.availability;
                          if (sessionDetails.customAvailability) {
                              mySession._isCustomAvailabilityEnabled = true;
                              mySession._customAvailability = sessionDetails.customAvailability;
                              mySession._currentCustomAvailabilityStateId = sessionDetails.customAvailability.currentStateId;
                          }
                          // Register interest in Offer status changes - Transfer usecases
                          mySession._connection.on(exports.MercuryEventType.CONTEXT_UPDATE, function (type, payload) {
                              var _a;
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                                  if (payload.assignmentType === exports.AssignmentType.TRANSFER) {
                                      // if the acceptee is not me and I'm lead for this channel, I need to switch to 'CONFEREE'
                                      var acceptedChannelID_1 = payload.channelIdentifier;
                                      var myChannel = mySession._channels.find(function (channel) { return channel.identifier === acceptedChannelID_1; });
                                      if (myChannel) {
                                          // We found the matching channel
                                          if (((_a = myChannel.myParticipant) === null || _a === void 0 ? void 0 : _a.role) === exports.ParticipationRoleType.LEAD) {
                                              // reset to 'CONFEREE'
                                              myChannel.myParticipant.role = exports.ParticipationRoleType.CONFEREE;
                                              var roleChangePayload = {
                                                  channelIdentifier: myChannel.identifier,
                                                  role: myChannel.myParticipant.role,
                                              };
                                              // Raise an event telling people of the change
                                              mySession._connection.publishEvent(exports.MercuryEventType.ROLE_CHANGE, roleChangePayload);
                                          }
                                      }
                                  }
                              }
                          }, true);
                          mySession._connection.on(exports.MercuryEventType.OFFER_STATUS, function (type, payload) {
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                              }
                          }, true);
                          // tslint:disable-next-line: no-shadowed-variable
                          mySession._connection.on(exports.MercuryEventType.SESSION_CHANGED, function (type, sessionDetails) {
                              var _a;
                              // Populate the Session object
                              Logger.log('#### UPDATING SESSION IN => ' + window.name + ' as => ' + sessionDetails.sessionIdentifier);
                              mySession._sessionIdentifier = sessionDetails.sessionIdentifier;
                              mySession._clientIdentifier = sessionDetails.clientIdentifier;
                              (_a = sessionDetails.channels) === null || _a === void 0 ? void 0 : _a.forEach(function (channel) {
                                  var existingChannel = mySession._channels.find(function (exChannel) {
                                      return exChannel.identifier === channel.identifier;
                                  });
                                  if (!existingChannel) {
                                      var newChannel = Channel.convert(channel);
                                      // This means a new channel is available and was accepted in another session
                                      newChannel.connection(mySession._connection);
                                      newChannel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(newChannel);
                                      Logger.log('### add New Channel with id => ' + channel.identifier);
                                  }
                              });
                              // ============================================
                              // Synchronize the server availability settings
                              // ============================================
                              mySession._isCustomAvailabilityEnabled = false;
                              mySession._availability = sessionDetails.availability;
                              mySession._sessionDetails = sessionDetails;
                              if (sessionDetails.customAvailability) {
                                  mySession._isCustomAvailabilityEnabled = true;
                                  mySession._customAvailability = sessionDetails.customAvailability;
                                  mySession._currentCustomAvailabilityStateId = sessionDetails.customAvailability.currentStateId;
                              }
                          });
                          mySession._connection.on(exports.MercuryEventType.NEW_CHANNEL, function (type, response) {
                              // This means a new channel is available and was accepted in another session
                              var channel = Channel.convert(response.channel);
                              channel.connection(mySession._connection);
                              channel.sessionToken = mySession._sessionIdentifier;
                              channel.recordMyParticipation(mySession._clientIdentifier);
                              // Copy over values from offer into Channel
                              var offer = response.offer;
                              channel.context = offer.context;
                              channel.externalIdString = offer.externalIdString;
                              channel.workTypeCode = offer.workTypeCode;
                              channel.contactInfo = new ContactInfo(offer.context);
                              channel.fusionChannelId = offer.fusionChannelId;
                              channel.conversationId = offer.conversationId;
                              // Register listener
                              channel.registerStateListener(function (channelId, stateName) {
                                  mySession.channelStateListener(channelId, stateName);
                              });
                              // Add the new channel to our list
                              mySession.addChannel(channel);
                              Logger.log('### add New Channel with id => ' + channel.identifier);
                          }, true);
                          return [2 /*return*/, mySession];
                  }
              });
          });
      };
      /**
       * Allocate a Supervisor Session using a mercury session cookie
       *
       * @param configuration Configuration object with the endpoint set
       * @returns a Session object
       */
      Session.createSupervisor = function (configuration) {
          return __awaiter(this, void 0, void 0, function () {
              var mySession, sessionDetails;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          Logger.log('Session create');
                          mySession = new Session(configuration);
                          return [4 /*yield*/, mySession._connection.makeLoginRequestSupervisor(false)];
                      case 1:
                          sessionDetails = _a.sent();
                          // Populate the Session object
                          mySession._sessionIdentifier = sessionDetails.sessionIdentifier;
                          mySession._clientIdentifier = sessionDetails.clientIdentifier;
                          // =================================================================
                          // Add any Channels - these will exist if we are rejoining a session
                          // =================================================================
                          sessionDetails.channels.forEach(function (channel) {
                              // We only get a skeleton of the channel - only a few attributes
                              channel = Channel.convert(channel);
                              channel.connection(mySession._connection);
                              channel.recordMyParticipation(mySession._clientIdentifier);
                              channel.isSupervisor = true;
                              mySession.addChannel(channel);
                          });
                          // ============================================
                          // Synchronize the server availability settings
                          // ============================================
                          mySession._isCustomAvailabilityEnabled = false;
                          mySession._availability = sessionDetails.availability;
                          if (sessionDetails.customAvailability) {
                              mySession._isCustomAvailabilityEnabled = true;
                              mySession._customAvailability = sessionDetails.customAvailability;
                              mySession._currentCustomAvailabilityStateId = sessionDetails.customAvailability.currentStateId;
                          }
                          // Register interest in Offer status changes
                          mySession._connection.on(exports.MercuryEventType.CONTEXT_UPDATE, function (type, payload) {
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                              }
                          }, true);
                          mySession._connection.on(exports.MercuryEventType.OFFER_STATUS, function (type, payload) {
                              var _a;
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                              }
                              if (payload.assignmentType === exports.AssignmentType.TRANSFER) {
                                  // if the acceptee is not me and I'm lead for this channel, I need to switch to 'CONFEREE'
                                  var acceptedChannelID_2 = payload.channelIdentifier;
                                  var myChannel = mySession._channels.find(function (channel) { return channel.identifier === acceptedChannelID_2; });
                                  if (myChannel) {
                                      // We found the matching channel
                                      if (((_a = myChannel.myParticipant) === null || _a === void 0 ? void 0 : _a.role) === exports.ParticipationRoleType.LEAD) {
                                          // reset to 'CONFEREE'
                                          myChannel.myParticipant.role = exports.ParticipationRoleType.CONFEREE;
                                          var roleChangePayload = {
                                              channelIdentifier: myChannel.identifier,
                                              role: myChannel.myParticipant.role,
                                          };
                                          // Raise an event telling people of the change
                                          mySession._connection.publishEvent(exports.MercuryEventType.ROLE_CHANGE, roleChangePayload);
                                      }
                                  }
                              }
                          }, true);
                          return [2 /*return*/, mySession];
                  }
              });
          });
      };
      /**
       * Based on the authentication token, allocate a session
       * @param identityToken Identity token (JWT)
       * @param configuration Configuration values
       * @returns a Session object
       */
      Session.createWorkObjects = function (identityToken, configuration) {
          return __awaiter(this, void 0, void 0, function () {
              var mySession, sessionDetails;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          Logger.log('Session create');
                          mySession = new Session(configuration);
                          if (identityToken == null || identityToken === '') {
                              throw new Error('identityToken must contain a value');
                          }
                          return [4 /*yield*/, mySession._connection.makeLoginRequestWorkObjects(identityToken, configuration.delayGetMessages)];
                      case 1:
                          sessionDetails = _a.sent();
                          // Populate the Session object
                          mySession._sessionIdentifier = sessionDetails.sessionIdentifier;
                          mySession._clientIdentifier = sessionDetails.clientIdentifier;
                          mySession._workTypeDefinition = sessionDetails.workTypeDefinition;
                          // =================================================================
                          // Add any Channels - these will exist if we are rejoining a session
                          // =================================================================
                          sessionDetails.channels.forEach(function (channel) {
                              channel = Channel.convert(channel);
                              // We only get a skeleton of the channel - only a few attributes
                              channel.connection(mySession._connection);
                              channel.recordMyParticipation(mySession._clientIdentifier);
                              mySession.addChannel(channel);
                          });
                          // ============================================
                          // Synchronize the server availability settings
                          // ============================================
                          mySession._isCustomAvailabilityEnabled = false;
                          mySession._availability = sessionDetails.availability;
                          if (sessionDetails.customAvailability) {
                              mySession._isCustomAvailabilityEnabled = true;
                              mySession._customAvailability = sessionDetails.customAvailability;
                              mySession._currentCustomAvailabilityStateId = sessionDetails.customAvailability.currentStateId;
                          }
                          // Register interest in Offer status changes - Transfer usecases
                          mySession._connection.on(exports.MercuryEventType.CONTEXT_UPDATE, function (type, payload) {
                              var _a;
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                                  if (payload.assignmentType === exports.AssignmentType.TRANSFER) {
                                      // if the acceptee is not me and I'm lead for this channel, I need to switch to 'CONFEREE'
                                      var acceptedChannelID_3 = payload.channelIdentifier;
                                      var myChannel = mySession._channels.find(function (channel) { return channel.identifier === acceptedChannelID_3; });
                                      if (myChannel) {
                                          // We found the matching channel
                                          if (((_a = myChannel.myParticipant) === null || _a === void 0 ? void 0 : _a.role) === exports.ParticipationRoleType.LEAD) {
                                              // reset to 'CONFEREE'
                                              myChannel.myParticipant.role = exports.ParticipationRoleType.CONFEREE;
                                              var roleChangePayload = {
                                                  channelIdentifier: myChannel.identifier,
                                                  role: myChannel.myParticipant.role,
                                              };
                                              // Raise an event telling people of the change
                                              mySession._connection.publishEvent(exports.MercuryEventType.ROLE_CHANGE, roleChangePayload);
                                          }
                                      }
                                  }
                              }
                          }, true);
                          mySession._connection.on(exports.MercuryEventType.OFFER_STATUS, function (type, payload) {
                              if (payload.status === exports.OfferStatusTypes.ACCEPTED) {
                                  if (payload.channel) {
                                      payload.channel = Channel.convert(payload.channel);
                                      // This means a new channel is available and was accepted in another session
                                      payload.channel.connection(mySession._connection);
                                      payload.channel.recordMyParticipation(mySession._clientIdentifier);
                                      mySession.addChannel(payload.channel);
                                  }
                              }
                          }, true);
                          return [2 /*return*/, mySession];
                  }
              });
          });
      };
      Session.disableSharedWorker = function () {
          Session.iSharedWorkerDisabled = true;
      };
      Object.defineProperty(Session.prototype, "isCustomAvailabilityEnabled", {
          /**
           * Returns a copy of the custom availability status flag for this Session
           */
          get: function () {
              return this._isCustomAvailabilityEnabled ? true : false;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Session.prototype, "availability", {
          /**
           * Returns a copy of the current availability map for this Session
           */
          get: function () {
              return new Map(this._availability);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Session.prototype, "customAvailability", {
          /**
           * Returns a copy of the current custom availability for this Session
           */
          get: function () {
              return new CustomAvailability(this._customAvailability.currentStateId, this._customAvailability.states);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Session.prototype, "clientIdentifier", {
          /**
           * Return the Session's clientIdentifier
           */
          get: function () {
              return this._clientIdentifier;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Session.prototype, "sessionIdentifier", {
          /*
           * Returns Session's session token
           */
          get: function () {
              return this._sessionIdentifier;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Session.prototype, "workTypeDefinition", {
          /*
           * Returns Session's WorkTypeDefinitionMap
           */
          get: function () {
              return this._workTypeDefinition;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Start listening for incoming messages
       * NOTE: You should register your event listeners
       * before this point.
       */
      Session.prototype.startListening = function (channelId) {
          this._connection.startListening(this._sessionIdentifier, channelId);
      };
      /**
       * End/Log out a Session
       * This method will close the link to the Mercury server
       * @param forced
       */
      Session.prototype.end = function (forced) {
          if (forced === void 0) { forced = false; }
          return __awaiter(this, void 0, void 0, function () {
              var error_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          // Stop listening for incoming messages
                          this._connection.stopListening();
                          _a.label = 1;
                      case 1:
                          _a.trys.push([1, 3, , 4]);
                          return [4 /*yield*/, this._connection.endSession(this._sessionIdentifier, forced)];
                      case 2:
                          _a.sent();
                          return [3 /*break*/, 4];
                      case 3:
                          error_1 = _a.sent();
                          Logger.error("Failed to end Session [" + this._sessionIdentifier + "] with response:[" + error_1 + "]");
                          throw error_1;
                      case 4: return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Update my availability per work-type
       * @param availability A Map of the availability by work type
       * @return new availability
       */
      Session.prototype.setAvailability = function (availability) {
          return __awaiter(this, void 0, void 0, function () {
              var response;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          return [4 /*yield*/, this._connection.setAvailability(this._sessionIdentifier, availability)];
                      case 1:
                          response = _a.sent();
                          // Now we need to update the local availability Map with the returned values
                          response.currentAvailibilty.forEach(function (value, key) {
                              _this._availability.set(key, value);
                          });
                          this._isCustomAvailabilityEnabled = false;
                          return [2 /*return*/, this._availability];
                  }
              });
          });
      };
      Session.prototype.setActivityStatus = function (status) {
          return __awaiter(this, void 0, void 0, function () {
              var res;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this._connection.setActivityStatus(this._sessionIdentifier, status)];
                      case 1:
                          res = _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      Session.prototype.requestAssignment = function () {
          return __awaiter(this, void 0, void 0, function () {
              var res;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this._connection.requestAssignment(this._sessionIdentifier, this._clientIdentifier, true)];
                      case 1:
                          res = _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Update my custom availability per work-type
       * @param customAvailabilityStateId A string representing the state id of the custom availability to be set
       * @return new custom availability state id
       */
      Session.prototype.setCustomAvailability = function (customAvailabilityStateId) {
          return __awaiter(this, void 0, void 0, function () {
              var response;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          return [4 /*yield*/, this._connection.setCustomAvailability(this._sessionIdentifier, customAvailabilityStateId)];
                      case 1:
                          response = _a.sent();
                          // Now we need to update the local custom availability state with the returned value
                          this._currentCustomAvailabilityStateId = response.customAvailabilityStateId;
                          this._isCustomAvailabilityEnabled = true;
                          return [2 /*return*/, this._currentCustomAvailabilityStateId];
                  }
              });
          });
      };
      /**
       * Accept a work offer
       * @param offer Work Offer
       * @return The Channel upon which communications (related to this work) can take place
       */
      Session.prototype.acceptOffer = function (offer, responseType) {
          if (responseType === void 0) { responseType = exports.OfferResponseType.MANUAL; }
          return __awaiter(this, void 0, void 0, function () {
              var channel;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          if (offer === null) {
                              throw new Error('Offer must contain a value');
                          }
                          return [4 /*yield*/, this._connection.respondToOffer(this._sessionIdentifier, offer, exports.OfferActionType.ACCEPT, responseType)];
                      case 1:
                          channel = _a.sent();
                          // Really clunky, but we are going to inject the Session reference into the channel
                          // so that the channel knows which Session it is part of
                          // TODO re-visit
                          channel = Channel.convert(channel);
                          channel.connection(this._connection);
                          channel.sessionToken = this._sessionIdentifier;
                          channel.recordMyParticipation(this._clientIdentifier);
                          // Copy over values from offer into Channel
                          channel.context = offer.context;
                          channel.externalIdString = offer.externalIdString;
                          channel.workTypeCode = offer.workTypeCode;
                          channel.contactInfo = new ContactInfo(offer.context);
                          channel.fusionChannelId = offer.fusionChannelId;
                          channel.conversationId = offer.conversationId;
                          // Register listener
                          channel.registerStateListener(function (channelId, stateName) {
                              _this.channelStateListener(channelId, stateName);
                          });
                          // Add the new channel to our list
                          this.addChannel(channel);
                          return [2 /*return*/, channel];
                  }
              });
          });
      };
      /**
       * Call monitor agent endpoint and return interaction object.
       * @param interactionID engagementIdString
       * @return Channel containing Supervisor in participant list
       */
      Session.prototype.monitor = function (interactionID) {
          return __awaiter(this, void 0, void 0, function () {
              var channel;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          if (!interactionID || interactionID === '') {
                              throw new Error('Empty or no interactionID provided');
                          }
                          return [4 /*yield*/, this._connection.monitor(this._sessionIdentifier, interactionID)];
                      case 1:
                          channel = _a.sent();
                          // Really clunky, but we are going to inject the Session reference into the channel
                          // so that the channel knows which Session it is part of
                          channel = Channel.convert(channel);
                          channel.connection(this._connection);
                          channel.sessionToken = this._sessionIdentifier;
                          channel.recordMyParticipation(this._clientIdentifier);
                          channel.isSupervisor = true;
                          // Register listener
                          channel.registerStateListener(function (channelId, stateName) {
                              _this.channelStateListener(channelId, stateName);
                          });
                          // Add the new channel to our list
                          this.addChannel(channel);
                          channel.changeParticipantRoleType(exports.ParticipationRoleType.MONITOR);
                          return [2 /*return*/, channel];
                  }
              });
          });
      };
      /**
       * Reject a work invitation
       * @param offer Work Offer
       * @returns {Promise}
       *
       */
      Session.prototype.rejectOffer = function (offer, responseType) {
          if (responseType === void 0) { responseType = exports.OfferResponseType.MANUAL; }
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          if (offer === null) {
                              throw new Error('Offer must contain a value');
                          }
                          return [4 /*yield*/, this._connection.respondToOffer(this._sessionIdentifier, offer, exports.OfferActionType.DECLINE, responseType)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Timeout a work invitation
       * Called when no action was performed on the offer - it timed out
       * @param offer Work Offer
       * @returns {Promise}
       *
       */
      Session.prototype.timeoutOffer = function (offer) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          this.checkConnectionObject();
                          if (offer === null) {
                              throw new Error('Offer must contain a value');
                          }
                          return [4 /*yield*/, this._connection.respondToOffer(this._sessionIdentifier, offer, exports.OfferActionType.DECLINE, exports.OfferResponseType.AUTO)];
                      case 1:
                          _a.sent();
                          return [2 /*return*/];
                  }
              });
          });
      };
      /**
       * Get the list of Channels that are associated with
       * this Session
       * @returns The list of Channels associated with this Session
       */
      Session.prototype.getChannels = function () {
          return this._channels;
      };
      /**
       * Allow the caller to register interest in a specific event
       * @param event The MercuryEvent you are interested in
       * @param callback Your listener function to call
       */
      Session.prototype.on = function (event, callback) {
          this.checkConnectionObject();
          Logger.log("Session: Registering interest in " + event);
          this._connection.on(event, callback);
      };
      /**
       * Allow the caller to unsubscribe from a specific event
       * @param event MercuryEvent
       * @param callback
       */
      Session.prototype.unsubscribe = function (event, callback) {
          this.checkConnectionObject();
          Logger.log("Session: unsubscribing from " + event);
          this._connection.unsubscribe(event, callback);
      };
      /**
       * Add a new channel to the session
       * @param channel
       */
      Session.prototype.addChannel = function (channel) {
          // remove the old channel if it exists
          // tslint:disable-next-line: no-increment-decrement
          for (var i = 0; i < this._channels.length; i++) {
              if (this._channels[i].identifier === channel.identifier) {
                  this._channels.splice(i, 1);
              }
          }
          // Add the full channel
          this._channels.push(channel);
      };
      Session.prototype.checkConnectionObject = function () {
          if (!this._connection) {
              // The connection has been removed - post 'end'
              throw new Error("Invalid call attempted after 'end'");
          }
      };
      /**
       * Listen for state changes on the channels
       * @param channelId
       * @param stateName
       */
      Session.prototype.channelStateListener = function (channelId, stateName) {
          var _a;
          if (stateName === 'CLOSED') {
              for (var i = 0; i < ((_a = this._channels) === null || _a === void 0 ? void 0 : _a.length); i++) {
                  if (this._channels[i].identifier === channelId) {
                      this._channels.splice(i, 1);
                      return;
                  }
              }
          }
      };
      Session.prototype.resolveAndCreateConnection = function () {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  // tslint:disable-next-line: no-string-literal
                  if (!Session.iSharedWorkerDisabled && window['SharedWorker']) {
                      this._connection = new ChatCommunicator(this._configuration);
                      Logger.log('Chat Connection changed to Shared Worker thread');
                  }
                  else {
                      this._connection = LegacyHttpConnection.getInstance(this._configuration);
                      Logger.log('Chat Connection changed to Main Thread');
                  }
                  this._resolveRef();
                  return [2 /*return*/];
              });
          });
      };
      Session.iSharedWorkerDisabled = false;
      return Session;
  }());

  /* Copyright (c) 2021, Oracle. All rights reserved. */
  /*
     Object representing a specific custom availability state
     
     Example:
     {
      "stateId": "729ad2c4-62ec-4cee-9749-d1792e28d159",
      "state": "Chat and SR",
      "baseState": "Available",
      "channels": [
        "CHAT",
        "SVC_SERVICE_REQUESTS"
      ]
    }
   */
  var CustomAvailabilityState = /** @class */ (function () {
      function CustomAvailabilityState() {
      }
      return CustomAvailabilityState;
  }());

  var AttachmentErrorType = /** @class */ (function () {
      function AttachmentErrorType() {
      }
      return AttachmentErrorType;
  }());

  var ChannelDestination = /** @class */ (function () {
      function ChannelDestination() {
      }
      return ChannelDestination;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (DisconnectType) {
      /** The participant was not responding */
      DisconnectType["IDLE_TIMEOUT"] = "IDLE_TIMEOUT";
      DisconnectType["NONE"] = "NONE";
      /**  The (Agent) participant concluded the channel */
      DisconnectType["AGENT_CONCLUDED"] = "AGENT_CONCLUDED";
      /**  The participant is being disconnected because no agents are available to join the channel */
      DisconnectType["NO_AGENTS_AVAILABLE"] = "NO_AGENTS_AVAILABLE";
      /**  The participant is being disconnected because the channel is being moved back to the queue */
      DisconnectType["TRANSFERRED_TO_QUEUE"] = "TRANSFERRED_TO_QUEUE";
      /**  The participant closed the channel */
      DisconnectType["PARTICIPANT_LEFT"] = "PARTICIPANT_LEFT";
      /**  The participant concluded the channel */
      DisconnectType["END_USER_CONCLUDED"] = "END_USER_CONCLUDED";
  })(exports.DisconnectType || (exports.DisconnectType = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  (function (PreferenceCategory) {
      /** Chat specific preferences */
      PreferenceCategory["CHAT_CONFIGURATION"] = "CHAT_CONFIGURATION";
      PreferenceCategory["OMNICHANNEL_NOTIFICATION"] = "OMNICHANNEL_NOTIFICATION";
      PreferenceCategory["OMNICHANNEL_GENERAL"] = "OMNICHANNEL_GENERAL";
      PreferenceCategory["OMNICHANNEL_RETENTION"] = "OMNICHANNEL_RETENTION";
      PreferenceCategory["ROUTING_CONFIGURATION"] = "ROUTING_CONFIGURATION";
      PreferenceCategory["COBROWSE_CONFIGURATION"] = "COBROWSE_CONFIGURATION";
  })(exports.PreferenceCategory || (exports.PreferenceCategory = {}));

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
    "locale": "en",
    "timezone": {
      "timezone": "UTC",
      "isoStrFormat": "0",
      "displayName": "Coordinated Universal Time",
      "dst": "false"
    },
    "dateFormatPattern": "M/d/yy",
    "timeFormatPattern": "h:mm a",
    "numberFormatPattern": "#,##0.###",
    "groupingSeparator": ",",
    "decimalSeparator": ".",
    "currencyCode": "USD",
    "FND_USER_PHOTO_ENABLED": "Y",
    "territory": "US"
  }
  */
  var UserPreferences = /** @class */ (function () {
      function UserPreferences() {
      }
      return UserPreferences;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
    "timezone": "UTC",
    "isoStrFormat": "0",
    "displayName": "Coordinated Universal Time",
    "dst": "false"
  }
  */
  var UserPrefTimezone = /** @class */ (function () {
      function UserPrefTimezone() {
      }
      return UserPrefTimezone;
  }());

  /* Copyright (c) 2021, Oracle. All rights reserved. */
  /**
   * Object representing a work type and its characteristics
   */
  var WorkTypeAvailabilityEntry = /** @class */ (function () {
      function WorkTypeAvailabilityEntry() {
      }
      return WorkTypeAvailabilityEntry;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */
  /*
  {
          level: "TENANT",
          tenant: "OSVC$1234$4567",
          group: null,
          user: null,
          preferences: {
            EC_ABSENT_INTERVAL: {
              key: "EC_ABSENT_INTERVAL",
              value: "10",
              createdAt: 100,
              createdBy: "createdBy",
              updatedAt: 200,
              updatedBy: "updatedBy"
            },
            EC_AGENT_ABSENT_RETRY_COUNT: {
              key: "EC_AGENT_ABSENT_RETRY_COUNT",
              value: "10",
              createdAt: 100,
              createdBy: "createdBy",
              updatedAt: 200,
              updatedBy: "updatedBy"
            }
          }
        }
  */
  /**
   * Functionality to fetch and manage the preferences
   */
  var Preferences = /** @class */ (function () {
      function Preferences() {
      }
      Preferences.fetch = function (identityToken, endpoint, category) {
          return __awaiter(this, void 0, void 0, function () {
              var _this = this;
              return __generator(this, function (_a) {
                  // tslint:disable-next-line: typedef
                  return [2 /*return*/, new Promise(function (resolve, reject) {
                          if (identityToken == null || identityToken === '') {
                              reject('identityToken must contain a value');
                              return;
                          }
                          // ======================================
                          // the endpoint should contain the tenant
                          // 'https://<HOST>/<NAMESPACE>/<TENANT>'
                          // ======================================
                          // First clean up the endpoint - remove any trailing '/'
                          endpoint = endpoint.trim();
                          if (endpoint.endsWith('/')) {
                              endpoint = endpoint.slice(0, -1);
                          }
                          // Extract the url without the tenant
                          var urlArr = endpoint.split('/');
                          urlArr.pop();
                          var reducedEndPoint = urlArr.join('/');
                          var xhr = new XMLHttpRequest();
                          xhr.open('GET', reducedEndPoint + "/preferences/tenant/v1/group/" + category);
                          xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
                          xhr.setRequestHeader('Authorization', "Bearer " + identityToken);
                          xhr.setRequestHeader('baseURL', endpoint);
                          xhr.onerror = function (event) {
                              Logger.log("Failed to fetch Preferences.  Connection error", event);
                              reject(event);
                          };
                          xhr.onload = function () {
                              if (xhr.status === 200) {
                                  Logger.log('Successfully fetched preferences');
                                  var responseObj = JSON.parse(xhr.responseText);
                                  var preferenceMap = _this.convertToMap(responseObj);
                                  resolve(preferenceMap);
                              }
                              else {
                                  reject("Request failed.  Returned status of " + xhr.status);
                              }
                          };
                          xhr.send();
                      })];
              });
          });
      };
      /**
       * Convert the object/attribute format to a 'normal' Map object
       * @param rawPreferences
       */
      Preferences.convertToMap = function (rawPreferences) {
          var preferenceMap = new Map();
          var preferences = rawPreferences.preferences;
          for (var attribute in preferences) {
              if (preferences.hasOwnProperty(attribute)) {
                  var element = preferences[attribute];
                  preferenceMap.set(element.key, element.value);
              }
          }
          return preferenceMap;
      };
      return Preferences;
  }());

  /* Copyright (c) 2022, Oracle. All rights reserved. */

  exports.AgentChannelDestination = AgentChannelDestination;
  exports.Channel = Channel;
  exports.ChannelContextItem = ChannelContextItem;
  exports.Session = Session;
  exports.HumanResource = HumanResource;
  exports.MercuryError = MercuryError;
  exports.Participant = Participant;
  exports.QueueChannelDestination = QueueChannelDestination;
  exports.Resource = Resource;
  exports.SetAvailabilityResponse = SetAvailabilityResponse;
  exports.CustomAvailability = CustomAvailability;
  exports.CustomAvailabilityState = CustomAvailabilityState;
  exports.SetCustomAvailabilityResponse = SetCustomAvailabilityResponse;
  exports.AttachmentErrorType = AttachmentErrorType;
  exports.ChannelDestination = ChannelDestination;
  exports.FileDetails = FileDetails;
  exports.RoleChange = RoleChange;
  exports.UserPreferences = UserPreferences;
  exports.UserPrefTimezone = UserPrefTimezone;
  exports.WorkTypeAvailabilityEntry = WorkTypeAvailabilityEntry;
  exports.ActivityChange = ActivityChange;
  exports.AvailabilityChange = AvailabilityChange;
  exports.ChannelClose = ChannelClose;
  exports.ContextUpdate = ContextUpdate;
  exports.MemberDisconnect = MemberDisconnect;
  exports.MemberUpdate = MemberUpdate;
  exports.MercuryOffer = MercuryOffer;
  exports.Message = Message;
  exports.MessageFailed = MessageFailed;
  exports.OfferCancellation = OfferCancellation;
  exports.OfferStatus = OfferStatus;
  exports.ParticipantAdded = ParticipantAdded;
  exports.UploadCompleted = UploadCompleted;
  exports.UploadStatus = UploadStatus;
  exports.ChatEngagementUpdateNotification = ChatEngagementUpdateNotification;
  exports.Preferences = Preferences;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=oracle-mercury-client.umd.js.map
