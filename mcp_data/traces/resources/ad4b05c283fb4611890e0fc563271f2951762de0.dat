(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ojs/ojlogger'), require('ojL10n!./resources/nls/mca-common-strings'), require('vb/helpers/rest'), require('ojs/ojtranslation'), require('oracle-mercury-client'), require('engage-mercury-adapter')) :
	typeof define === 'function' && define.amd ? define(['exports', 'ojs/ojlogger', 'ojL10n!./resources/nls/mca-common-strings', 'vb/helpers/rest', 'ojs/ojtranslation', 'oracle-mercury-client', 'engage-mercury-adapter'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mcaAdfMainPack = {}, global.svcMcaPresenceDependencies.logger, global.svcMcaPresenceDependencies.commonStrings, global.svcMcaPresenceDependencies.restHelper, global.svcMcaPresenceDependencies.translation, global.svcMcaPresenceDependencies.mercuryClient, global.svcMcaPresenceDependencies.engageAdapter));
})(this, (function (exports, require$$0, require$$2, require$$5, require$$8, require$$9, require$$0$1) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var mcaAdfMain = {};

	var knockoutLatest = {exports: {}};

	/*!
	 * Knockout JavaScript library v3.5.1
	 * (c) The Knockout.js team - http://knockoutjs.com/
	 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
	 */

	(function (module, exports) {
		(function() {(function(n){var A=this||(0, eval)("this"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||"undefined"===typeof jQuery||(v=jQuery);(function(n){n(module.exports||exports);})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b();},c));}}function Y(b,c){var d;return function(){clearTimeout(d);
		d=a.a.setTimeout(b,c);}}function Z(a,c){c&&"change"!==c?"beforeChange"===c?this.pc(a):this.gb(a,c):this.qc(a);}function aa(a,c){null!==c&&c.s&&c.s();}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd());}var a="undefined"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c;};a.L=function(a,c,d){a[c]=d;};a.version="3.5.1";a.b("version",
		a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c]);}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e);});b[c]=l.join(" ");}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h="function"===typeof Symbol,m={},k={};m[R&&/Firefox\/2/i.test(R.userAgent)?
		"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];m.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a;});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),q=/\S+/g,t;return {Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
		D:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a);},A:"function"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return -1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift();},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b);});return c},Mb:function(a,
		b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1);},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=
		b.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild);},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k);}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d]);},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],
		l=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k]);}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d);}}return a},Zc:function(a,b){7>p?a.setAttribute("selected",b):a.selected=b;},Db:function(a){return null===a||a===n?"":a.trim?
		a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ud:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return !0;if(11===a.nodeType)return !1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return !!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return !!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&
		a.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0);},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var k=function(a){e.call(b,a);},f="on"+c;b.attachEvent(f,
		k);a.a.K.za(b,function(){b.detachEvent(f,k);});}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else t||(t="function"==typeof v(b).on?"on":"bind"),v(b)[t](c,e);},Fb:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.R(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof w.createEvent)if("function"==
		typeof b.dispatchEvent)d=w.createEvent(k[c]||"HTMLEvents"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c);},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&("object"===typeof b.classList?
		(l=b.classList[d?"add":"remove"],a.a.D(c.match(q),function(a){l.call(b.classList,a);})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d));},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d="";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b);},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>'"]/g,function(a){return "&#"+a.charCodeAt(0)+";"});a.mergeAttributes(w.createElement("<input name='"+
		c+"'/>"),!1);}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom));},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b;}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName("input")).concat(a.a.la(b.getElementsByTagName("textarea"))),
		e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return "string"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
		return H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if("object"==typeof c&&"form"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement("form");p.style.display="none";p.action=f;p.method="post";for(var q in d)c=w.createElement("input"),c.type="hidden",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement("input");
		c.type="hidden";c.name=a;c.value=b;p.appendChild(c);});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p);},0);}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.D);a.b("utils.arrayFirst",a.a.Lb);a.b("utils.arrayFilter",a.a.jb);a.b("utils.arrayGetDistinctValues",a.a.wc);a.b("utils.arrayIndexOf",a.a.A);a.b("utils.arrayMap",a.a.Mb);a.b("utils.arrayPushAll",a.a.Nb);a.b("utils.arrayRemoveItem",a.a.Pa);a.b("utils.cloneNodes",a.a.Ca);a.b("utils.createSymbolOrString",
		a.a.Da);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Jc);a.b("utils.getFormFields",a.a.Lc);a.b("utils.objectMap",a.a.Ga);a.b("utils.peekObservable",a.a.bc);a.b("utils.postJson",a.a.Od);a.b("utils.parseJson",a.a.Nd);a.b("utils.registerEventHandler",a.a.B);a.b("utils.stringifyJson",a.a.hc);a.b("utils.range",a.a.Pd);a.b("utils.toggleDomNodeCssClass",a.a.Eb);a.b("utils.triggerEvent",a.a.Fb);a.b("utils.unwrapObservable",a.a.f);a.b("utils.objectForEach",a.a.P);a.b("utils.addOrRemoveItem",
		a.a.Na);a.b("utils.setTextContent",a.a.Bb);a.b("unwrap",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||"null"===f||!d[f]){if(!e)return n;f=a[c]="ko"+b++;d[f]=
		{};}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return {get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c);},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b("utils.domData",a.a.g);a.b("utils.domData.clear",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);
		d===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0);}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return {za:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c);},yb:function(c,
		d){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n));},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName("*")));});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b);},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a]);}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b("cleanNode",a.oa);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.K);a.b("utils.domNodeDisposal.addDisposeCallback",
		a.a.K.za);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.K.yb);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else {if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;
		l.parentNode&&l.parentNode.removeChild(l);}}else {(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement("div"),t;t=(p=p.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/))&&f[p[1]]||b;p=t[0];t="ignored<div>"+t[1]+c+t[2]+"</div>";"function"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes);}return e};a.a.Md=function(b,c){var d=a.a.ua(b,
		c);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e]);};})();a.b("utils.parseHtmlFragment",a.a.ua);a.b("utils.setHtml",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f});}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],
		e);}var c={};return {Xb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return "\x3c!--[ko_memo:"+b+"]--\x3e"},bd:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete c[a];}},cd:function(c,e){var f=
		[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue="";m.parentNode&&m.parentNode.removeChild(m);}},Uc:function(a){return (a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.aa);a.b("memoization.memoize",a.aa.Xb);a.b("memoization.unmemoize",a.aa.bd);a.b("memoization.parseMemoText",a.aa.Uc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=
		++c){h=f;a.a.Gc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=f;}try{d();}catch(p){a.a.Gc(p);}}}function c(){b();h=f=e.length=0;}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo");}}(c):d=w&&"onreadystatechange"in w.createElement("script")?function(a){var b=w.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);
		b=null;a();};w.documentElement.appendChild(b);}:function(a){setTimeout(a,0);};return {scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null);},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b("tasks",a.na);a.b("tasks.schedule",a.na.zb);a.b("tasks.runEarly",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e);},
		c);}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f="function"==typeof e?e:"notifyWhenChangesStop"==e?Y:X;a.ub(function(a){return f(a,d,c)});},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,"dirty");}finally{f=
		!1;}}}}));},notify:function(a,c){a.equalityComparer="always"==c?null:K;}};var W={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,"dispose",this.s);a.L(this,"disposeWhenNodeIsRemoved",this.l);};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null);};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this));};
		a.T=function(){a.a.Ab(this,D);D.qb(this);};var D={qb:function(a){a.U={change:[]};a.sc=1;},subscribe:function(b,c,d){var e=this;d=d||"change";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d);});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||"change";"change"===c&&this.Gb();if(this.Wa(c)){var d="change"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b);}finally{a.u.end();}}},ob:function(){return this.sc},
		Dd:function(a){return this.ob()!==a},Gb:function(){++this.sc;},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h);});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k();};c.pc=function(a){e||(g=a,c.gb(a,"beforeChange"));};c.rc=function(){m=!0;};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0);};},Wa:function(a){return this.U[a]&&this.U[a].length},
		Bd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){"dirty"!==a&&(c+=b.length);});return c},sb:function(a,c){return !this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return "[object Object]"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];"function"==typeof f&&(c=f(c,e)||c);});return c}};a.L(D,"init",D.qb);a.L(D,"subscribe",D.subscribe);a.L(D,"extend",D.extend);a.L(D,"getSubscriptionsCount",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,
		Function.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&"function"==typeof a.subscribe&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.T);a.b("isSubscribable",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a;}function c(){e=d.pop();}var d=[],e,f=0;return {xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error("Only subscribable things can act as dependencies");e.od.call(e.pd,b,b.fd||(b.fd=++f));}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c();}},qa:function(){if(e)return e.o.qa()},
		Va:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b("computedContext",a.S);a.b("computedContext.getDependenciesCount",a.S.qa);a.b("computedContext.getDependencies",a.S.Va);a.b("computedContext.isInitial",a.S.Ya);a.b("computedContext.registerDependency",a.S.cc);a.b("ignoreDependencies",a.Yd=a.u.G);var I=a.a.Da("_latestValue");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;
		a.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],"spectate");this.notifySubscribers(this[I]);},ya:function(){this.notifySubscribers(this[I],"beforeChange");}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma="__ko_proto__";F[G]=a.ta;a.O=function(b){if((b="function"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");
		return !!b};a.Za=function(b){return "function"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b("observable",a.ta);a.b("isObservable",a.O);a.b("isWriteableObservable",a.Za);a.b("isWritableObservable",a.Za);a.b("observable.fn",F);a.L(F,"peek",F.v);a.L(F,"valueHasMutated",F.xa);a.L(F,"valueWillMutate",F.ya);a.Ha=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.ta(b);a.a.Ab(b,
		a.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e="function"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error("Array modified during remove; cannot remove item");d.push(g);c.splice(f,1);f--;}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=
		a.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d="function"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0);}this.xa();},destroyAll:function(b){return b===n?this.destroy(function(){return !0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa());},sorted:function(a){var c=this().slice(0);
		return a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D("pop push reverse shift sort splice unshift".split(" "),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d};});a.a.D(["slice"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)};});a.Pc=function(b){return a.O(b)&&"function"==typeof b.remove&&"function"==
		typeof b.push};a.b("observableArray",a.Ha);a.b("isObservableArray",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa("arrayChange")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f;}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,"arrayChange");}}e?c():(e=!0,h=b.subscribe(function(){++m;},null,"spectate"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c));}b.Ob={};c&&"object"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,
		k,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);"arrayChange"===a&&d();};b.hb=function(a){p&&p.call(b,a);"arrayChange"!==a||b.Wa("arrayChange")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n);};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case "push":h=p;case "unshift":for(c=0;c<g;c++)l("added",d[c],h+c);break;case "pop":h=p-1;case "shift":p&&l("deleted",b[h],h);break;case "splice":c=Math.min(Math.max(0,0>d[0]?p+d[0]:
		d[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l("deleted",b[c],c)),c<g&&U.push(l("added",d[n],c));a.a.Kc(L,U);break;default:return}f=k;}};}};var r=a.a.Da("_state");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}g.ra||
		a.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc="function"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):
		d.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s();});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da;});return b},Vb:function(b){if(!this[r].V)return !1;var c=this.Va();return -1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&
		c===this)throw Error("A 'pure' computed must not be called recursively");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob();},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return !0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1);},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc();},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,"dirty"),d=a.subscribe(this.Rd,
		this);return {da:a,s:function(){c.s();d.s();}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0);},c)):b.Ia?b.Ia(!0):b.ha(!0);},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b);}finally{c.rb=!1;}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,
		od:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,"beforeChange"),c.X=f,this.notifySubscribers(c.X,"spectate"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,"awake");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1;}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},
		ub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a);};},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s();});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n);}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&"change"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=
		0,c.ha()&&c.Gb();else {var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a;});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m;});c.Xa()&&c.ha()&&c.Gb();}d.ra||c.notifySubscribers(d.X,"awake");}},hb:function(b){var c=this[r];c.ra||"change"!=b||this.Wa("change")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s());}),c.J=!0,this.notifySubscribers(n,"asleep"));},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){"change"!=
		a&&"beforeChange"!=a||this.v();}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return "function"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b("computed",a.o);a.b("dependentObservable",a.o);a.b("isComputed",a.Oc);a.b("isPureComputed",a.Fd);a.b("computed.fn",C);a.L(C,"peek",C.v);a.L(C,"dispose",C.s);a.L(C,"isActive",C.ja);a.L(C,"getDependenciesCount",C.qa);a.L(C,"getDependencies",C.Va);a.xb=function(b,c){if("function"===typeof b)return a.o(b,
		c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b("pureComputed",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var l=g.get(d);h[c]=l!==
		n?l:b(d,f,g);}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON");}else for(c in a)b(c);}function d(){this.keys=[];this.values=[];}a.ad=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,
		b);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c));},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}};})();a.b("toJS",a.ad);a.b("toJSON",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:"always"}),h=e.subscribe(function(a){a&&(h.s(),c(a));});e.notifySubscribers(e.v());return h}return "function"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b("when",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case "option":return !0===b.__ko__hasDomDataOptionValue__?
		a.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case "option":"string"===typeof c?(a.a.g.set(b,a.c.options.$b,n),"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===
		typeof c?c:"");break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||""===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e;},0);break;default:if(null===c||c===n)c="";b.value=c;}}};})();a.b("selectExtensions",a.w);a.b("selectExtensions.readValue",a.w.M);a.b("selectExtensions.writeValue",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,
		-1));b+="\n,";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join("")}:{unknown:p||q.join("")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B="/"):40===u||123===u||91===u?++h:
		41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B);}if(0<h)throw Error("Unbalanced parentheses, braces, or brackets");}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|`(?:\\\\.|[^`])*`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*\n|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,\"'`{}()/:[\\]]*[^\\s,\"'`{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},
		h={};return {Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?"Object("+k[1]+")"+k[2]:f),k=f;k&&q.push("'"+("string"==typeof h[b]?h[b]:b)+"':function(_z){"+f+"=_z}");}g&&(e="function(){return "+e+" }");p.push("'"+b+"':"+e);}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B="string"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,
		a.value);});q.length&&l("_ko_property_writers","{"+q.join(",")+" }");return p.join(",")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return !0;return !1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e);}}}();a.b("expressionRewriting",a.m);a.b("expressionRewriting.bindingRewriteValidators",a.m.Ra);a.b("expressionRewriting.parseObjectLiteral",a.m.ac);a.b("expressionRewriting.preProcessBindings",a.m.vb);a.b("expressionRewriting._twoWayBindings",
		a.m.wa);a.b("jsonExpressionRewriting",a.m);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++;}if(!e)throw Error("Cannot find closing comment tag to match: "+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?
		0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&"\x3c!--test--\x3e"===w.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,m={ul:!0,ol:!0},k="__ko_matchedEndComment__";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d]);}else a.a.Tb(c);},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=
		c.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e);}else a.a.va(c,d);},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c);},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d);},firstChild:function(a){if(b(a))return !a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error("Found invalid end comment, as the first child of "+
		a);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error("Found end comment without a matching opening comment, as child of "+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return (a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=
		g:h=[k];}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g]);}while(f=f.nextSibling)}}}};})();a.b("virtualElements",a.h);a.b("virtualElements.allowedBindings",a.h.ea);a.b("virtualElements.emptyNode",a.h.Ea);a.b("virtualElements.insertAfter",a.h.Wb);a.b("virtualElements.prepend",a.h.Vc);a.b("virtualElements.setDomNodeChildren",a.h.va);(function(){a.ga=function(){this.nd={};};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=
		b.getAttribute("data-bind")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return !1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.h.Vd(b);default:return null}},
		parseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var m,k="with($context){with($data||{}){return{"+a.m.vb(b,e)+"}}}";m=new Function("$context","$element",k);h=f[g]=m;}return h(c,d)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.ga.instance=new a.ga;})();a.b("bindingProvider",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc());}function c(c,d,e){this.node=c;this.yc=
		d;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e);}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return "function"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);
		d=a.h.firstChild(c);}for(;e=d;)d=a.h.nextSibling(e),k(b,e);}a.i.ma(c,a.i.H);}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c);}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
		ca(c);}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0;}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error("You cannot apply bindings multiple times to the same element.");f.hd=!0;}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&"function"!==typeof c)g=c;else {var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]();}return g},null,{l:b});g&&m.ja()||(m=null);}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():
		g,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0, g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]));}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0, g[a.i.pa])();c&&a.h.firstChild(b)&&c(b);}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error("The binding '"+
		f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f;}}),"function"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x);},null,{l:b});}catch(k){throw k.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+k.message,
		k;}});}f=u===n;return {shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da("_subscribable"),x=a.a.Da("_ancestorBindingInfo"),B=a.a.Da("_dataDependency");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=
		b,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p="function"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n);};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&"object"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f="function"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b;},e)}return new a.fa(b,
		this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a);},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,"function"==typeof b?b(c):b);},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node);};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc();};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=
		null,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc());};a.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error("descendantsComplete event not supported for bindings on this node");
		},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e;})}};a.Td=function(b){return (b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b);};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");
		}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");k(q(a,c),b);};a.Dc=function(b){return !b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return (b=a.Dc(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("bindingEvent",a.i);a.b("bindingEvent.subscribe",a.i.subscribe);a.b("bindingEvent.startPossiblyAsyncContentBinding",a.i.Cb);a.b("applyBindings",a.vc);a.b("applyBindingsToDescendants",a.Oa);
		a.b("applyBindingAccessorsToNode",a.ib);a.b("applyBindingsToNode",a.ld);a.b("contextFor",a.Dc);a.b("dataFor",a.Ec);})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b);});}),l=!0);}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,
		c);}):b(null,null);});}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l);}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,l);}else f(null);}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition);}):
		a.na.zb(function(){e(f.definition);}):c(d,e);},Bc:function(a){delete g[a];},oc:e};a.j.loaders=[];a.b("components",a.j);a.b("components.get",a.j.get);a.b("components.clearCachedDefinition",a.j.Bc);})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h);}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc("loadTemplate",[b,c],function(a){h.template=a;g();});}):g();d?f(c,d,function(c){a.j.oc("loadViewModel",[b,c],function(a){h[m]=a;g();});}):g();}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
		else if("function"===typeof b[m])d(b[m]);else if("instance"in b){var e=b.instance;d(function(){return e});}else "viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b);}function d(b){switch(a.a.R(b)){case "script":return a.a.ua(b.text);case "textarea":return a.a.ua(b.value);case "template":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
		T||A.require?(T||A.require)([b.require],function(a){a&&"object"===typeof a&&a.Xd&&a["default"]&&(a=a["default"]);c(a);}):a("Uses require, but no AMD loader is present"):c(b);}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.j.tb(b))throw Error("Component "+b+" is already registered");h[b]=c;};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];
		a.j.Bc(b);};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null);},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d);});},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var h=w.getElementById(c);h?f(d(h)):b("Cannot find element with ID "+c);}else b("Unknown element type: "+
		c);else b("Unknown template value: "+c);},loadViewModel:function(a,b,d){c(g(a),b,d);}};var m="createViewModel";a.b("components.register",a.j.register);a.b("components.isRegistered",a.j.tb);a.b("components.unregister",a.j.unregister);a.b("components.defaultLoader",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h;})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,
		function(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a);},l:b}):e});Object.prototype.hasOwnProperty.call(g,"$raw")||(g.$raw=f);return g}return {$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
		var m={name:h,params:b(e,f)};c.component=g?function(){return m}:m;}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b();a.j.dd;return c}}(w.createDocumentFragment));})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.Ca(c);a.h.va(d,b);}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,
		b,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;"function"===typeof a&&a.call(l);q&&q.s();p=l=q=null;}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;"string"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error("No component name specified");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error("Unknown component '"+h+"'");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});
		d=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t;}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e);}});},null,{l:e});return {controlsDescendantBindings:!0}}};a.h.ea.component=!0;})();var V={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(":"),g="lookupNamespaceURI"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===
		d||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));"name"===c&&a.a.Yc(b,h?"":d);});}};(function(){a.c.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q);}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,
		d,"checked",f,!0);}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d;}var g=a.xb(function(){if(d.has("checkedValue"))return a.a.f(d.get("checkedValue"));if(q)return d.has("value")?a.a.f(d.get("value")):b.value}),h="checkbox"==b.type,m="radio"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return !0});a.o(e,null,{l:b});a.a.B(b,"click",e);a.o(f,null,{l:b});
		k=n;}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c());}};})();a.c["class"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0);}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&"object"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d);}):a.c["class"].update(b,c);}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0);}};a.c.disable=
		{update:function(b,c){a.c.enable.update(b,function(){return !a.a.f(c())});}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){"string"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p);}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1);}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation());}});});}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);
		if(!d||"number"==typeof d.length)return {foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return {foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=
		!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement;}catch(l){g=f.body;}e=g===b;}f=c();a.m.eb(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1;}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,"focus",f);a.a.B(b,"focusin",f);a.a.B(b,"blur",g);a.a.B(b,"focusout",g);b.__ko_hasfocusLastValue=!1;},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
		d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?"focusin":"focusout"]));}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus="hasfocus";a.c.html={init:function(){return {controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c());}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get("as");var u=h.get("noChildContext");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n};}x=(t=
		"render"==h.get("completeOn"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext("function"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k;}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m;}},null,{l:b});return {controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0;}b("if");b("ifnot",!1,!0);b("with",!0);})();a.c.let={init:function(b,
		c,d,e,f){c=f.extend(c);a.Oa(c,b);return {controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if("select"!==a.a.R(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return {controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return "function"==d?b(a):"string"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=
		0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,"change"]);}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get("valueAllowUnset")&&d.has("value"),p=d.get("optionsIncludeDestroyed");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&("undefined"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has("optionsCaption")&&(k=a.a.f(d.get("optionsCaption")),null!==
		k&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a);};k=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(k=function(b,c){g(0,c);a.u.G(d.get("optionsAfterRender"),null,[c[0],b!==Q?b:n]);});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement("option");c===Q?(a.a.Bb(e,d.get("optionsCaption")),a.w.cb(e,n)):(g=f(c,d.get("optionsValue"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get("optionsText"),g),
		a.a.Bb(e,c));return [e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,"change"]);}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m);}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.w.M(b));});a.m.eb(e,d,"selectedOptions",
		f);}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.D(b.getElementsByTagName("option"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c);});b.scrollTop=e;}if("select"!=a.a.R(b))throw Error("selectedOptions binding applies only to SELECT elements");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,"change",e),g=a.o(f,null,{l:b}));},null,{notifyImmediately:!0});},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||
		{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d="";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else {c=c.replace(/-(\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+"px");}});}};a.c.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.B(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b);}finally{!0!==d&&(a.preventDefault?
		a.preventDefault():a.returnValue=!1);}});}};a.c.text={init:function(){return {controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c());}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\/([^ ]+)$/)))||b(c.match(/Chrome\/([^ ]+)/))||(e=b(c.match(/Version\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||
		(g=b(c.match(/rv:([^ )]+)/)));}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b);},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,"selectionchange",l));a.a.g.set(b,k,c);};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d);}function m(){var d=a.a.f(c());if(null===d||d===n)d="";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value);}function r(){w||(L=b.value,w=a.a.setTimeout(z,
		4));}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,"textInput",d));}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l("keypress",z);11>g&&l("propertychange",function(a){y||"value"!==a.propertyName||A();});8==g&&(l("keyup",z),l("keydown",z));p&&(p(b,A),l("dragend",r));(!g||9<=g)&&l("input",A);5>e&&"textarea"===a.a.R(b)?(l("keydown",r),l("paste",r),l("cut",r)):11>d?l("keydown",r):4>f?(l("DOMAutoComplete",z),l("dragdrop",z),l("drop",z)):h&&"number"===b.type&&l("keydown",r);l("change",
		z);l("blur",z);a.o(m,null,{l:b});}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c("textInput",a);}};})();a.c.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.c.uniqueName.rd;a.a.Yc(b,d);}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has("as")&&(g={as:d.get("as"),noChildContext:d.get("noChildContext")});c=f.createChildContext(c,g);a.Oa(c,b);return {controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f="input"==
		e;if(!f||"checkbox"!=b.type&&"radio"!=b.type){var g=[],h=d.get("valueUpdate"),m=!1,k=null;h&&("string"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,"change"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,"value",f);};!a.a.W||!f||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.A(g,"propertychange")||(a.a.B(b,"propertychange",function(){m=!0;}),a.a.B(b,"focus",function(){m=!1;}),a.a.B(b,"blur",function(){m&&l();}));a.a.D(g,function(c){var d=l;a.a.Ud(c,"after")&&
		(d=function(){k=a.w.M(b);a.a.setTimeout(l,0);},c=c.substring(5));a.a.B(b,c,d);});var p;p=f&&"file"==b.type?function(){var d=a.a.f(c());null===d||d===n||""===d?b.value="":a.u.G(l);}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)"select"===e?(g=d.get("valueAllowUnset"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f);};if("select"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get("valueAllowUnset")?p():l():(a.a.B(b,"change",l),q=a.o(p,null,{l:b}));},
		null,{notifyImmediately:!0});}else a.a.B(b,"change",l),a.o(p,null,{l:b});}else a.ib(b,{checkedValue:c});},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none");}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return !a.a.f(c())});}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}};})("click");
		a.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.ca.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error("Unknown template type: "+b);};a.ca.prototype.renderTemplate=
		function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return !1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0);};a.b("templateEngine",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,
		l)){var p=m[l];if("function"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.m.vb(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,
		d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return {xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d);},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h);})}}}();a.b("__tr_ambtns",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=
		a.a.R(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4;}};a.C.F.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.F[b];var c=arguments[0];"innerHTML"===b?a.a.fc(this.F,c):this.F[b]=c;};var b=a.a.g.Z()+"_";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1]);};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;
		if(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}));}return f}e=arguments[0];this.ab!==n&&this.text("");a.a.g.set(b,c,{lb:e});};a.C.ia=function(a){this.F=a;};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,
		c,{bb:arguments[0]});};a.b("templateSources",a.C);a.b("templateSources.domElement",a.C.F);a.b("templateSources.anonymousTemplate",a.C.ia);})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b);}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c));});c.length=0;if(!e)return;e===f?c.push(e):
		(c.push(e,f),a.a.Ua(c,g));}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b);});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d]);});a.a.Ua(c,g);}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.h.va(b,
		f);n=!0;break;case "replaceNode":a.a.Xc(b,f);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||"$data"]]),"replaceChildren"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():"function"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error("templateEngine must inherit from ko.templateEngine");g=b;};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==
		n)throw Error("Set a template engine before calling renderTemplate");t=t||"replaceChildren";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);"replaceNode"==t&&(m=g,x=d(m));},null,{Sa:function(){return !x||!a.a.Sb(x)},l:x&&"replaceNode"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,"replaceNode");})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H);}
		function r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null;}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+"Index"]=c);}});var d=f(b,a,v);return e(h,"ignoreTargetNode",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];"undefined"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||
		!a.a.f(b._destroy)}));x(b);},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a);},null,"arrayChange");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if("string"==typeof d||"name"in d)a.h.Ea(b);else if("nodes"in d){d=d.nodes||[];if(a.O(d))throw Error('The "nodes" option must be a plain, non-observable array.');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e);}else if(d=a.h.childNodes(b),0<d.length)e=
		a.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error("Anonymous template defined, but no template content was provided");return {controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;"string"==typeof c?c={}:(g="name"in c?c.name:b,"if"in c&&(d=a.a.f(c["if"])),d&&"ifnot"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));"foreach"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,"data"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),
		e=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&"function"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f);}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.h.ea.template=!0;})();a.b("setTemplateEngine",a.gc);a.b("renderTemplate",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===
		m.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g;}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):
		(--q,--l,g.sparse||h.push({status:"retained",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l);},null,{l:b,Sa:function(){return !a.a.kd(k)}});
		return {Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y);}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y);}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa);});}f=f||[];"undefined"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else {if(!k||t&&t._countWaitingForRemove){var E=
		a.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0});}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case "deleted":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case "added":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value);}for(;w<f.length;)p(u++);v._countWaitingForRemove=I;}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,
		h.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement;}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1]);}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);
		q(h.afterAdd,F);};})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1;};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b("nativeTemplateEngine",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();
		this.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=v.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return "{{ko_code ((function() { return "+
		a+" })()) }}"};this.addTemplate=function(a,b){w.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>");};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},v.tmpl.tag.ko_with={open:"with($1) {",close:"} "});};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b("jqueryTmplTemplateEngine",a.$a);})();});})();})(); 
	} (knockoutLatest, knockoutLatest.exports));

	var knockoutLatestExports = knockoutLatest.exports;

	var mcaAdfContainer = {};

	var mcaCommonTypes = {};

	var ojMcaCommon = {};

	var mcaLogger = {};

	var mcaIndexedDbManager = {};

	var hasRequiredMcaIndexedDbManager;

	function requireMcaIndexedDbManager () {
		if (hasRequiredMcaIndexedDbManager) return mcaIndexedDbManager;
		hasRequiredMcaIndexedDbManager = 1;
		var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(mcaIndexedDbManager, "__esModule", { value: true });
		mcaIndexedDbManager.Operation = mcaIndexedDbManager.McaIndexedDbManager = void 0;
		const logger = require$$0;
		const mcaLogger_1 = requireMcaLogger();
		var Operation;
		(function (Operation) {
		    Operation[Operation["GET"] = 0] = "GET";
		    Operation[Operation["PUT"] = 1] = "PUT";
		    Operation[Operation["DELETE"] = 2] = "DELETE";
		    Operation[Operation["DELETE_BY_FILTER"] = 3] = "DELETE_BY_FILTER";
		    Operation[Operation["CLEANUP"] = 4] = "CLEANUP";
		    Operation[Operation["GET_ALL"] = 5] = "GET_ALL";
		    Operation[Operation["CLEAR"] = 6] = "CLEAR";
		})(Operation || (Operation = {}));
		mcaIndexedDbManager.Operation = Operation;
		class McaIndexedDbManager {
		    constructor() {
		        this.init();
		    }
		    static getInstance() {
		        if (!McaIndexedDbManager.instance) {
		            McaIndexedDbManager.instance = new McaIndexedDbManager();
		        }
		        return McaIndexedDbManager.instance;
		    }
		    static doOperation(idbDatabase, dbRequest, dbSchema) {
		        return __awaiter(this, void 0, void 0, function* () {
		            try {
		                const transactionMode = dbRequest.operation === Operation.GET ? 'readonly' : 'readwrite';
		                if (dbRequest.operation === Operation.CLEANUP) {
		                    if (dbRequest.objectStorage) {
		                        const schema = McaIndexedDbManager.getSchemaDetails(dbSchema.name, dbRequest.objectStorage);
		                        if (schema) {
		                            return McaIndexedDbManager.cleanUpStaleDataFromObjectStore(idbDatabase, schema);
		                        }
		                    }
		                    else {
		                        return McaIndexedDbManager.cleanUpStaleData(idbDatabase, dbSchema);
		                    }
		                }
		                const objectStore = idbDatabase
		                    .transaction(dbRequest.objectStorage, transactionMode)
		                    .objectStore(dbRequest.objectStorage);
		                let request;
		                switch (dbRequest.operation) {
		                    case Operation.GET:
		                        request = objectStore.get(dbRequest.data);
		                        break;
		                    case Operation.PUT:
		                        request = objectStore.put(dbRequest.data);
		                        break;
		                    case Operation.DELETE:
		                        request = objectStore.delete(dbRequest.data);
		                        break;
		                    case Operation.GET_ALL:
		                        request = objectStore.getAll();
		                        break;
		                    case Operation.CLEAR:
		                        request = objectStore.clear();
		                        break;
		                    case Operation.DELETE_BY_FILTER:
		                        return McaIndexedDbManager.deleteItemsByFilter(objectStore, dbRequest.filterFunction);
		                    default:
		                        break;
		                }
		                return new Promise((resolve, reject) => {
		                    request.onsuccess = (event) => {
		                        resolve(event.target.result);
		                    };
		                    request.onerror = (err) => {
		                        reject(err);
		                    };
		                });
		            }
		            catch (err) {
		                logger.warn(`${McaIndexedDbManager.PRE} Error adding record in Local DB ${dbRequest.objectStorage}`);
		                logger.warn(err);
		                return Promise.reject(err);
		            }
		        });
		    }
		    static cleanUpStaleData(idbDatabase, dbSchema) {
		        return __awaiter(this, void 0, void 0, function* () {
		            dbSchema.objectStores.forEach((schema) => {
		                this.cleanUpStaleDataFromObjectStore(idbDatabase, schema);
		            });
		        });
		    }
		    static cleanUpStaleDataFromObjectStore(idbDatabase, schema) {
		        return __awaiter(this, void 0, void 0, function* () {
		            if (schema.cleanupFunction) {
		                logger.info(`${McaIndexedDbManager.PRE} clean up stale data for ${schema.name}`);
		                try {
		                    const objectStore = idbDatabase
		                        .transaction(schema.name, 'readwrite')
		                        .objectStore(schema.name);
		                    McaIndexedDbManager.deleteItemsByFilter(objectStore, schema.cleanupFunction);
		                }
		                catch (error) {
		                    logger.warn(`${McaIndexedDbManager.PRE} Error while stale data cleanup for ${schema.name}`, error);
		                }
		            }
		        });
		    }
		    static deleteItemsByFilter(objectStore, filterFunction) {
		        return __awaiter(this, void 0, void 0, function* () {
		            logger.info(`${McaIndexedDbManager.PRE} deleteItemsByFilter`);
		            if (!filterFunction) {
		                logger.warn(`${this.PRE} missing filter function`);
		                return false;
		            }
		            return new Promise((resolve, reject) => {
		                objectStore.openCursor().onsuccess = (event) => {
		                    var _a;
		                    const cursor = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
		                    if (!cursor) {
		                        resolve(true);
		                    }
		                    else {
		                        if (filterFunction(cursor)) {
		                            cursor.delete();
		                        }
		                        cursor.continue();
		                    }
		                };
		                objectStore.openCursor().onerror = (err) => {
		                    reject(err);
		                };
		            });
		        });
		    }
		    static upgradeNeeded(event, dbSchema) {
		        return __awaiter(this, void 0, void 0, function* () {
		            logger.info(`${McaIndexedDbManager.PRE} DB Upgrade Started`);
		            try {
		                const request = event.target;
		                const db = request.result;
		                dbSchema.objectStores.forEach((schema) => {
		                    if (!db.objectStoreNames.contains(schema.name)) {
		                        const objectStore = db.createObjectStore(schema.name, { keyPath: schema.key });
		                        if (schema.indexes && schema.indexes.length > 0) {
		                            schema.indexes.forEach((index) => {
		                                objectStore.createIndex(index.name, index.name, { unique: index.unique });
		                            });
		                        }
		                    }
		                });
		                logger.info(`${McaIndexedDbManager.PRE} DB Upgrade Success for`);
		                return Promise.resolve(db);
		            }
		            catch (err) {
		                logger.warn(`${McaIndexedDbManager.PRE} Error while upgrading DB`);
		                logger.warn(err);
		                return Promise.reject(err);
		            }
		        });
		    }
		    static getSchemaDetails(dbName, objectStoreName) {
		        return McaIndexedDbManager.IDB_DATABASE_SCHEMA.get(dbName).objectStores.find((objectStore) => objectStore.name === objectStoreName);
		    }
		    static getDb(dbName, dbVersion, waitForConfigCompletion) {
		        return __awaiter(this, void 0, void 0, function* () {
		            if (McaIndexedDbManager.dbConfigurationCompleted && !waitForConfigCompletion) {
		                yield McaIndexedDbManager.dbConfigurationCompleted;
		            }
		            const dbSchema = McaIndexedDbManager.IDB_DATABASE_SCHEMA.get(dbName);
		            const dbOpenRequest = window.indexedDB.open(dbName, dbVersion !== null && dbVersion !== void 0 ? dbVersion : dbSchema.version);
		            return new Promise((resolve, reject) => {
		                dbOpenRequest.onsuccess = (event) => __awaiter(this, void 0, void 0, function* () {
		                    var _a;
		                    const db = (_a = event.target) === null || _a === void 0 ? void 0 : _a.result;
		                    resolve(db);
		                });
		                dbOpenRequest.onupgradeneeded = (event) => __awaiter(this, void 0, void 0, function* () {
		                    if (dbSchema) {
		                        try {
		                            yield McaIndexedDbManager.upgradeNeeded(event, dbSchema);
		                        }
		                        catch (err) {
		                            reject(err);
		                        }
		                    }
		                });
		                dbOpenRequest.onerror = (err) => {
		                    reject(err);
		                };
		                dbOpenRequest.onblocked = (err) => {
		                    reject(err);
		                };
		            });
		        });
		    }
		    performIndexDbOperation(dbRequest, dbName = McaIndexedDbManager.OJ_MCA, dbVersion) {
		        return __awaiter(this, void 0, void 0, function* () {
		            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
		                try {
		                    const db = yield McaIndexedDbManager.getDb(dbName, dbVersion);
		                    const dbSchema = McaIndexedDbManager.IDB_DATABASE_SCHEMA.get(dbName);
		                    const response = yield McaIndexedDbManager.doOperation(db, dbRequest, dbSchema);
		                    resolve(response);
		                }
		                catch (err) {
		                    reject(err);
		                }
		            }));
		        });
		    }
		    init() {
		        var _a, _b;
		        return __awaiter(this, void 0, void 0, function* () {
		            let dbConfigurationReadyPromiseRes;
		            try {
		                if (!McaIndexedDbManager.dbConfigurationCompleted) {
		                    McaIndexedDbManager.dbConfigurationCompleted = new Promise((resolve) => {
		                        dbConfigurationReadyPromiseRes = resolve;
		                    });
		                }
		                yield McaIndexedDbManager.getDb(McaIndexedDbManager.OJ_MCA, null, true);
		                dbConfigurationReadyPromiseRes();
		            }
		            catch (error) {
		                // Need to Handle the version error for oj-mca
		                if (((_b = (_a = error.target) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.name) === 'VersionError') {
		                    mcaLogger_1.McaLogger.warn('Version error, deleting the IDB to recreate with the current version.', error);
		                    window.indexedDB.deleteDatabase(McaIndexedDbManager.OJ_MCA);
		                }
		                dbConfigurationReadyPromiseRes();
		                return;
		            }
		            // Cleanup for removing stale data
		            this.performIndexDbOperation({
		                data: null,
		                objectStorage: null,
		                operation: Operation.CLEANUP
		            }, McaIndexedDbManager.OJ_MCA_RW);
		        });
		    }
		}
		mcaIndexedDbManager.McaIndexedDbManager = McaIndexedDbManager;
		McaIndexedDbManager.OJ_MCA = 'oj-mca';
		McaIndexedDbManager.OJ_MCA_RW = 'oj-mca-rw';
		McaIndexedDbManager.OJ_MCA_RW_VERSION = 1;
		McaIndexedDbManager.PRE = '[McaIndexedDbManager] ';
		McaIndexedDbManager.IDB_DATABASE_SCHEMA = new Map([
		    ['oj-mca', {
		            name: 'oj-mca',
		            objectStores: [
		                {
		                    indexes: [{ name: 'sessionId', unique: false }],
		                    key: 'endPoint',
		                    name: 'objects'
		                }
		            ],
		            version: 1
		        }],
		    ['oj-mca-rw', {
		            name: 'oj-mca-rw',
		            objectStores: [
		                {
		                    cleanupFunction: (cursor) => { var _a; return ((Date.now() - ((_a = cursor.value) === null || _a === void 0 ? void 0 : _a.created)) > 60 * 60 * 1000); },
		                    indexes: [{ name: 'transcriptKey', unique: true }],
		                    key: 'transcriptKey',
		                    name: 'transcripts'
		                },
		                {
		                    cleanupFunction: (cursor) => { var _a; return ((Date.now() - ((_a = cursor.value) === null || _a === void 0 ? void 0 : _a.created)) > 30 * 60 * 1000); },
		                    key: 'created',
		                    name: 'logger'
		                }
		            ],
		            version: McaIndexedDbManager.OJ_MCA_RW_VERSION
		        }]
		]);
		
		return mcaIndexedDbManager;
	}

	var hasRequiredMcaLogger;

	function requireMcaLogger () {
		if (hasRequiredMcaLogger) return mcaLogger;
		hasRequiredMcaLogger = 1;
		Object.defineProperty(mcaLogger, "__esModule", { value: true });
		mcaLogger.McaLogger = void 0;
		const logger = require$$0;
		const mca_indexed_db_manager_1 = requireMcaIndexedDbManager();
		const oj_mca_common_1 = requireOjMcaCommon();
		class McaLogger {
		    static setDebugMode(debugMode) {
		        McaLogger.localDebuggingEnabled = localStorage.getItem(oj_mca_common_1.McaCommon.MCA_LOCAL_DEBUG_MODE_KEY) === 'Y';
		        McaLogger.debugModeEnabled = debugMode !== 'N';
		        localStorage.setItem(oj_mca_common_1.McaCommon.MCA_REMOTE_DEBUG_MODE_KEY, debugMode);
		    }
		    static error(message, ...optionalParams) {
		        logger.error(message, optionalParams);
		        McaLogger.storeLogsToIndexedDb(message, 'ERROR', optionalParams);
		    }
		    static info(message, ...optionalParams) {
		        logger.info(message, optionalParams);
		        McaLogger.storeLogsToIndexedDb(message, 'INFO', optionalParams);
		    }
		    static log(message, ...optionalParams) {
		        logger.log(message, optionalParams);
		        McaLogger.storeLogsToIndexedDb(message, 'LOG', optionalParams);
		    }
		    static warn(message, ...optionalParams) {
		        logger.warn(message, optionalParams);
		        McaLogger.storeLogsToIndexedDb(message, 'WARN', optionalParams);
		    }
		    static getMcaIndexedDbManager() {
		        if (!McaLogger.mcaIndexedDbManager) {
		            McaLogger.mcaIndexedDbManager = mca_indexed_db_manager_1.McaIndexedDbManager.getInstance();
		        }
		        return McaLogger.mcaIndexedDbManager;
		    }
		}
		McaLogger.debugModeEnabled = true;
		McaLogger.localDebuggingEnabled = false;
		McaLogger.storeLogsToIndexedDb = (message, level, ...extraData) => {
		    if (level !== 'INFO' || McaLogger.localDebuggingEnabled || McaLogger.debugModeEnabled) {
		        let jsonString = '';
		        const app = 'MCA';
		        try {
		            jsonString = JSON.stringify(extraData);
		        }
		        catch (e) {
		            jsonString = '';
		        }
		        const dbRequest = {
		            data: {
		                app,
		                created: Date.now(),
		                jsonString,
		                level,
		                message,
		                sessionId: oj_mca_common_1.McaCommon.getSessionId(),
		                windowName: window.name
		            },
		            objectStorage: 'logger',
		            operation: mca_indexed_db_manager_1.Operation.PUT,
		        };
		        try {
		            McaLogger.getMcaIndexedDbManager().performIndexDbOperation(dbRequest, mca_indexed_db_manager_1.McaIndexedDbManager.OJ_MCA_RW);
		        }
		        catch (error) {
		            jsonString = '';
		        }
		    }
		};
		mcaLogger.McaLogger = McaLogger;
		
		return mcaLogger;
	}

	var hasRequiredOjMcaCommon;

	function requireOjMcaCommon () {
		if (hasRequiredOjMcaCommon) return ojMcaCommon;
		hasRequiredOjMcaCommon = 1;
		var _a;
		Object.defineProperty(ojMcaCommon, "__esModule", { value: true });
		ojMcaCommon.McaCommon = void 0;
		/*
		 * To change this license header, choose License Headers in Project Properties.
		 * To change this template file, choose Tools | Templates
		 * and open the template in the editor.
		 */
		const mcaLogger_1 = requireMcaLogger();
		const mca = requireMcaCommonTypes();
		const mcaStrings = require$$2;
		class McaCommon {
		    constructor() { }
		    static setAdfEngageSdkUrl(_adfEngageSdkUrl) {
		        this.adfEngageSdkUrl = _adfEngageSdkUrl;
		    }
		    static setApiGroupContacts(_apiGroupContacts) {
		        this.apiGroupContacts = _apiGroupContacts;
		    }
		    static getApiGroupContacts() {
		        if (this.apiGroupContacts) {
		            return this.apiGroupContacts;
		        }
		        else {
		            return mca.ServiceName.contacts;
		        }
		    }
		    static setApiGroupChatAgentInteractions(_apiGroupChatAgentInteractions) {
		        this.apiGroupChatAgentInteractions = _apiGroupChatAgentInteractions;
		    }
		    static getApiGroupChatAgentInteractions() {
		        if (this.apiGroupChatAgentInteractions) {
		            return this.apiGroupChatAgentInteractions;
		        }
		        else {
		            return mca.ServiceName.mcaChatInterations;
		        }
		    }
		    static setApiGroupChatTranscript(_apiGroupChatTranscript) {
		        this.apiGroupChatTranscript = _apiGroupChatTranscript;
		    }
		    static getApiGroupChatTranscript() {
		        if (this.apiGroupChatTranscript) {
		            return this.apiGroupChatTranscript;
		        }
		        else {
		            return mca.ServiceName.mcaChatTranscript;
		        }
		    }
		    static setApiGroupFndStaticLookups(_apiGroupFndStaticLookups) {
		        this.apiGroupFndStaticLookups = _apiGroupFndStaticLookups;
		    }
		    static getApiGroupFndStaticLookups() {
		        if (this.apiGroupFndStaticLookups) {
		            return this.apiGroupFndStaticLookups;
		        }
		        else {
		            return mca.ServiceName.mcafndlookups;
		        }
		    }
		    static setApiGroupMultiChannelAdapterEvents(_apiGroupMultiChannelAdapterEvents) {
		        this.apiGroupMultiChannelAdapterEvents = _apiGroupMultiChannelAdapterEvents;
		    }
		    static getApiGroupMultiChannelAdapterEvents() {
		        if (this.apiGroupMultiChannelAdapterEvents) {
		            return this.apiGroupMultiChannelAdapterEvents;
		        }
		        else {
		            return mca.ServiceName.mcaEvents;
		        }
		    }
		    static setApiGroupWrapUps(_apiGroupWrapUps) {
		        this.apiGroupWrapUps = _apiGroupWrapUps;
		    }
		    static getApiGroupWrapUps() {
		        if (this.apiGroupWrapUps) {
		            return this.apiGroupWrapUps;
		        }
		        else {
		            return mca.ServiceName.wrapUps;
		        }
		    }
		    static setApiGroupResourcePresences(_apiGroupResourcePresences) {
		        this.apiGroupResourcePresences = _apiGroupResourcePresences;
		    }
		    static getApiGroupResourcePresences() {
		        if (this.apiGroupResourcePresences) {
		            return this.apiGroupResourcePresences;
		        }
		        else {
		            return mca.ServiceNameV2.mcaResourcePresences;
		        }
		    }
		    static setUnitTestFlag(flag) {
		        this.unitTest = flag;
		    }
		    static getUnitTestFlag() {
		        return this.unitTest;
		    }
		    static setSessionId(id) {
		        if (!id) {
		            id = 'NOT_AVAILABLE'; // assume this is the local testing scenario
		        }
		        this.sessionId = id;
		    }
		    static getInstance() {
		        if (!McaCommon.instance) {
		            McaCommon.instance = new McaCommon();
		        }
		        return McaCommon.instance;
		    }
		    static getMsiEnabled() {
		        return this.isMsiEnabled;
		    }
		    static setMsiEnabled(enabled) {
		        this.isMsiEnabled = enabled;
		    }
		    static localUuidV4() {
		        const bth = [];
		        for (let ii = 0; ii < 256; ii++) {
		            bth[ii] = (ii + 0x100).toString(16).substr(1);
		        }
		        const uuidBytes = new Array(16);
		        const randomNums = window.crypto.getRandomValues(new Uint32Array(4));
		        let y = 0;
		        for (let i = 0, r = 0; i < 16; i++) {
		            // tslint:disable-next-line: no-bitwise
		            if ((i & 0x03) === 0) {
		                // Replaced on 9-10-20 to fix Fortify Scan
		                // r = Math.random() * 0x100000000;
		                r = randomNums[y];
		                y++;
		            }
		            // tslint:disable-next-line: no-bitwise
		            uuidBytes[i] = (r >>> ((i & 0x03) << 3)) & 0xff;
		        }
		        // tslint:disable-next-line: no-bitwise
		        uuidBytes[6] = (uuidBytes[6] & 0x0f) | 0x40;
		        // tslint:disable-next-line: no-bitwise
		        uuidBytes[8] = (uuidBytes[8] & 0x3f) | 0x80;
		        let j = 0;
		        const uuidString = (bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            '-' +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            '-' +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            '-' +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            '-' +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]] +
		            bth[uuidBytes[j++]]);
		        return uuidString;
		    }
		    /**
		     * Utility method to determine if the value means true
		     * @param value
		     * @return boolean - true is returned if the value means true
		     */
		    static getBoolean(value) {
		        let retVal = false;
		        if (value) {
		            if (typeof value === 'boolean') {
		                retVal = value;
		            }
		            else if (typeof value === 'string') {
		                if (value.toUpperCase().startsWith('Y')) {
		                    retVal = true;
		                }
		                else if (value.toUpperCase().startsWith('T')) {
		                    retVal = true;
		                }
		                else if (value === '1') {
		                    retVal = true;
		                }
		            }
		            else if (typeof value === 'number') {
		                if (value !== 0) {
		                    retVal = true;
		                }
		            }
		        }
		        return retVal;
		    }
		    /**
		     * Checks if a resource exists on the server for the given file path
		     * @returns true if the specified file is found
		     */
		    static doesFileExist(filePath) {
		        mcaLogger_1.McaLogger.info(McaCommon.PRE + 'Checking file exists: ' + filePath);
		        const xhr = new XMLHttpRequest();
		        xhr.open('HEAD', filePath, false);
		        xhr.send();
		        if (xhr.status === 404) {
		            mcaLogger_1.McaLogger.info("File doesn't exist");
		            return false;
		        }
		        else {
		            mcaLogger_1.McaLogger.info('File exists');
		            return true;
		        }
		    }
		    /**
		     * For async functions only.
		     * This Sleeps for numMs number of milliseconds.
		     */
		    static sleep(numMs) {
		        return new Promise((resolve) => {
		            setTimeout(() => {
		                resolve('resolved');
		            }, numMs);
		        });
		    }
		    /**
		     * Retrieves the current User Session Id
		     */
		    static getSessionId() {
		        return this.sessionId;
		    }
		    /**
		     * Retrieves the current User Configuration object
		     */
		    static getUserConfigurations() {
		        return this.userConfigurations;
		    }
		    /**
		     * Sets the current User Configuration object
		     */
		    static setUserConfigurations(config) {
		        if (!config) {
		            this.userConfigurations = { data: 'NOT_AVAILABLE' }; // assume this is the local testing scenario
		        }
		        this.userConfigurations = config;
		    }
		    /**
		     * Gets the VB App Name based upon the URL Pattern /.../webApps/<App Name>/...
		     */
		    static getAppName() {
		        var _b;
		        const WEB_APPS = 'webApps';
		        let appName = null;
		        const currentPath = window.location.pathname;
		        let startingIndex = currentPath.indexOf(WEB_APPS);
		        let offset = WEB_APPS.length;
		        if (startingIndex < 0 && ((_b = window.vbInitConfig) === null || _b === void 0 ? void 0 : _b.APP_NAME)) {
		            startingIndex = currentPath.indexOf(window.vbInitConfig.APP_NAME);
		            offset = window.vbInitConfig.APP_NAME.length;
		        }
		        if (startingIndex > 0) {
		            const newPath = currentPath.substr(startingIndex + offset + 1, currentPath.length);
		            const lastIndex = newPath.indexOf('/');
		            appName = newPath.substr(0, lastIndex);
		        }
		        mcaLogger_1.McaLogger.info(McaCommon.PRE + 'Returning appName: ' + appName);
		        return appName;
		    }
		    /**
		     * Checks the url string parameter to determine if it is a valid URL
		     */
		    static isValidUrl(url) {
		        let retVal = false;
		        if (url && url.trim() !== '') {
		            try {
		                const validUrl = new URL(url);
		                retVal = true;
		            }
		            catch (err) {
		                mcaLogger_1.McaLogger.error(`Error parsing ${url} Error ${err}`, err);
		            }
		        }
		        return retVal;
		    }
		    /**
		     * Returns time field
		     */
		    static relativeTime(date) {
		        const currentDate = new Date();
		        const millis = currentDate.getTime() - date.getTime();
		        const min = Math.floor(millis / 60000);
		        const hours = Math.floor(min / 60);
		        const days = Math.floor(hours / 24);
		        const months = Math.floor(days / 30);
		        const years = Math.floor(days / 365);
		        let result;
		        if (years > 0) {
		            const diffMonths = months - 12 * years;
		            if (years === 1) {
		                result = years + ' Year';
		            }
		            else {
		                result = years + ' Years';
		            }
		            if (diffMonths === 0) {
		                result += ' Ago';
		            }
		            else if (diffMonths === 1) {
		                result += ' ' + diffMonths + ' Month Ago';
		            }
		            else {
		                result += ' ' + diffMonths + ' Months Ago';
		            }
		        }
		        else if (months > 0) {
		            const diffDays = days - 30 * months;
		            if (months === 1) {
		                result = months + ' Month';
		            }
		            else {
		                result = months + ' Months';
		            }
		            if (diffDays === 0) {
		                result += ' Ago';
		            }
		            else if (diffDays === 1) {
		                result += ' ' + diffDays + ' Day Ago';
		            }
		            else {
		                result += ' ' + diffDays + ' Days Ago';
		            }
		        }
		        else if (days > 0) {
		            const diffHours = hours - 24 * days;
		            if (days === 1) {
		                result = days + ' Day';
		            }
		            else {
		                result = days + ' Days';
		            }
		            if (diffHours === 0) {
		                result += ' Ago';
		            }
		            else if (diffHours === 1) {
		                result += ' ' + diffHours + ' Hour Ago';
		            }
		            else {
		                result += ' ' + diffHours + ' Hours Ago';
		            }
		        }
		        else if (hours > 0) {
		            const diffMins = min - 60 * hours;
		            if (hours === 1) {
		                result = hours + ' Hour';
		            }
		            else {
		                result = hours + ' Hours';
		            }
		            if (diffMins === 0) {
		                result += ' Ago';
		            }
		            else if (diffMins === 1) {
		                result += ' ' + diffMins + ' Mins Ago';
		            }
		            else {
		                result += ' ' + diffMins + ' Mins Ago';
		            }
		        }
		        else if (min > 0) {
		            if (min === 1) {
		                result = min + ' Minute Ago';
		            }
		            else {
		                result = min + ' Minutes Ago';
		            }
		        }
		        else {
		            result = 'Just Now';
		        }
		        return result;
		    }
		    static initUefObjPromise() {
		        const windowObj = window;
		        if (!windowObj._uiEventsAPPFrameworkLibInjected) {
		            windowObj._uiEventsAPPFrameworkLibInjected = new Promise((resolveRef, rejectRef) => {
		                windowObj._uiEventsAPPFrameworkResolveRef = resolveRef;
		                windowObj._uiEventsAPPFrameworkRejectRef = rejectRef;
		            });
		        }
		    }
		}
		ojMcaCommon.McaCommon = McaCommon;
		_a = McaCommon;
		McaCommon.mcaCoreStrings = mcaStrings;
		McaCommon.MCA_PREV_WINDOW_NAME = 'MCA_PREV_WINDOW_NAME';
		McaCommon.MCA_LOCAL_DEBUG_MODE_KEY = 'MCA_LOCAL_DEBUG_MODE_ENABLED';
		McaCommon.MCA_REMOTE_DEBUG_MODE_KEY = 'MCA_REMOTE_DEBUG_MODE_ENABLED';
		McaCommon.PRE = '[McaCommon] ';
		McaCommon.unitTest = false;
		McaCommon.sessionId = 'NOT_SET';
		McaCommon.isMsiEnabled = false;
		McaCommon.userConfigurations = {};
		McaCommon.apiGroupContacts = null;
		McaCommon.apiGroupChatAgentInteractions = null;
		McaCommon.apiGroupChatTranscript = null;
		McaCommon.apiGroupFndStaticLookups = null;
		McaCommon.apiGroupMultiChannelAdapterEvents = null;
		McaCommon.apiGroupWrapUps = null;
		McaCommon.apiGroupResourcePresences = null;
		// ADF presence related
		McaCommon.adfEngageSdkUrl = null;
		/**
		 * Retrieves the requirejs config path for the specified namespace.
		 * @return the full path for the specified namespace, null is returned if no path is found
		 */
		McaCommon.getRequirePath = (name) => {
		    let retVal = null;
		    if (!name || name.trim().length < 1) {
		        return retVal;
		    }
		    try {
		        if (window.vb && window.vb.version) {
		            const requireConfig = requirejs.s.contexts._.config;
		            retVal = requireConfig.paths[name] ? requireConfig.paths[name] : null;
		        }
		        else {
		            if (name === 'engage-mercury-adapter') {
		                retVal = _a.adfEngageSdkUrl;
		            }
		        }
		    }
		    catch (error) { /* nothing to do - this is for Adf presence case */ }
		    return retVal;
		};
		/**
		 * This is based upon the Profile Option: ORA_SVC_MCA_ENABLE_ENGAGE_SDK
		 * or may be overriden by the enableEngageSDK localStorage attribute
		 * @returns true if the Engage SDK should be used instead of the Mercury Client Lib
		 */
		McaCommon.isEngageSDKEnabled = () => {
		    var _b;
		    let retVal = false;
		    const mercuryInfo = (_b = McaCommon.userConfigurations) === null || _b === void 0 ? void 0 : _b.mercuryInfo;
		    if (mercuryInfo === null || mercuryInfo === void 0 ? void 0 : mercuryInfo.engageConfig) {
		        retVal = mercuryInfo.engageConfig.engageEnabled;
		    }
		    else {
		        mcaLogger_1.McaLogger.warn(`${McaCommon.PRE} UserConfigurations missing engageConfig, Backend does not support Engage SDK!`);
		    }
		    // DEV NOTE: For Dev/Demo Purposes to enable Engage from DevTools console: localStorage.setItem('enableEngageSDK','Y');
		    const demoEngageEnabled = localStorage.getItem(mca.Constants.DEMO_ENABLE_ENGAGE_SDK);
		    if (demoEngageEnabled) {
		        retVal = (demoEngageEnabled === 'Y' || demoEngageEnabled === 'y') ? true : false;
		        mcaLogger_1.McaLogger.warn(`${McaCommon.PRE} enableEngageSDK overidden with localStorage ${demoEngageEnabled}!`);
		    }
		    return retVal;
		};
		McaCommon.sendToUef = (eventData) => {
		    // TODO: Remove localstorage flag once the complete functionality tested by QA
		    if (window.UIEventsAPPFramework && localStorage.getItem('DISABLE_UEF_IN_MCA') !== 'Y' && !window.UIEventsAPPFramework.isSkeleton) {
		        try {
		            if (window.UIEventsAPPFramework.ExtensionLogger) {
		                const parsedEventData = JSON.parse(eventData);
		                window.UIEventsAPPFramework.ExtensionLogger.formattedCheckpoint('McaCommon.sendToUef', '7', 'sending response to uef from MCA.', 'SUCCESS', `method: ${parsedEventData.method}`, `uuid: ${parsedEventData.uuid}`);
		            }
		        }
		        catch (error) {
		            mcaLogger_1.McaLogger.log(error.message);
		        }
		        try {
		            const payload = {
		                context: null,
		                eventName: 'MCA',
		                requestContextType: 'Global',
		                responseDetails: typeof (eventData) === 'string' ? JSON.parse(eventData) : eventData,
		            };
		            const sanitizedPayload = JSON.parse(JSON.stringify(payload));
		            window.UIEventsAPPFramework.EventsHandlerFactory.fireEvent(sanitizedPayload, null, true);
		        }
		        catch (error) {
		            mcaLogger_1.McaLogger.error(error);
		        }
		    }
		};
		/**
		 * Parse the page Key and substitue tokens identified as '$TOKEN$' with the Token Value from the inData object
		 * @param pageKey  Raw pageKey with Token Names
		 * @param inData   Array of Token Name/Token Value
		 * @param forceUnique Default value is true.  If true a unique identifier suffix is added to the pageKey to ensure each page instance is unique.
		 * @returns Formatted pageKey
		 */
		McaCommon.substitutePageKeyTokens = (pageKey, inData, forceUnique = true) => {
		    let finalPageKey = '';
		    if (pageKey) {
		        if (pageKey.includes(mca.Constants.PAGE_KEY_TIME_DELIM)) {
		            // The pageKey has already been substituted and made unique
		            return pageKey;
		        }
		        let tempPageKey = '';
		        const qTokenPos = pageKey.indexOf('$');
		        if (qTokenPos < 0) {
		            // Token is not found, return null so that MCA does not used page key returned in redwood Screep  pop
		            return finalPageKey;
		        }
		        const paramSections = pageKey.split('$');
		        for (let i = 0; i <= Math.round(paramSections.length / 2); i++) {
		            const nonTokenPart = paramSections[i * 2 + 0];
		            if (!nonTokenPart || nonTokenPart === '') {
		                // End of pageKey
		                break;
		            }
		            const paramToken = paramSections[i * 2 + 1];
		            if (inData[paramToken]) {
		                tempPageKey += nonTokenPart + inData[paramToken];
		            }
		            else {
		                // if needed token is not found in inData, return null so that MCA does not used page key returned in redwork Screep  pop
		                // return finalPageKey;
		                tempPageKey += nonTokenPart;
		            }
		        }
		        if (tempPageKey != null) {
		            // if blanks are found, substitute all blanks with "_"
		            tempPageKey = tempPageKey.replace(/ /g, '_');
		        }
		        finalPageKey = tempPageKey;
		    }
		    if (forceUnique) {
		        // 11-26-23 Now making the pageKey unique to always force Screen Pops in a new Window
		        const pageKeySuffix = mca.Constants.PAGE_KEY_TIME_DELIM + Date.now();
		        if (!finalPageKey || finalPageKey.length <= 0) {
		            finalPageKey = pageKeySuffix;
		        }
		        if (!finalPageKey.includes(mca.Constants.PAGE_KEY_TIME_DELIM)) {
		            finalPageKey = finalPageKey + pageKeySuffix;
		            mcaLogger_1.McaLogger.info(`${McaCommon.PRE} Forcing unique PageKey ${finalPageKey}`);
		        }
		    }
		    return finalPageKey;
		};
		
		return ojMcaCommon;
	}

	var hasRequiredMcaCommonTypes;

	function requireMcaCommonTypes () {
		if (hasRequiredMcaCommonTypes) return mcaCommonTypes;
		hasRequiredMcaCommonTypes = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.McaWindowChange = exports.CacheMap = exports.ItemChange = exports.CacheLock = exports.McaWindow = exports.McaRedwoodPage = exports.ActionName = exports.PageDisplayMode = exports.Engagement = exports.EngagementEventState = exports.McaEventResponseMap = exports.McaEventMap = exports.McaEventStateMap = exports.CacheControl = exports.Channel = exports.Command = exports.CommandResponse = exports.ObjectActionEvent = exports.createObjectActionEvent = exports.ObjectActionEnum = exports.CommandResponseKeys = exports.InteractionCommandName = exports.AgentCommandName = exports.DirectionToken = exports.UiTypeToken = exports.MappedSystemToken = exports.IncludedSystemToken = exports.SystemToken = exports.EventSource = exports.UpdateType = exports.Result = exports.McaKey = exports.McaMethod = exports.DeltaType = exports.McaWindowState = exports.EventState = exports.Constants = exports.CcaRegistrationStatus = exports.Permission = exports.ResourcePresencesEndPointName = exports.ContactsEndPointName = exports.WrapUpEndPointName = exports.McaEventName = exports.ServiceNameV2 = exports.ServiceName = exports.AppClassification = exports.AppName = exports.OptInFeature = exports.ChannelType = exports.McaEventType = void 0;
			exports.SrTokenKeys = exports.TranscriptEntryType = exports.CallType = exports.TranscriptState = exports.InvokeFetchUserConfigActions = exports.OmniProfileOptionValues = exports.NotificationManagerItemChange = exports.NotificationMap = exports.NotificationManagerItem = exports.NotificationAssignType = exports.NotificationType = exports.PreviewCommMode = exports.SubStatusCdDisplay = exports.CloseCommReason = exports.ObjectMap = exports.ConfigItemKeys = exports.ConfigItemMap = exports.ConfigItemChange = exports.ConfigItem = exports.ObjectChange = exports.ObjectChangeState = exports.BusinessObject = exports.McaTokenMap = exports.ToolbarLayout = exports.EngagementMap = exports.McaWindowMap = exports.EngagementChange = void 0;
			const oj_mca_common_1 = requireOjMcaCommon();
			var McaEventType;
			(function (McaEventType) {
			    McaEventType["agentState"] = "mcaAgentStateEvent";
			    McaEventType["mcaEvent"] = "mcaEvent";
			    McaEventType["objectAction"] = "faObjectActionEvent";
			    McaEventType["screenPop"] = "mcaScreenPopEvent";
			    McaEventType["wrapUp"] = "mcaWrapUpEvent";
			    McaEventType["doVerify"] = "mcaVerifyContactEvent";
			    McaEventType["updateCcaRegistration"] = "updateCcaRegistrationStatus";
			    McaEventType["verified"] = "mcaContactVerifiedEvent";
			    McaEventType["notVerified"] = "mcaContactNotVerifiedEvent";
			    McaEventType["searchContact"] = "mcaSearchContactEvent";
			    McaEventType["notifyOn"] = "mcaNotifyOnEvent";
			    McaEventType["notifyOff"] = "mcaNotifyOffEvent";
			    McaEventType["unstableConnection"] = "mcaUnstableConnection";
			    McaEventType["connectionLost"] = "mcaConnectionLost";
			    McaEventType["connectionEstablished"] = "mcaConnectionExtablished";
			    McaEventType["chatCancel"] = "mcaChatCancel";
			    McaEventType["reloadChatConfig"] = "mcaReloadChatConfig";
			    McaEventType["updateEngagement"] = "mcaUpdateEngagementEvent";
			    McaEventType["startComm"] = "mcaStartCommEvent";
			    McaEventType["endComm"] = "mcaEndCommEvent";
			    McaEventType["transferToQueue"] = "transferToQueue";
			    McaEventType["previewComm"] = "mcaPreviewCommEvent";
			    McaEventType["updateComm"] = "mcaUpdateCommEvent";
			    McaEventType["expansionChanged"] = "mcaControllerExpansionChangedEvent";
			    McaEventType["interactionControlsChanged"] = "mcaInteractionControlStateChanged";
			    McaEventType["forceReload"] = "mcaForceReload";
			    McaEventType["searchAgainNotifyOn"] = "mcaSearchAgainNotifyOn";
			    McaEventType["searchAgainNotifyOff"] = "mcaSearchAgainNotifyOff";
			    McaEventType["showToolbarEvent"] = "showToolbarEvent";
			    McaEventType["addWrapUpToEngagement"] = "addWrapUpToEngagement";
			    McaEventType["addNotifToMap"] = "mcaAddNotifToMap";
			    McaEventType["removeNotifToMap"] = "mcaRemoveNotifToMap";
			    McaEventType["addNotifOnUi"] = "mcaAddNotifToUi";
			    McaEventType["removeNotifOnUi"] = "mcaRemoveNotifToUi";
			    McaEventType["unloadHandling"] = "mcaUnloadEvent";
			    McaEventType["feedLiveTranscript"] = "mcaFeedLiveTranscript";
			    McaEventType["feedOfflineTranscript"] = "mcaFeedOfflineTranscript";
			    McaEventType["feedSystemMessage"] = "mcaFeedSystemMessage";
			})(McaEventType = exports.McaEventType || (exports.McaEventType = {}));
			var ChannelType;
			(function (ChannelType) {
			    ChannelType["phone"] = "ORA_SVC_PHONE";
			    ChannelType["chat"] = "ORA_SVC_CHAT";
			    ChannelType["chatIntRef"] = "SVC_CHATS";
			    ChannelType["video"] = "ORA_SVC_VIDEO";
			    ChannelType["cobrowse"] = "ORA_SVC_COBROWSE";
			    ChannelType["email"] = "ORA_SVC_EMAIL";
			    ChannelType["slack"] = "ORA_SVC_SLACK";
			    ChannelType["sms"] = "ORA_SVC_SMS";
			    ChannelType["web"] = "ORA_SVC_WEB";
			    ChannelType["social"] = "ORA_SVC_SOCIAL";
			    ChannelType["webConference"] = "ORA_SVC_WEB_CONFERENCE";
			    ChannelType["none"] = "ORA_SVC_NONE";
			})(ChannelType = exports.ChannelType || (exports.ChannelType = {}));
			(function (OptInFeature) {
			    OptInFeature["SUMMARIZATION"] = "summarization";
			    OptInFeature["AGENT_ASSIST"] = "agent_assist";
			})(exports.OptInFeature || (exports.OptInFeature = {}));
			(function (AppName) {
			    AppName["service"] = "service";
			    AppName["mca"] = "mca-vbcs-test";
			    AppName["atcagentcare"] = "atcagentcare";
			    AppName["sales"] = "digital-sales";
			    AppName["advancedCustomerCare"] = "advanced-customer-care";
			    AppName["spectra"] = "spectra"; // Spectra Demo App
			})(exports.AppName || (exports.AppName = {}));
			(function (AppClassification) {
			    AppClassification["service"] = "ORA_SERVICE";
			    AppClassification["atcagentcare"] = "AGENT_CARE";
			    AppClassification["sales"] = "ORA_SALES";
			    AppClassification["advancedCustomerCare"] = "ORA_ADVANCED_CUSTOMER_CARE"; // Advanced-customer-care
			})(exports.AppClassification || (exports.AppClassification = {}));
			(function (ServiceName) {
			    ServiceName["contacts"] = "cx_contacts";
			    ServiceName["mcaEvents"] = "cx_multiChannelAdapterEvents";
			    ServiceName["wrapUps"] = "mca_wrapUps";
			    ServiceName["mcafndlookups"] = "mca_fndStaticLookups";
			    ServiceName["mcaChatInterations"] = "mca_chatAgentInteractions";
			    ServiceName["mcaChatTranscript"] = "chatTranscript";
			})(exports.ServiceName || (exports.ServiceName = {}));
			(function (ServiceNameV2) {
			    ServiceNameV2["contacts"] = "contacts";
			    ServiceNameV2["mcaEvents"] = "multiChannelAdapterEvents";
			    ServiceNameV2["wrapUps"] = "wrapUps";
			    ServiceNameV2["mcafndlookups"] = "fndStaticLookups";
			    ServiceNameV2["mcaChatInterations"] = "chatAgentInteractions";
			    ServiceNameV2["mcaChatTranscript"] = "chatTranscript";
			    ServiceNameV2["mcaResourcePresences"] = "resourcePresences";
			})(exports.ServiceNameV2 || (exports.ServiceNameV2 = {}));
			(function (McaEventName) {
			    McaEventName["fetchUserEventConfiguration"] = "/doall_fetchUserEventConfiguration_multiChannelAdapterEvents";
			})(exports.McaEventName || (exports.McaEventName = {}));
			(function (WrapUpEndPointName) {
			    WrapUpEndPointName["getWrapUpById"] = "/get_wrapUps";
			    WrapUpEndPointName["patchWrapUpById"] = "/update_wrapUps";
			    WrapUpEndPointName["getAllWrapUps"] = "/getall_wrapUps";
			    WrapUpEndPointName["getWrapUpCommonReasonLov"] = "/getall_wrapUps-CommReasonLov";
			    WrapUpEndPointName["getWrapUpResolutionCdLov"] = "/getall_wrapUps-ResolutionCdLov";
			    WrapUpEndPointName["getWrapUpCallNotes"] = "/get_wrapUps-CallNotes";
			    WrapUpEndPointName["replaceWrapUpCallNotes"] = "/replace_wrapUps-CallNotes";
			})(exports.WrapUpEndPointName || (exports.WrapUpEndPointName = {}));
			(function (ContactsEndPointName) {
			    ContactsEndPointName["getContactsByContactId"] = "/get_contacts";
			    ContactsEndPointName["getAllContacts"] = "/getall_contacts";
			})(exports.ContactsEndPointName || (exports.ContactsEndPointName = {}));
			(function (ResourcePresencesEndPointName) {
			    ResourcePresencesEndPointName["patchResourcePresencesById"] = "/update_resourcePresences";
			})(exports.ResourcePresencesEndPointName || (exports.ResourcePresencesEndPointName = {}));
			(function (Permission) {
			    Permission["denied"] = "denied";
			    Permission["granted"] = "granted";
			})(exports.Permission || (exports.Permission = {}));
			(function (CcaRegistrationStatus) {
			    CcaRegistrationStatus["register"] = "register";
			    CcaRegistrationStatus["deRegister"] = "deregister";
			})(exports.CcaRegistrationStatus || (exports.CcaRegistrationStatus = {}));
			class Constants {
			}
			Constants.BASE_REST = '/crmRestApi/resources/11.13.18.05/';
			Constants.YES_FLAG = 'Y';
			Constants.NO_FLAG = 'N';
			Constants.MAPKEY = 'key';
			Constants.NEW_VALUE = 'newValue';
			Constants.ACTIVE_COUNT = 'activeCount';
			Constants.APP_CLASS = 'applicationClassification';
			Constants.PAGE_KEY = 'pageKey';
			Constants.PAGE_KEY_TIME_DELIM = '_mcapkts_';
			Constants.TOOLBAR = 'toolbar';
			// public static readonly FUSION: string = 'fusion';
			Constants.EVENT_MAP_KEY = 'mcaEventMapKey';
			Constants.MCA_TOOLBAR_API_VERSION = '1.2.0';
			Constants.MCA_TOOLBAR_MANUAL_NAME = 'MANUAL_TLB';
			Constants.MCA_TOOLBAR_MANUAL_EVENTSOURCE = 'manual-source';
			Constants.INTERNAL = 'MCA_INTERNAL_USE';
			Constants.FA_ENDPOINTS = 'FAEndPoints';
			Constants.ZOOM_IN = 'zoomIn';
			Constants.ZOOM_OUT = 'zoomOut';
			Constants.UNKNOWN_PAGE = 'Unknown_Contact';
			Constants.LAUNCH_CREATE_CONTACT_PAGE = 'Launch_Create_Contact';
			Constants.LAUNCH_CREATE_LEAD_PAGE = 'Launch_Create_Lead';
			Constants.LAUNCH_APP_NAME = 'launchAppName';
			Constants.APP_CLASSIFICATION = 'appClassification';
			Constants.LAUNCHED_FROM = 'launchedFrom';
			Constants.UNKNOWN_CALLER = 'unknownCaller';
			Constants.DEFAULT_APP_CLASS = 'ORA_SERVICE';
			Constants.CHANNEL_TYPE = 'channelType';
			Constants.EVENT_ID = 'eventId';
			Constants.CHANNEL = 'channel';
			Constants.CHAT = 'CHAT';
			Constants.PHONE = 'PHONE';
			Constants.VIDEO = 'VIDEO';
			Constants.NONE = 'NONE';
			Constants.SERVICE_REQUEST = 'SVC_SERVICE_REQUESTS';
			Constants.OMNI_SERVICE_REQUEST = 'ServiceRequest';
			Constants.SERVICE_REQUEST_HRHD = 'SVC_SERVICE_REQUESTS_HRHD';
			Constants.OMNI_SVC_REQ_HRHD = 'HR Help Desk Request';
			Constants.SERVICE_REQUEST_ISR = 'SVC_SERVICE_REQUESTS_ISR';
			Constants.OMNI_SVC_REQ_ISR = 'Internal Help Desk Request';
			Constants.ERR_MSG = 'errorMsg';
			Constants.DEMO_SEED_ENDPOINT = 'seedEp';
			Constants.DEMO_SEED_JWT = 'seedJwt';
			Constants.DEMO_ENABLE_MSI = 'enableMSI';
			Constants.DEMO_SHARED_WORKER = 'seedSharedWorker';
			Constants.DEMO_ENABLE_ENGAGE_SDK = 'enableEngageSDK';
			Constants.UNITTEST_MODE = 'IS_UNIT_TEST_MODE';
			Constants.LOCAL_MODE = 'IS_LOCAL_MODE';
			Constants.VB_DT_MODE = 'IS_DT_MODE';
			Constants.VB_DT_APP_CONFIG = 'SERVICE_WORKER_CONFIG';
			Constants.LOCAL_MODE_WORKER_SERVER = 'LOCAL_MODE_WORKER_SERVER';
			Constants.VB_CONFIG = 'vbInitConfig';
			Constants.FORCED_START_COMM = 'forcedStartComm';
			Constants.TOOLBAR_WINDOW = 'mcatbwin';
			Constants.PRIMARY_WINDOW = 'primaryWin';
			Constants.TOOLBAR_PARENT_WINDOW = 'mcatbp';
			Constants.TOOLBAR_BROADCAST_CHANNEL = 'mcaToolbarWindowChannel';
			Constants.CONTAINER_BROADCAST_CHANNEL = 'mcaContainerChannel';
			Constants.PRESENCE_BROADCAST_CHANNEL = 'mcaPresenceChannel';
			Constants.UNSAVED_NOTES_PREFIX = 'unsaved-notes-';
			Constants.MCA_SHARED_WORKER_URL = 'mcaSharedWorkerURL';
			Constants.UEF_COMMUNICATION_KEY = 'ORA_SVC_UI_EVENTS_FRAMEWORK';
			Constants.UEF_INITIALIZED_EVENT = 'UEF_INITIALIZED';
			Constants.CHAT_TRANSCRIPT_KEY = 'chatTranscript_';
			Constants.NOTES_STORAGE_PREFIX = 'interaction_notes_';
			Constants.OUTCOME_STORAGE_PREFIX = 'interaction_outcome_chat_';
			exports.Constants = Constants;
			(function (EventState) {
			    EventState["start"] = "started";
			    EventState["wait"] = "waiting";
			    EventState["process"] = "processing";
			    EventState["loaded"] = "loaded";
			    EventState["complete"] = "completed";
			    EventState["fail"] = "failed";
			})(exports.EventState || (exports.EventState = {}));
			(function (McaWindowState) {
			    McaWindowState["opening"] = "opening";
			    McaWindowState["opened"] = "opened";
			    McaWindowState["dataChanged"] = "dataChanged";
			    McaWindowState["unloading"] = "unloading";
			    McaWindowState["deleted"] = "deleted";
			    McaWindowState["orphaned"] = "orphaned";
			    McaWindowState["focusChanged"] = "focusChanged";
			    McaWindowState["forceClose"] = "forceClose";
			    McaWindowState["engagementAdded"] = "engagementAdded";
			})(exports.McaWindowState || (exports.McaWindowState = {}));
			var DeltaType;
			(function (DeltaType) {
			    DeltaType[DeltaType["none"] = 0] = "none";
			    DeltaType[DeltaType["state"] = 1] = "state";
			    DeltaType[DeltaType["data"] = 2] = "data";
			})(DeltaType = exports.DeltaType || (exports.DeltaType = {}));
			var McaMethod;
			(function (McaMethod) {
			    McaMethod["newComm"] = "newCommEvent";
			    McaMethod["startComm"] = "startCommEvent";
			    McaMethod["updateComm"] = "updateCommDataEvent";
			    McaMethod["upgradeComm"] = "upgradeCommEvent";
			    McaMethod["downgradeComm"] = "downgradeCommEvent";
			    McaMethod["closeComm"] = "closeCommEvent";
			    McaMethod["onDataUpdate"] = "onDataUpdated";
			    McaMethod["onToolbarMsg"] = "onToolbarMessage";
			    McaMethod["closeCompanion"] = "closeCompanionPanel";
			    McaMethod["openCompanion"] = "openCompanionPanel";
			    McaMethod["onInteractionCmd"] = "onToolbarInteractionCommand";
			    McaMethod["onAgentCmd"] = "onToolbarAgentCommand";
			    McaMethod["postToolbar"] = "postToolbarMessage";
			    McaMethod["interactionCmdResponse"] = "tbInteractionCommandResponse";
			    McaMethod["agentCmdResponse"] = "tbAgentCommandResponse";
			    McaMethod["getConfig"] = "getConfiguration";
			    McaMethod["agentStateEvent"] = "agentStateEvent";
			    McaMethod["onOutgoing"] = "onOutgoingEvent";
			    McaMethod["outboundError"] = "outboundCommError";
			    McaMethod["fetchUserEventConfiguration"] = "fetchUserEventConfiguration";
			    McaMethod["previewComm"] = "previewCommEvent";
			    McaMethod["interactionControlsChanged"] = "interactionControlStateChanged";
			    McaMethod["getCustomerData"] = "getCustomerData";
			    McaMethod["getScreenPopDataEvent"] = "getScreenPopData";
			    McaMethod["showToolbar"] = "showToolbar";
			    McaMethod["hideToolbar"] = "hideToolbar";
			    McaMethod["isToolbarVisible"] = "isToolbarVisible";
			    McaMethod["newMessage"] = "newMessageEvent";
			    McaMethod["transferedToQueue"] = "transferedToQueue";
			    McaMethod["enableFeature"] = "EnableFeature";
			    McaMethod["FeedLiveTranscript"] = "FeedLiveTranscript";
			    McaMethod["FeedOfflineTranscript"] = "FeedOfflineTranscript";
			    McaMethod["FeedSystemMessage"] = "FeedSystemMessage";
			})(McaMethod = exports.McaMethod || (exports.McaMethod = {}));
			(function (McaKey) {
			    McaKey["updateType"] = "updateType";
			})(exports.McaKey || (exports.McaKey = {}));
			(function (Result) {
			    Result["success"] = "success";
			    Result["error"] = "error";
			})(exports.Result || (exports.Result = {}));
			(function (UpdateType) {
			    UpdateType["wrapUp"] = "WRAPUP_CLOSED";
			    UpdateType["data"] = "CUSTOMER_DATA";
			})(exports.UpdateType || (exports.UpdateType = {}));
			(function (EventSource) {
			    EventSource["toolbar"] = "toolbar";
			    EventSource["mercury"] = "mercury";
			    EventSource["application"] = "application"; // For Events Initiate by the App such as 'Manual Call'
			})(exports.EventSource || (exports.EventSource = {}));
			var SystemToken;
			(function (SystemToken) {
			    SystemToken["ani"] = "SVCMCA_ANI";
			    SystemToken["email"] = "SVCMCA_EMAIL";
			    SystemToken["interactionId"] = "SVCMCA_INTERACTION_ID";
			    SystemToken["parentInteractionId"] = "SVCMCA_PARENT_INTERACTION_ID";
			    SystemToken["wrapupId"] = "SVCMCA_WRAPUP_ID";
			    SystemToken["direction"] = "SVCMCA_COMMUNICATION_DIRECTION";
			    SystemToken["displayName"] = "SVCMCA_DISPLAY_NAME";
			    SystemToken["offerTimeout"] = "SVCMCA_OFFER_TIMEOUT_SEC";
			    SystemToken["contactMutation"] = "SVCMCA_CONTACT_MUTATION";
			    SystemToken["contactName"] = "SVCMCA_CONTACT_NAME";
			    SystemToken["contactId"] = "SVCMCA_CONTACT_ID";
			    SystemToken["firstName"] = "SVCMCA_CONTACT_FIRST_NAME";
			    SystemToken["lastName"] = "SVCMCA_CONTACT_LAST_NAME";
			    SystemToken["contactJobTitle"] = "SVCMCA_CONTACT_JOB_TITLE";
			    SystemToken["contactNumber"] = "SVCMCA_CONTACT_NUMBER";
			    SystemToken["contactPrimaryPhone"] = "SVCMCA_CONTACT_PRIMARY_PHONE";
			    SystemToken["accountId"] = "SVCMCA_ORG_ID";
			    SystemToken["accountName"] = "SVCMCA_ORG_NAME";
			    SystemToken["accountNumber"] = "SVCMCA_ORG_NUMBER";
			    SystemToken["primaryAccountName"] = "SVCMCA_CONTACT_PRIM_ORG_NAME";
			    SystemToken["leadContactName"] = "SVCMCA_LEAD_CONTACT_NAME";
			    SystemToken["leadPhone"] = "SVCMCA_LEAD_PHONE";
			    SystemToken["leadId"] = "SVCMCA_LEAD_ID";
			    SystemToken["leadName"] = "SVCMCA_LEAD_NAME";
			    SystemToken["leadNum"] = "SVCMCA_LEAD_NUMBER";
			    SystemToken["srId"] = "SVCMCA_SR_ID";
			    SystemToken["srIdHrHd"] = "SVCMCA_HRHD_SR_ID";
			    SystemToken["srNum"] = "SVCMCA_SR_NUM";
			    SystemToken["srNumHrHd"] = "SVCMCA_HRHD_SR_NUM";
			    SystemToken["isrNum"] = "SVCMCA_ISR_NUM";
			    SystemToken["isrId"] = "SVCMCA_ISR_ID";
			    SystemToken["optyId"] = "SVCMCA_OPPORTUNITY_ID";
			    SystemToken["callId"] = "SVCMCA_CALL_ID";
			    SystemToken["secondCallType"] = "SVCMCA_2NDARY_CALL_TYPE";
			    SystemToken["window"] = "mcaWindow";
			    SystemToken["unknownFlow"] = "mcaUnknownFlow";
			    SystemToken["bypassCustomerVerification"] = "SVCMCA_BYPASS_CUSTOMER_VERIFICATION";
			    SystemToken["bypassIdentifyContact"] = "SVCMCA_BYPASS_IDENTIFY_CONTACT";
			    SystemToken["bypassAutoScreenPop"] = "SVCMCA_BYPASS_AUTO_SCREEN_POP";
			    SystemToken["objectType"] = "SVCMCA_INTERACTION_REF_OBJ_TYPE";
			    SystemToken["manualMca"] = "SVCMCA_MANUAL";
			    SystemToken["clickToDial"] = "SVCMCA_CLICK2DIAL";
			    SystemToken["objectId"] = "SVCMCA_INTERACTION_REF_OBJ_ID";
			    SystemToken["updateAttrKey"] = "SVCMCA_UPDATE_TOKEN_NAME";
			    SystemToken["interactionDescription"] = "SVCMCA_INTERACTION_DESCRIPTION";
			    SystemToken["baseUrl"] = "SVCMCA_BASE_URL";
			    SystemToken["queueId"] = "SVCMCA_QUEUE_ID";
			    SystemToken["chatId"] = "SVCMCA_CHAT_ID";
			    SystemToken["queueName"] = "SVCMCA_QUEUE_NAME";
			    SystemToken["client_side_screenpop"] = "SVCMCA_CLIENT_SIDE_SCREENPOP";
			    SystemToken["createLeadButtonOn"] = "SVCMCA_CREATE_LEAD_BUTTON_ON";
			    SystemToken["uiTypeCd"] = "SVCMCA_UI_TYPE_CD";
			    SystemToken["spFailOverHandled"] = "SVCMCA_SP_FAILOVER_HANDLED";
			    SystemToken["spFailOverObject"] = "SVCMCA_SP_FAILOVER_OBJECT";
			    SystemToken["spFailOverPage"] = "SVCMCA_SP_FAILOVER_PAGE";
			    SystemToken["spFailOverObjId"] = "SVCMCA_SP_FAILOVER_OBJ_ID";
			    SystemToken["woType"] = "WoTypeName";
			    SystemToken["woName"] = "WoName";
			    SystemToken["appClassification"] = "SVCMCA_APPLICATION_CLASSIFICATION";
			    SystemToken["stripeCd"] = "SVCMCA_STRIPE_CD";
			    SystemToken["confInteractionsMapper"] = "SVCMCA_INTERACTION_MAPPER";
			    SystemToken["fileAttachmentsSupported"] = "fileAttachmentsSupported";
			    SystemToken["transferPending"] = "SVCMCA_TRANSFER_PEND";
			    SystemToken["assignmentType"] = "SVCMCA_CHAT_ASSIGNMENT_TYPE";
			})(SystemToken = exports.SystemToken || (exports.SystemToken = {}));
			(function (IncludedSystemToken) {
			    IncludedSystemToken["ani"] = "SVCMCA_ANI";
			    IncludedSystemToken["email"] = "SVCMCA_EMAIL";
			    IncludedSystemToken["contactName"] = "SVCMCA_CONTACT_NAME";
			    IncludedSystemToken["contactJobTitle"] = "SVCMCA_CONTACT_JOB_TITLE";
			    IncludedSystemToken["srNum"] = "SVCMCA_SR_NUM";
			    IncludedSystemToken["interactionDescription"] = "SVCMCA_INTERACTION_DESCRIPTION";
			    IncludedSystemToken["queueName"] = "SVCMCA_QUEUE_NAME";
			    IncludedSystemToken["primaryAccountName"] = "SVCMCA_CONTACT_PRIM_ORG_NAME";
			    IncludedSystemToken["contactPrimaryPhone"] = "Primary Contact Number";
			})(exports.IncludedSystemToken || (exports.IncludedSystemToken = {}));
			(function (MappedSystemToken) {
			    MappedSystemToken["ani"] = "Phone Number";
			    MappedSystemToken["email"] = "Email";
			    MappedSystemToken["interactionId"] = "Interaction identifier";
			    MappedSystemToken["parentInteractionId"] = "Parent interaction identifier";
			    MappedSystemToken["wrapupId"] = "Wrapup ID";
			    MappedSystemToken["direction"] = "Communication direction";
			    MappedSystemToken["displayName"] = "Display Name";
			    MappedSystemToken["offerTimeout"] = "Offer Timeout Seconds";
			    MappedSystemToken["contactName"] = "Contact Name";
			    MappedSystemToken["contactId"] = "Contact Id";
			    MappedSystemToken["firstName"] = "Contact First Name";
			    MappedSystemToken["lastName"] = "Contact Last Name";
			    MappedSystemToken["contactJobTitle"] = "Contact Job Title";
			    MappedSystemToken["contactNumber"] = "Contact Number";
			    MappedSystemToken["accountId"] = "Organization Id";
			    MappedSystemToken["accountName"] = "Organization Name";
			    MappedSystemToken["accountNumber"] = "Account Party Number";
			    MappedSystemToken["leadContactName"] = "Lead Contact Name";
			    MappedSystemToken["leadId"] = "Lead Id";
			    MappedSystemToken["leadName"] = "Lead Name";
			    MappedSystemToken["leadNum"] = "Lead Number";
			    MappedSystemToken["srId"] = "Service Request Id";
			    MappedSystemToken["srNum"] = "Service Request Number";
			    MappedSystemToken["optyId"] = "Opportunity Id";
			    MappedSystemToken["callId"] = "SVCMCA_CALL_ID";
			    MappedSystemToken["secondCallType"] = "Secondary Call Type";
			    MappedSystemToken["window"] = "mcaWindow";
			    MappedSystemToken["unknownFlow"] = "mcaUnknownFlow";
			    MappedSystemToken["bypassCustomerVerification"] = "Skip customer verification step";
			    MappedSystemToken["bypassIdentifyContact"] = "Skip customer identification step";
			    MappedSystemToken["bypassAutoScreenPop"] = "Skip the auto screen pop engine";
			    MappedSystemToken["objectType"] = "SVCMCA_INTERACTION_REF_OBJ_TYPE";
			    MappedSystemToken["objectId"] = "SVCMCA_INTERACTION_REF_OBJ_ID";
			    MappedSystemToken["updateAttrKey"] = "SVCMCA_UPDATE_TOKEN_NAME";
			    MappedSystemToken["interactionDescription"] = "Interaction Description";
			    MappedSystemToken["baseUrl"] = "SVCMCA_BASE_URL";
			    MappedSystemToken["queueId"] = "Queue ID";
			    MappedSystemToken["queueName"] = "Queue Name";
			    MappedSystemToken["client_side_screenpop"] = "SVCMCA_CLIENT_SIDE_SCREENPOP";
			    MappedSystemToken["createLeadButtonOn"] = "SVCMCA_CREATE_LEAD_BUTTON_ON";
			    MappedSystemToken["uiTypeCd"] = "SVCMCA_UI_TYPE_CD";
			    MappedSystemToken["spFailOverHandled"] = "SVCMCA_SP_FAILOVER_HANDLED";
			    MappedSystemToken["spFailOverObject"] = "SVCMCA_SP_FAILOVER_OBJECT";
			    MappedSystemToken["spFailOverPage"] = "SVCMCA_SP_FAILOVER_PAGE";
			    MappedSystemToken["spFailOverObjId"] = "SVCMCA_SP_FAILOVER_OBJ_ID";
			    MappedSystemToken["woType"] = "WoTypeName";
			    MappedSystemToken["woName"] = "WoName";
			    MappedSystemToken["appClassification"] = "Application Classification";
			    MappedSystemToken["primaryAccountName"] = "Primary Account Name";
			    MappedSystemToken["contactPrimaryPhone"] = "Primary Contact Number";
			})(exports.MappedSystemToken || (exports.MappedSystemToken = {}));
			(function (UiTypeToken) {
			    UiTypeToken["adf"] = "ORA_SVC_ADF";
			    UiTypeToken["redwood"] = "ORA_SVC_REDWOOD";
			})(exports.UiTypeToken || (exports.UiTypeToken = {}));
			(function (DirectionToken) {
			    DirectionToken["inbound"] = "ORA_SVC_INBOUND";
			    DirectionToken["outbound"] = "ORA_SVC_OUTBOUND";
			})(exports.DirectionToken || (exports.DirectionToken = {}));
			(function (AgentCommandName) {
			    AgentCommandName["makeAvailable"] = "makeAvailable";
			    AgentCommandName["makeUnavailable"] = "makeUnavailable";
			    AgentCommandName["getActiveEngagements"] = "getActiveEngagements";
			    AgentCommandName["getBreakReasons"] = "getBreakReasons";
			    AgentCommandName["getInteractionCommands"] = "getActiveInteractionCommands";
			    AgentCommandName["getChannelPrefs"] = "getChannelPrefs";
			    AgentCommandName["getVideoConfig"] = "getVideoConfig"; // retrieve LX Video Configuration
			})(exports.AgentCommandName || (exports.AgentCommandName = {}));
			var InteractionCommandName;
			(function (InteractionCommandName) {
			    InteractionCommandName["accept"] = "accept";
			    InteractionCommandName["reject"] = "reject";
			    InteractionCommandName["autoAccept"] = "autoAccept";
			    InteractionCommandName["forceAccept"] = "forceAccept";
			    InteractionCommandName["chatOfferTimeout"] = "chatOfferTimeout";
			    InteractionCommandName["setActive"] = "setActive";
			    InteractionCommandName["disconnect"] = "disconnect";
			    InteractionCommandName["transferToQueue"] = "transferToQueue";
			    InteractionCommandName["hold"] = "hold";
			    InteractionCommandName["unhold"] = "unhold";
			    InteractionCommandName["mute"] = "mute";
			    InteractionCommandName["unmute"] = "unmute";
			    InteractionCommandName["record"] = "record";
			    InteractionCommandName["stopRecord"] = "stopRecord";
			    InteractionCommandName["init_transfer"] = "init_transfer";
			    InteractionCommandName["getCommunicationChannel"] = "getCommunicationChannel";
			    InteractionCommandName["wrapupComplete"] = "wrapupComplete";
			})(InteractionCommandName = exports.InteractionCommandName || (exports.InteractionCommandName = {}));
			(function (CommandResponseKeys) {
			    CommandResponseKeys["channelPrefs"] = "channelPrefsMap";
			    CommandResponseKeys["lxVideoConfig"] = "lxVideoConfig";
			})(exports.CommandResponseKeys || (exports.CommandResponseKeys = {}));
			(function (ObjectActionEnum) {
			    ObjectActionEnum["Create"] = "CREATED";
			    ObjectActionEnum["Delete"] = "DELETED";
			    ObjectActionEnum["Update"] = "UPDATED";
			    ObjectActionEnum["FailOver"] = "FAILOVER";
			    ObjectActionEnum["Select"] = "SELECTED";
			    ObjectActionEnum["Open"] = "OPENED";
			    ObjectActionEnum["Close"] = "CLOSED";
			    ObjectActionEnum["LaunchCreate"] = "LAUNCH_CREATE";
			})(exports.ObjectActionEnum || (exports.ObjectActionEnum = {}));
			/**
			 * *Note*: CustomEvent type doesn't support inheritance.
			 * Helper method to create common application object action event.
			 */
			function createObjectActionEvent(action1, objectId1, objectType1, objectData1, sourceEvent1, engagementContext1) {
			    return new CustomEvent(McaEventType.objectAction, { bubbles: true,
			        cancelable: false,
			        detail: { action: action1, objectId: objectId1, objectType: objectType1, objectData: objectData1, sourceEvent: sourceEvent1, engagementContext: engagementContext1 }
			    });
			}
			exports.createObjectActionEvent = createObjectActionEvent;
			class ObjectActionEvent extends CustomEvent {
			    constructor(action2, objectId2, objectType2, sourceEvent2, engagementContext2) {
			        super(McaEventType.objectAction, { bubbles: true,
			            cancelable: false,
			            detail: { action: action2, objectId: objectId2, objectType: objectType2, sourceEvent: sourceEvent2, engagementContext: engagementContext2 } });
			    }
			}
			exports.ObjectActionEvent = ObjectActionEvent;
			class CommandResponse {
			    constructor(name, result, commandId, engagementId, outData, channelType, realTimeCommChannel, workType) {
			        this.command = name;
			        this.result = result;
			        this.commandId = commandId;
			        this.engagementId = engagementId;
			        this.outData = outData;
			        this.channelType = channelType;
			        this.realTimeCommChannel = realTimeCommChannel;
			        this.workType = workType;
			    }
			    static getCommandResponse(eventData) {
			        let cmdResponse;
			        if (!eventData) {
			            return cmdResponse;
			        }
			        const name = eventData.command;
			        if (!name) {
			            return cmdResponse;
			        }
			        const eventId = eventData.eventId;
			        const cmdId = eventData.commandId;
			        const result = eventData.result;
			        const outData = eventData.outData;
			        const channelType = eventData.channelType;
			        cmdResponse = new CommandResponse(name, result, cmdId, eventId, outData, channelType);
			        return cmdResponse;
			    }
			}
			exports.CommandResponse = CommandResponse;
			var CommandType;
			(function (CommandType) {
			    CommandType["agent"] = "onToolbarAgentCommand";
			    CommandType["interaction"] = "onToolbarInteractionCommand";
			})(CommandType || (CommandType = {}));
			class Command {
			    constructor(name, engagementId, channelType, parameters, responseCallback, target, workType) {
			        this.setMethod = () => {
			            this.method = McaMethod.onAgentCmd;
			            if (this.command in InteractionCommandName) {
			                this.method = McaMethod.onInteractionCmd;
			            }
			        };
			        this.command = name;
			        this.eventId = engagementId;
			        this.channelType = channelType;
			        this.inData = parameters;
			        if (!this.inData) {
			            this.inData = {};
			        }
			        this.responseCallback = responseCallback;
			        this.target = target;
			        this.setMethod();
			        this.timeStamp = Date.now();
			        if (this.responseCallback) {
			            this.commandId = oj_mca_common_1.McaCommon.localUuidV4();
			        }
			        if (this.channelType) {
			            switch (this.channelType) {
			                case ChannelType.phone:
			                    this.channel = 'PHONE';
			                    break;
			                case ChannelType.chat:
			                    this.channel = 'CHAT';
			                    break;
			                case ChannelType.webConference:
			                    this.channel = 'ZOOM';
			                    break;
			            }
			        }
			        this.workType = workType;
			    }
			    // For Array Sorting
			    static compare(lhs, rhs) {
			        let retVal = 0;
			        if (lhs && rhs) {
			            if (lhs.timeStamp && rhs.timeStamp) {
			                if (lhs.timeStamp < rhs.timeStamp) {
			                    retVal = -1; // lhs comes 1st
			                }
			                else if (lhs.timeStamp > rhs.timeStamp) {
			                    retVal = 1; // rhs comes 1st
			                }
			            }
			        }
			        return retVal;
			    }
			    toString() {
			        let params = '(';
			        if (this.eventId) {
			            params += this.eventId;
			            params += ',';
			        }
			        if (this.inData) {
			            for (const key of Object.keys(this.inData)) {
			                params += key;
			                params += ':';
			                params += this.inData[key];
			                params += ',';
			            }
			        }
			        params += ')';
			        return this.command + params;
			    }
			}
			exports.Command = Command;
			/**
			 * The Channel defines the source for Engagements.
			 */
			class Channel {
			    constructor(channelType, source, workType, displayName, displayNamePlural, channel, networkType) {
			        this.channelType = channelType;
			        this.source = source;
			        this.workType = workType;
			        this.displayName = displayName;
			        this.displayNamePlural = displayNamePlural;
			        this.channel = channel;
			        this.networkType = networkType;
			    }
			}
			exports.Channel = Channel;
			class CacheControl {
			    constructor(origEventSource, sessionId, deletedFlag, createTime, unloadTime) {
			        this.origEventSource = origEventSource;
			        this.sessionId = sessionId;
			        this.deletedFlag = deletedFlag;
			        this.createTime = createTime;
			        this.unloadTime = unloadTime;
			    }
			    static fromJSON(obj) {
			        return Object.assign(new CacheControl(), obj);
			    }
			    okForDelete() {
			        // <TODO> check session / unloadTime etc...
			        return this.deletedFlag === 'Y' ? true : false;
			    }
			}
			exports.CacheControl = CacheControl;
			class McaEventStateMap {
			}
			exports.McaEventStateMap = McaEventStateMap;
			class McaEventMap {
			}
			exports.McaEventMap = McaEventMap;
			class McaEventResponseMap {
			}
			exports.McaEventResponseMap = McaEventResponseMap;
			class EngagementEventState {
			    static fromJSON(obj) {
			        const o = Object.assign(new EngagementEventState(), obj);
			        return o;
			    }
			    toString() {
			        let retVal = '' + this.method + ' : ' + this.state;
			        if (this.eventMapKey) {
			            retVal += ' : ' + this.eventMapKey;
			        }
			        return retVal;
			    }
			}
			exports.EngagementEventState = EngagementEventState;
			class Engagement {
			    constructor(event) {
			        this.updateTicketNum = -1; // Uniquely tracks updateCommEvents
			        this.transcriptReadyStatus = false;
			        if (event) {
			            this.engagementId = event.data.engagementId;
			            if (!this.engagementId) {
			                this.engagementId = event.data.eventId;
			            }
			            this.eventId = event.data.eventId;
			            this.channelType = event.data.channelType;
			            this.origin = event.origin;
			            this.stateMap = new McaEventStateMap();
			            const cd = new CacheControl(event.eventSource, oj_mca_common_1.McaCommon.getSessionId());
			            this.cacheControl = cd;
			            this.engagementSource = event.mcaOrigEventSource;
			            this.windowName = event.window;
			            this.data = event.data;
			            const inData = {};
			            if (event.data.inData) {
			                // for (let key in event.data.inData) {
			                for (const key of Object.keys(event.data.inData)) {
			                    switch (key) {
			                        case SystemToken.interactionId:
			                    }
			                    inData[key] = event.data.inData[key];
			                }
			            }
			            this.data.inData = inData;
			            this.lastEvent = event;
			            this.eventMap = new McaEventMap();
			            this.eventMap[event.method] = event;
			            this.responseMap = new McaEventResponseMap();
			        }
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new Engagement(), obj);
			        o.cacheControl = CacheControl.fromJSON(o.cacheControl);
			        return o;
			    }
			    getId() {
			        return this.engagementId;
			    }
			    isActive() {
			        let rv = false;
			        if (this.stateMap) {
			            const start = this.stateMap[McaMethod.startComm];
			            const close = this.stateMap[McaMethod.closeComm];
			            if (start && !close) {
			                rv = true;
			            }
			            else if (start && close) {
			                // 07-27-20 Now we treat WrapUp state as Active
			                const startCommEvent = this.responseMap[McaMethod.startComm];
			                if (startCommEvent) {
			                    const startActions = startCommEvent.actions;
			                    if (startActions && startActions.length > 0) {
			                        for (let i = 0; i < startActions.length; i++) {
			                            const action = startActions[i];
			                            if (action && action.name === ActionName.WrapUp) {
			                                rv = true;
			                                break;
			                            }
			                        }
			                    }
			                }
			            }
			        }
			        return rv;
			    }
			    /**
			     * Number used to differentiate multiple events of the same type
			     * necessary for updateCommDataEvents
			     */
			    getTicketNum() {
			        this.updateTicketNum++;
			        return this.updateTicketNum;
			    }
			    toString() {
			        let retVal = '[engagementId: ' + this.engagementId + ' interactionId: ' + this.interactionId + ' ';
			        if (this.stateMap) {
			            retVal += ' States: ';
			            const newComm = this.stateMap[McaMethod.newComm];
			            if (newComm) {
			                retVal += newComm;
			            }
			            const start = this.stateMap[McaMethod.startComm];
			            if (start) {
			                retVal += ' ';
			                retVal += start;
			            }
			            const close = this.stateMap[McaMethod.closeComm];
			            if (close) {
			                retVal += ' ';
			                retVal += close;
			            }
			        }
			        retVal += ']';
			        return retVal;
			    }
			}
			exports.Engagement = Engagement;
			(function (PageDisplayMode) {
			    PageDisplayMode["CurrentWindow"] = "CURRENT_WINDOW";
			    PageDisplayMode["NewWindow"] = "NEW_WINDOW";
			    PageDisplayMode["CloseWindow"] = "CLOSE_WINDOW";
			    PageDisplayMode["None"] = "NONE";
			    PageDisplayMode["MsiWindow"] = "MSI_WINDOW";
			})(exports.PageDisplayMode || (exports.PageDisplayMode = {}));
			// TODO - REMOVE
			// export enum ControllerDisplayState {
			//     drawer, // 0 - Only Drawer is displayed i.e. no real estate required
			//     bar, // 1 - Only Channel Bar is displayed; 27px
			//     levelOneExpansion, // 2 - Standard Sized Controller Displayed
			//     secondLevelExpansion // 3 - Expanded Sized Controller Displayed e.g. if on a video or screen share
			// }
			// export interface ExpansionState {
			//     isControllerVisible: boolean;
			//     // displayState: ControllerDisplayState;
			//     width: string;
			// }
			var ActionName;
			(function (ActionName) {
			    ActionName["Notify"] = "Notify";
			    ActionName["ScreenPop"] = "ScreenPop";
			    ActionName["ScreenPopFailure"] = "ScreenPop_Failure";
			    ActionName["SearchContact"] = "SearchContact";
			    ActionName["VerifyContact"] = "VerifyContact";
			    ActionName["LaunchCreate"] = "LaunchCreate";
			    ActionName["WrapUp"] = "WrapUp";
			    ActionName["EndEngagement"] = "EndEngagement";
			    ActionName["EndCommunication"] = "EndCommunication";
			    ActionName["ContactVerified"] = "ContactVerified";
			    ActionName["CreateLeadPageInfo"] = "CreateLeadPageInfo";
			    ActionName["CreateContactPageInfo"] = "CreateContactPageInfo";
			    ActionName["UnknownCallerPageInfo"] = "UnknownCallerPageInfo";
			})(ActionName = exports.ActionName || (exports.ActionName = {}));
			class McaRedwoodPage {
			}
			exports.McaRedwoodPage = McaRedwoodPage;
			class McaWindow {
			    constructor() {
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new McaWindow(), obj);
			        o.cacheControl = CacheControl.fromJSON(o.cacheControl);
			        return o;
			    }
			    getId() {
			        return this.name;
			    }
			}
			exports.McaWindow = McaWindow;
			class CacheLock {
			    constructor(autoFill, winName, time, id) {
			        if (autoFill) {
			            // incase if window name is not set we are setting it so that the isLocked works as expected
			            this.winName = window.name ? window.name : `inital_load_${Date.now()}`;
			            this.time = Date.now();
			            const lid = localStorage.getItem(CacheLock.ID_KEY);
			            let seq = 369;
			            if (lid) {
			                seq = +lid;
			                if (seq++ >= Number.MAX_SAFE_INTEGER) {
			                    seq = 1;
			                }
			            }
			            localStorage.setItem(CacheLock.ID_KEY, '' + seq);
			            this.id = '' + seq;
			        }
			        else {
			            if (winName) {
			                this.winName = winName;
			            }
			            if (time) {
			                this.time = time;
			            }
			            if (id) {
			                this.id = id;
			            }
			        }
			    }
			    static fromJSON(obj) {
			        return Object.assign(new CacheLock(), obj);
			    }
			    isLocked() {
			        let retVal = false;
			        if (this.winName && this.id) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    equals(rhs) {
			        let retVal = false;
			        if (!rhs) {
			            return retVal;
			        }
			        if (this === rhs) {
			            retVal = true;
			        }
			        else {
			            retVal = this.winName === rhs.winName && this.id === rhs.id;
			        }
			        return retVal;
			    }
			    clear() {
			        delete this.winName;
			        delete this.id;
			        this.time = Date.now();
			    }
			}
			CacheLock.ID_KEY = 'oj-mca-id';
			exports.CacheLock = CacheLock;
			/**
			 * Tracks updates to items stored in CacheMaps.
			 */
			class ItemChange {
			    /**
			     * returns true if there is an ItemChange to handle
			     */
			    isChanged() {
			        if (this.type === DeltaType.data || this.type === DeltaType.state) {
			            return true;
			        }
			        return false;
			    }
			    /**
			     * Clears the Item
			     */
			    clear() {
			        this.type = DeltaType.none;
			    }
			}
			exports.ItemChange = ItemChange;
			class CacheMap {
			    constructor() {
			        this._items = {};
			    }
			    get(key) {
			        return this._items[key];
			    }
			    put(key, value) {
			        this._items[key] = value;
			    }
			    remove(key) {
			        delete this._items[key];
			    }
			    has(key) {
			        return this._items[key] ? true : false;
			    }
			    getLock() {
			        return this._lock;
			    }
			    setLock(lock) {
			        this._lock = lock;
			    }
			    keys() {
			        return Object.keys(this._items);
			    }
			    size() {
			        return this.keys().length;
			    }
			}
			exports.CacheMap = CacheMap;
			class McaWindowChange extends ItemChange {
			    constructor(windowName, state, type, engagementId) {
			        super();
			        this.windowName = windowName;
			        this.state = state;
			        this.type = type;
			        this.engagementId = engagementId;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new McaWindowChange(), obj);
			        return o;
			    }
			    clear() {
			        delete this.windowName;
			        delete this.state;
			        this.type = DeltaType.none;
			    }
			    isChanged() {
			        let retVal = false;
			        if (this.windowName && this.state) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    toString() {
			        return ' windowName: ' + this.windowName + ' state: ' + this.state;
			    }
			}
			exports.McaWindowChange = McaWindowChange;
			class EngagementChange extends ItemChange {
			    constructor(engagementId, state, type) {
			        super();
			        this.engagementId = engagementId;
			        this.state = state;
			        this.type = type;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new EngagementChange(), obj);
			        o.state = (o.state) ? EngagementEventState.fromJSON(o.state) : o.state;
			        return o;
			    }
			    clear() {
			        delete this.engagementId;
			        delete this.state;
			        this.type = DeltaType.none;
			    }
			    isChanged() {
			        let retVal = false;
			        if (this.engagementId && this.state) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    toString() {
			        return ' engagementId: ' + this.engagementId + ' state: ' + this.state + ' type: ' + this.type;
			    }
			}
			exports.EngagementChange = EngagementChange;
			class McaWindowMap extends CacheMap {
			    constructor() {
			        super();
			    }
			    fromJSON(obj) {
			        const o = Object.assign(new McaWindowMap(), obj);
			        o._lock = CacheLock.fromJSON(o._lock);
			        o._delta = McaWindowChange.fromJSON(o._delta);
			        return o;
			    }
			    getDelta() {
			        return this._delta;
			    }
			    setDelta(delta) {
			        this._delta = delta;
			    }
			}
			exports.McaWindowMap = McaWindowMap;
			class EngagementMap extends CacheMap {
			    constructor() {
			        super();
			    }
			    fromJSON(obj) {
			        const o = Object.assign(new EngagementMap(), obj);
			        o._lock = CacheLock.fromJSON(o._lock);
			        o._delta = EngagementChange.fromJSON(o._delta);
			        return o;
			    }
			    /**
			     * overrides the base method and converts the result to an Engagement object
			     * <TODO> analyze performance impact of engagement creation
			     */
			    get(key) {
			        let engagement = super.get(key);
			        if (engagement) {
			            if (!(engagement instanceof Engagement)) {
			                engagement = Engagement.fromJSON(engagement);
			                super.put(key, engagement);
			            }
			        }
			        return engagement;
			    }
			    getDelta() {
			        return this._delta;
			    }
			    setDelta(delta) {
			        if (delta.type === DeltaType.none) {
			            delta.clear();
			        }
			        this._delta = delta;
			    }
			    toString() {
			        let retVal = 'EngagementMap: ';
			        if (this._items) {
			            const keys = this.keys();
			            if (keys) {
			                const count = keys.length;
			                retVal += 'Count: ' + count + '\n';
			                for (let i = 0; i < count; i++) {
			                    const engagement = this.get(keys[i]);
			                    retVal += engagement + '\n';
			                }
			            }
			        }
			        return retVal;
			    }
			}
			exports.EngagementMap = EngagementMap;
			(function (ToolbarLayout) {
			    ToolbarLayout["vertical"] = "LIVE_WINDOW";
			    ToolbarLayout["horizontal"] = "HORIZONTAL";
			    ToolbarLayout["redwood"] = "REDWOOD";
			})(exports.ToolbarLayout || (exports.ToolbarLayout = {}));
			class McaTokenMap {
			}
			exports.McaTokenMap = McaTokenMap;
			// MCA Business Object
			class BusinessObject {
			    constructor(name, objectId) {
			        this.tokenMap = new McaTokenMap();
			        const cd = new CacheControl('<DB>', oj_mca_common_1.McaCommon.getSessionId());
			        this.cacheControl = cd;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new BusinessObject(), obj);
			        o.cacheControl = CacheControl.fromJSON(o.cacheControl);
			        return o;
			    }
			    getId() {
			        return this.name;
			    }
			}
			exports.BusinessObject = BusinessObject;
			var ObjectChangeState;
			(function (ObjectChangeState) {
			    ObjectChangeState["loading"] = "loading";
			    ObjectChangeState["modified"] = "modified";
			    ObjectChangeState["complete"] = "complete";
			})(ObjectChangeState = exports.ObjectChangeState || (exports.ObjectChangeState = {}));
			class ObjectChange extends ItemChange {
			    constructor(objectName, state, type) {
			        super();
			        this.objectName = objectName;
			        this.state = state;
			        this.type = type;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new ObjectChange(), obj);
			        return o;
			    }
			    clear() {
			        delete this.objectName;
			        delete this.state;
			        this.type = DeltaType.none;
			    }
			    isChanged() {
			        let retVal = false;
			        if (this.state === ObjectChangeState.modified) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    toString() {
			        return ' objectName: ' + this.objectName + ' state: ' + this.state + ' type: ' + this.type;
			    }
			}
			exports.ObjectChange = ObjectChange;
			/**
			 * Cache Generic MCA Configuration Setting.  This was implemented to cache the Toolbar iFrame Load State for deferred toolbar
			 * loading.
			 */
			class ConfigItem {
			    constructor(name, value) {
			        const cd = new CacheControl('<MCA>', oj_mca_common_1.McaCommon.getSessionId());
			        this.cacheControl = cd;
			        this.name = name;
			        this.value = value;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new ConfigItem(), obj);
			        o.cacheControl = CacheControl.fromJSON(o.cacheControl);
			        return o;
			    }
			    getId() {
			        return this.name;
			    }
			}
			exports.ConfigItem = ConfigItem;
			class ConfigItemChange extends ItemChange {
			    constructor(name, type) {
			        super();
			        this.name = name;
			        this.type = type;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new ConfigItemChange(), obj);
			        return o;
			    }
			    clear() {
			        delete this.name;
			        this.type = DeltaType.none;
			    }
			    isChanged() {
			        let retVal = false;
			        if (this.name && (this.type === DeltaType.data || this.type === DeltaType.state)) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    toString() {
			        return ' name: ' + this.name + ' type: ' + this.type;
			    }
			}
			exports.ConfigItemChange = ConfigItemChange;
			class ConfigItemMap extends CacheMap {
			    constructor() {
			        super();
			    }
			    fromJSON(obj) {
			        const o = Object.assign(new ConfigItemMap(), obj);
			        o._lock = CacheLock.fromJSON(o._lock);
			        o._delta = ConfigItemChange.fromJSON(o._delta);
			        return o;
			    }
			    /**
			     * @override Base method and converts the result to a ConfigItem object
			     */
			    get(key) {
			        let configItem = super.get(key);
			        if (configItem) {
			            if (!(configItem instanceof ConfigItem)) {
			                configItem = ConfigItem.fromJSON(configItem);
			                super.put(key, configItem);
			            }
			        }
			        return configItem;
			    }
			    getDelta() {
			        return this._delta;
			    }
			    setDelta(delta) {
			        if (delta.type === DeltaType.none) {
			            delta.clear();
			        }
			        this._delta = delta;
			    }
			    toString() {
			        let retVal = 'ConfigItemMap: ';
			        if (this._items) {
			            const keys = this.keys();
			            if (keys) {
			                const count = keys.length;
			                retVal += 'Count: ' + count + '\n';
			                for (let i = 0; i < count; i++) {
			                    const configItem = this.get(keys[i]);
			                    retVal += configItem + '\n';
			                }
			            }
			        }
			        return retVal;
			    }
			}
			exports.ConfigItemMap = ConfigItemMap;
			(function (ConfigItemKeys) {
			    ConfigItemKeys["launchToolbar"] = "LAUNCH_TOOLBAR";
			})(exports.ConfigItemKeys || (exports.ConfigItemKeys = {}));
			/**
			 * Stores MCA Business Object - Token Mappings
			 */
			class ObjectMap extends CacheMap {
			    constructor() {
			        super();
			        this._lastUpdateTime = Date.now();
			        this._sessionId = oj_mca_common_1.McaCommon.getSessionId();
			    }
			    fromJSON(obj) {
			        const o = Object.assign(new ObjectMap(), obj);
			        o._lock = CacheLock.fromJSON(o._lock);
			        return o;
			    }
			    /**
			     * Overrides the base method and converts the result to a BusinessObject
			     * <TODO> NOT TESTED, IS THIS EVEN NECESSARY???
			     */
			    get(key) {
			        let businessObject = super.get(key);
			        if (businessObject) {
			            if (!(businessObject instanceof BusinessObject)) {
			                businessObject = BusinessObject.fromJSON(businessObject);
			                super.put(key, businessObject);
			            }
			        }
			        return businessObject;
			    }
			    getDelta() {
			        return this._delta;
			    }
			    setDelta(delta) {
			        if (delta.type === DeltaType.none) {
			            delta.clear();
			        }
			        this._delta = delta;
			    }
			}
			exports.ObjectMap = ObjectMap;
			(function (CloseCommReason) {
			    CloseCommReason["wrapup"] = "WRAPUP";
			    CloseCommReason["end"] = "ENDCOMMUNICATION";
			    CloseCommReason["error"] = "ERROR";
			    CloseCommReason["reject"] = "REJECT";
			    CloseCommReason["timeout"] = "TIMEDOUT";
			    CloseCommReason["abandoned"] = "ABANDONED";
			    CloseCommReason["missed"] = "MISSED";
			    CloseCommReason["canceled"] = "CANCELED";
			    CloseCommReason["transferred"] = "TRANSFERRED";
			})(exports.CloseCommReason || (exports.CloseCommReason = {}));
			(function (SubStatusCdDisplay) {
			    SubStatusCdDisplay["reject"] = "ORA_SVC_REJECTED";
			    SubStatusCdDisplay["timeout"] = "ORA_SVC_TIMEOUT";
			    SubStatusCdDisplay["abandoned"] = "ORA_SVC_ABANDONED";
			    SubStatusCdDisplay["missed"] = "ORA_SVC_MISSED";
			    SubStatusCdDisplay["canceled"] = "ORA_SVC_CANCELED";
			    SubStatusCdDisplay["transfered"] = "ORA_SVC_TRANSFERRED";
			    SubStatusCdDisplay["conference"] = "ORA_SVC_CONFERENCE";
			})(exports.SubStatusCdDisplay || (exports.SubStatusCdDisplay = {}));
			(function (PreviewCommMode) {
			    PreviewCommMode["manualMode"] = "MANUAL";
			    PreviewCommMode["outboundMode"] = "DIALING";
			})(exports.PreviewCommMode || (exports.PreviewCommMode = {}));
			(function (NotificationType) {
			    NotificationType["realtime"] = "REALTIME";
			    NotificationType["nonRealtime"] = "NON_REALTIME";
			})(exports.NotificationType || (exports.NotificationType = {}));
			(function (NotificationAssignType) {
			    NotificationAssignType["AUTO"] = "AUTO";
			    NotificationAssignType["FORCED"] = "FORCED";
			})(exports.NotificationAssignType || (exports.NotificationAssignType = {}));
			class NotificationManagerItem {
			    constructor(notificationEvent) {
			        this.method = notificationEvent.method;
			        this.assignType = notificationEvent.assignType;
			        this.notificationEventId = notificationEvent.notificationEventId;
			        this.notificationEngagementId = notificationEvent.notificationEngagementId;
			        this.notificationType = notificationEvent.notificationType;
			        this.notificationCategory = notificationEvent.notificationCategory;
			        if (notificationEvent.notificationViewable) {
			            this.notificationViewable = notificationEvent.notificationViewable;
			        }
			        else {
			            this.notificationViewable = 'N';
			        }
			        this.notificationIconTitle = notificationEvent.notificationIconTitle;
			        this.notificationTitle = notificationEvent.notificationTitle;
			        this.notificationTitlePlural = notificationEvent.notificationTitlePlural;
			        this.notificationSubtitle = notificationEvent.notificationSubtitle;
			        this.notificationStartTimestamp = notificationEvent.notificationStartTimestamp;
			        this.timeoutTimerLabel = notificationEvent.timeoutTimerLabel;
			        this.timeoutValue = notificationEvent.timeoutValue;
			        this.timerLabelPre = notificationEvent.timerLabelPre;
			        this.tooltip = notificationEvent.tooltip;
			        this.notificationEventSource = notificationEvent.notificationEventSource;
			        this.windowName = notificationEvent.windowName;
			        this.data = notificationEvent.data;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new NotificationManagerItem(), obj);
			        o.cacheControl = CacheControl.fromJSON(o.cacheControl);
			        return o;
			    }
			    getId() {
			        return this.notificationEventId;
			    }
			}
			exports.NotificationManagerItem = NotificationManagerItem;
			class NotificationMap extends CacheMap {
			    constructor() {
			        super();
			    }
			    fromJSON(obj) {
			        const o = Object.assign(new NotificationMap(), obj);
			        o._lock = CacheLock.fromJSON(o._lock);
			        o._delta = NotificationManagerItemChange.fromJSON(o._delta);
			        return o;
			    }
			    /**
			     * overrides the base method and converts the result to an Notification object
			     * <TODO> analyze performance impact of Notification creation
			     */
			    get(key) {
			        const notificationItem = super.get(key);
			        // if (notificationItem) {
			        //     if (!(notificationItem instanceof NotificationManagerItem)) {
			        //         notificationItem = NotificationManagerItem.fromJSON(notificationItem);
			        //         super.put(key, notificationItem);
			        //     }
			        // }
			        return notificationItem;
			    }
			    getDelta() {
			        return this._delta;
			    }
			    setDelta(delta) {
			        if (delta.type === DeltaType.none) {
			            delta.clear();
			        }
			        this._delta = delta;
			    }
			    toString() {
			        let retVal = 'NotificationMap: ';
			        if (this._items) {
			            const keys = this.keys();
			            if (keys) {
			                const count = keys.length;
			                retVal += 'Count: ' + count + '\n';
			                for (let i = 0; i < count; i++) {
			                    const notificationDetail = this.get(keys[i]);
			                    retVal += notificationDetail + '\n';
			                }
			            }
			        }
			        return retVal;
			    }
			}
			exports.NotificationMap = NotificationMap;
			class NotificationManagerItemChange extends ItemChange {
			    constructor(notificationId, windowName, type) {
			        super();
			        this.notificationItemId = notificationId;
			        this.windowName = windowName;
			        this.type = type;
			    }
			    static fromJSON(obj) {
			        const o = Object.assign(new NotificationManagerItemChange(), obj);
			        return o;
			    }
			    clear() {
			        delete this.notificationItemId;
			        this.type = DeltaType.none;
			    }
			    isChanged() {
			        let retVal = false;
			        if (this.notificationItemId && (this.type === DeltaType.data || this.type === DeltaType.state)) {
			            retVal = true;
			        }
			        return retVal;
			    }
			    toString() {
			        return ' notificationItemId: ' + this.notificationItemId + ', windowName: ' + this.windowName + ', type: ' + this.type;
			    }
			}
			exports.NotificationManagerItemChange = NotificationManagerItemChange;
			(function (OmniProfileOptionValues) {
			    OmniProfileOptionValues["none"] = "NONE";
			    OmniProfileOptionValues["all"] = "ALL";
			    OmniProfileOptionValues["chat"] = "CHAT";
			    OmniProfileOptionValues["nrt"] = "NON_REAL_TIME_WORK";
			})(exports.OmniProfileOptionValues || (exports.OmniProfileOptionValues = {}));
			(function (InvokeFetchUserConfigActions) {
			    InvokeFetchUserConfigActions["default"] = "DEFAULT";
			    InvokeFetchUserConfigActions["reloadChatConfig"] = "RELOAD_CHAT";
			    InvokeFetchUserConfigActions["renewJwt"] = "RENEW_JWT";
			})(exports.InvokeFetchUserConfigActions || (exports.InvokeFetchUserConfigActions = {}));
			(function (TranscriptState) {
			    TranscriptState["started"] = "STARTED";
			    TranscriptState["inprogress"] = "INPROGRESS";
			    TranscriptState["closed"] = "CLOSED";
			})(exports.TranscriptState || (exports.TranscriptState = {}));
			(function (CallType) {
			    CallType["consult"] = "INIT_CONSULT";
			    CallType["transfer"] = "INIT_TRANSFER";
			})(exports.CallType || (exports.CallType = {}));
			(function (TranscriptEntryType) {
			    TranscriptEntryType["WORK_JOIN"] = "WorkJoin";
			    TranscriptEntryType["WORK_JOIN_MONITOR"] = "WorkJoin_Monitor";
			    TranscriptEntryType["WORK_JOIN_CONFEREE"] = "WorkJoin_Conferee";
			    TranscriptEntryType["WORK_JOIN_COACH"] = "WorkJoin_Coach";
			    TranscriptEntryType["WORK_LEAVE"] = "WorkLeave";
			    TranscriptEntryType["WORK_LEAVE_MONITOR"] = "WorkLeave_Monitor";
			    TranscriptEntryType["WORK_LEAVE_CONFEREE"] = "WorkLeave_Conferee";
			    TranscriptEntryType["WORK_MESSAGE"] = "WorkMessage";
			    TranscriptEntryType["WORK_MESSAGE_LOCAL"] = "WorkMessageLocal";
			    TranscriptEntryType["SYSTEM_MESSAGE"] = "SYSTEM_MESSAGE";
			})(exports.TranscriptEntryType || (exports.TranscriptEntryType = {}));
			(function (SrTokenKeys) {
			    SrTokenKeys["incidentName"] = "incidentName";
			    SrTokenKeys["srNum"] = "srNum";
			    SrTokenKeys["SVCMCA_SR_NUM"] = "SVCMCA_SR_NUM";
			})(exports.SrTokenKeys || (exports.SrTokenKeys = {}));
			
		} (mcaCommonTypes));
		return mcaCommonTypes;
	}

	var mcaEngagementManager = {};

	var mcaAdfRestHelper = {};

	Object.defineProperty(mcaAdfRestHelper, "__esModule", { value: true });
	mcaAdfRestHelper.McaAdfRestHelper = void 0;
	const mca$a = requireMcaCommonTypes();
	const logger$3 = require$$0;
	class McaAdfRestHelper {
	    constructor(jwtToken) {
	        this.pre = '[McaAdfRestHelper] ';
	        this.renewTokenInitiated = false;
	        this.restCallsQueue = [];
	        this.updateJwtToken = (jwtToken) => {
	            this.jwtToken = jwtToken;
	            if (this.renewTokenInitiated) {
	                this.renewTokenInitiated = false;
	            }
	            while (this.restCallsQueue.length > 0) {
	                const pendingRestCall = this.restCallsQueue.shift();
	                if (pendingRestCall) {
	                    pendingRestCall();
	                    logger$3.info(`${this.pre} ===> Queued REST call`);
	                }
	            }
	        };
	        this.fetch = (url, options) => {
	            let jwtExpired = false;
	            if (this.jwtToken && this.jwtToken.split('.').length === 3) {
	                const payloadB64 = this.jwtToken.split('.')[1];
	                try {
	                    const payload = JSON.parse(window.atob(payloadB64));
	                    if (payload.exp && payload.exp <= Math.floor(Date.now() / 1000)) {
	                        jwtExpired = true;
	                        if (!this.renewTokenInitiated) {
	                            this.renewTokenInitiated = true;
	                            const formattedRenewEvent = { bubbles: true, cancelable: false, detail: {} };
	                            const customRenewEvent = new CustomEvent('mcaAdfRenewTkn', formattedRenewEvent);
	                            window.dispatchEvent(customRenewEvent);
	                        }
	                    }
	                    else {
	                        logger$3.info(`${this.pre} Token validity remaining ${payload.exp - Math.floor(Date.now() / 1000)}sec`);
	                    }
	                }
	                catch (error) {
	                    logger$3.error(`${this.pre} Error while checking token validity ${error}`);
	                }
	            }
	            let jwt = 'Bearer ' + this.jwtToken;
	            try {
	                const demoSeedJwt = localStorage.getItem(mca$a.Constants.DEMO_SEED_JWT);
	                if (demoSeedJwt) {
	                    jwt = 'Basic ' + demoSeedJwt;
	                }
	            }
	            catch (errSeedJwt) { }
	            if (options) {
	                options.headers = options.headers || {};
	                // tslint:disable-next-line: no-string-literal
	                options.headers['Authorization'] = jwt;
	            }
	            else {
	                options = {
	                    headers: {
	                        'Authorization': jwt
	                    },
	                    method: 'GET'
	                };
	            }
	            const fetchPromise = new Promise((resolve, reject) => {
	                const fetchExecute = () => {
	                    try {
	                        fetch(url, options).then((response) => {
	                            if (response.ok) {
	                                response.text().then((fetchBody) => {
	                                    resolve(fetchBody);
	                                });
	                            }
	                            else {
	                                logger$3.warn(`${this.pre}fetch failed with status: ${response.status}`);
	                                reject(JSON.stringify({ error: `Status: ${response.status}` }));
	                            }
	                        });
	                    }
	                    catch (fetchError) {
	                        logger$3.warn(`${this.pre}fetch failed with error: ${fetchError}`);
	                        reject(JSON.stringify({ error: `Reason: ${fetchError}` }));
	                    }
	                };
	                if (jwtExpired) {
	                    this.restCallsQueue.push(fetchExecute);
	                }
	                else {
	                    fetchExecute();
	                }
	            });
	            return fetchPromise;
	        };
	        this.jwtToken = jwtToken;
	    }
	    static getInstance(jwtToken) {
	        if (!McaAdfRestHelper.instance) {
	            McaAdfRestHelper.instance = new McaAdfRestHelper(jwtToken);
	        }
	        return McaAdfRestHelper.instance;
	    }
	}
	mcaAdfRestHelper.McaAdfRestHelper = McaAdfRestHelper;

	var mcaCacheManager = {};

	var __awaiter$9 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaCacheManager, "__esModule", { value: true });
	mcaCacheManager.CacheManager = void 0;
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	const mcaLogger_1$8 = requireMcaLogger();
	const mca$9 = requireMcaCommonTypes();
	const oj_mca_common_1$a = requireOjMcaCommon();
	/**
	 * Base Cache Management Class
	 */
	class McaCacheManager {
	    constructor(key, mapClass, desc, minSize, maxSize, expiration, appExtnObject) {
	        this.prefix = '[CacheMgr-';
	        this.minSize = McaCacheManager.MIN_SIZE;
	        this.maxSize = McaCacheManager.MAX_SIZE;
	        this.expiration = McaCacheManager.EXPIRE;
	        this.storageListener = (event) => {
	            if (!event.key && !event.newValue) {
	                // Assume the localStorage was cleared!
	                mcaLogger_1$8.McaLogger.warn(this.prefix + 'Detected Storage Delete!!!');
	                this.restoreCache(event);
	            }
	            if (!event[mca$9.Constants.MAPKEY] || event[mca$9.Constants.MAPKEY] !== this.key) {
	                return;
	            }
	            // 10/28/23 - Bug 35928993 - handle localStorage item delete 
	            if (!event.newValue) {
	                // For now just do this when the source is from a cx-sales page.  
	                if (event.url && event.url.includes('cx-sales')) {
	                    mcaLogger_1$8.McaLogger.warn(this.prefix + 'Detected Storage Removal for ' + event.key);
	                    this.restoreCache(event);
	                }
	            }
	            const map = this.map.fromJSON(JSON.parse(event[mca$9.Constants.NEW_VALUE]));
	            if (map.getLock().isLocked()) {
	                return;
	            }
	            const delta = map.getDelta();
	            if (!delta.isChanged()) {
	                return;
	            }
	            // 03/16/23 - The managers are now getting loaded in the toolbar window which should not be doing
	            // any  StorageEvent processing ...
	            if (window.name === mca$9.Constants.TOOLBAR_WINDOW) {
	                return;
	            }
	            mcaLogger_1$8.McaLogger.info(this.prefix + 'Detected Storage Update ...' + delta.toString());
	            this.cachedMapString = event.newValue;
	            this.processStorageEvent(map);
	        };
	        /**
	         * Restores the localStorage Map with a local copy.
	         * This is used if we detect the localStorage was cleared.
	         */
	        this.restoreCache = (event) => __awaiter$9(this, void 0, void 0, function* () {
	            if (!this.cachedMapString) {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Nothing to restore');
	                return; // nothing to restore
	            }
	            // TODO check the cachedMapString and make sure it actually contains items that should be restored...
	            const lock = this.getCacheLock();
	            if (lock.isLocked()) {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Ignoring restore, cache is already locked by another window');
	                return;
	            }
	            let map = this.getMap();
	            if (map.size() > 0) {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Ignoring restore, cache must have been restored by another window');
	                return; // map must have been restored via another window
	            }
	            map = yield this.checkOutMap();
	            // Check again after getting exclusive lock
	            if (map.size() > 0) {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Ignoring restore after lock, cache must have been restored by another window');
	                this.undoCheckOut(map);
	                return; // map must have been restored via another window
	            }
	            try {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Restoring map ' + this.key);
	                const reservedLock = map.getLock();
	                // overwrite the storage with our local map contents
	                const localMap = this.map.fromJSON(JSON.parse(this.cachedMapString));
	                localMap.setLock(reservedLock);
	                map = localMap;
	            }
	            catch (err) {
	                mcaLogger_1$8.McaLogger.warn(this.prefix + 'Error while restoring map: ' + err);
	            }
	            finally {
	                this.flushCache(map);
	            }
	        });
	        /**
	         * Because the listener is registered in this baseclass constructor which is invoked prior
	         * to the subclass loading we need to register this listener to forward the event
	         * to the subclass impl.
	         */
	        this.baseUnloadListener = (event) => {
	            this.unloadListener(event);
	        };
	        /**
	         * Retrieves an unsync'ed Read Only version of the Cached Map.
	         * If updates to the Map are required then the #checkOutMap method *MUST* be used to retrieve an exclusive lock.
	         *
	         * @param throwError - set to true if an error should be thrown, This is for the case this is called from
	         * the locking code.  So, the checkout loop may break.
	         */
	        this.getMap = (throwError) => {
	            let cacheMap = null;
	            try {
	                let cacheMapString = localStorage.getItem(this.key);
	                if (!cacheMapString) {
	                    mcaLogger_1$8.McaLogger.warn(this.prefix + 'CacheMap with key: ' + this.key + " doesn't exist");
	                    cacheMapString = '{}';
	                }
	                cacheMap = this.map.fromJSON(JSON.parse(cacheMapString));
	                const lock = this.getCacheLock();
	                cacheMap.setLock(lock);
	                if (throwError === true) {
	                    mcaLogger_1$8.McaLogger.info(this.prefix + 'Reading <--- Debug Cache Dump: items[' + cacheMap.size() + ']\n');
	                    // McaLogger.info(cacheMapString);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Error reading Cache');
	                mcaLogger_1$8.McaLogger.info(err);
	                if (throwError) {
	                    throw err;
	                }
	            }
	            return cacheMap;
	        };
	        /***
	         * Retrieves a synchronized Map for updating Cache Data.
	         *
	         * *NOTE*: This holds an exclusive lock on the Map; so it MUST BE RELEASED!!!
	         * Also, ensure there are no lenghty operations e.g. callbacks or async operations
	         * invoked while the lock is being held.
	         */
	        this.checkOutMap = () => __awaiter$9(this, void 0, void 0, function* () {
	            // DEV NOTE: The current implementation relies upon localStorage.
	            // Unfortunately, localStorage doesn't support truly synchronous operations
	            // across windows. Based upon observation each window has it's own local copy
	            // of the localStorage for a period of time. There doesn't appear to be a way
	            // to force the write to disk (or the ability to make the local window's copy of
	            // localStorage available immediately in other windows).
	            // Therefore although we use an approach here to "ensure" map lock exclusivity,
	            // this is only guranteed to work for writes within the current window.
	            // There are still no guarantees the updates made by this window won't get
	            // overwritten by another window.
	            //
	            // Also, note that the map and the lock are written to different localStorage
	            // variables.  This allows us to release the lock without any updates to the
	            // map.
	            let cacheMap = null;
	            const startTime = Date.now();
	            while (!cacheMap) {
	                try {
	                    cacheMap = this.getMap(true);
	                    // Perform a 2 Phase Lock
	                    let lock = this.getCacheLock();
	                    // Phase 1 Verify Map is Not Locked
	                    if (!lock || !lock.isLocked()) {
	                        lock = new mca$9.CacheLock(true);
	                        cacheMap.setLock(lock);
	                        const lockString = JSON.stringify(lock);
	                        // Phase 2 Update Cache and Verify the Lock is the Same
	                        localStorage.setItem(this.key + '-l', lockString);
	                        const dclLock = this.getCacheLock();
	                        if (lock.equals(dclLock)) {
	                            // McaLogger.warn("verified lock!!!");
	                        }
	                        else {
	                            // Leave Current Lock In Place ...
	                            mcaLogger_1$8.McaLogger.warn(this.prefix + 'Cache is already locked, waiting ...');
	                            cacheMap = null;
	                            yield oj_mca_common_1$a.McaCommon.sleep(5);
	                            continue;
	                        }
	                        this.lock = lock;
	                        mcaLogger_1$8.McaLogger.info(this.prefix + 'Locked Cache: ' + lock.id);
	                    }
	                    else {
	                        mcaLogger_1$8.McaLogger.info(this.prefix + 'Waiting on Cache Lock ...');
	                        cacheMap = null;
	                        yield oj_mca_common_1$a.McaCommon.sleep(5);
	                    }
	                    if (!cacheMap) {
	                        const currTime = Date.now();
	                        if (currTime - startTime > McaCacheManager.MAX_LOCK_WAIT) {
	                            mcaLogger_1$8.McaLogger.error(this.prefix + 'Timeout Detetected waiting Cache Lock, stealing the map!');
	                            cacheMap = this.getMap(true);
	                        }
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$8.McaLogger.error(this.prefix + 'Error Locking Cache');
	                    mcaLogger_1$8.McaLogger.error(err);
	                    // ensure we release our temp lock before we exit!!!
	                    this.forceRelease(cacheMap);
	                    break;
	                }
	            }
	            return cacheMap;
	        });
	        /**
	         * Force Releases the Cache Map Lock.
	         * @param map -  optional map to be released.
	         */
	        this.forceRelease = (map) => {
	            if (!map) {
	                map = this.getMap();
	            }
	            mcaLogger_1$8.McaLogger.warn(this.prefix + 'forceRelease: Cache Lock');
	            this.undoCheckOut(map, true);
	        };
	        /**
	         * Use this to undo a map checkout without performing any map manipulations!
	         * @param - map - checked out map
	         * @param - forceUnlock - Force removes the lock owned by another.
	         */
	        this.undoCheckOut = (map, forceUnlock) => {
	            mcaLogger_1$8.McaLogger.info(this.prefix + 'undoCheckOut');
	            try {
	                const lock = map.getLock();
	                const currLock = this.getCacheLock();
	                if (!currLock.isLocked()) {
	                    mcaLogger_1$8.McaLogger.info(this.prefix + 'Map is not locked, ignoring undoCheckOut');
	                    return;
	                }
	                if (!lock.equals(currLock)) {
	                    if (forceUnlock) {
	                        mcaLogger_1$8.McaLogger.warn(this.prefix + 'undoCheckOut, Force Removing locked owned by another process!!!');
	                    }
	                    else {
	                        mcaLogger_1$8.McaLogger.warn(this.prefix + 'undoCheckOut, Ignoring because map locked by another window');
	                        return;
	                    }
	                }
	                const dbgLock = lock.id;
	                lock.clear();
	                const lockString = JSON.stringify(lock);
	                localStorage.setItem(this.key + '-l', lockString);
	                this.lock = null;
	                map.setLock(null); // ensure consumers are aware this map is no longer locked
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'Unlocked Cache: ' + dbgLock);
	            }
	            catch (err) {
	                mcaLogger_1$8.McaLogger.error(this.prefix + 'Error undoCheckOut!');
	                mcaLogger_1$8.McaLogger.error(err);
	            }
	        };
	        /**
	         * Checks to ensure the map lock matches the current lock.
	         * If so, write the contents of the map to cache.
	         * The map lock is released so, this map may no longer be used for cache updates.  Further cache
	         * updates will require a new checkout.
	         */
	        this.flushCache = (map, forceFlush) => {
	            if (!map) {
	                return;
	            }
	            const lock = map.getLock();
	            if ((!lock || !lock.id || !this.lock || this.lock.id !== lock.id) && !forceFlush) {
	                throw new Error('Attempting to flush Cache without a lock!');
	            }
	            else {
	                const tmp = this.getMap();
	                const tmpLock = tmp.getLock();
	                if (!lock.equals(tmpLock)) {
	                    mcaLogger_1$8.McaLogger.error(this.prefix + 'Cache lock was hi-jacked by: ' + tmpLock.id + ' window: ' + tmpLock.winName);
	                }
	            }
	            const dbgLock = lock.id;
	            lock.clear();
	            const mapString = JSON.stringify(map);
	            this.cachedMapString = mapString;
	            mcaLogger_1$8.McaLogger.info(this.prefix + 'Flushing --> Debug Cache Dump ' + this.key + ' items [' + map.size() + ']\n');
	            // McaLogger.info(mapString);
	            const lockString = JSON.stringify(lock);
	            localStorage.setItem(this.key, mapString);
	            localStorage.setItem(this.key + '-l', lockString);
	            this.lock = null;
	            map.setLock(null); // ensure consumers are aware this map is no longer locked
	            mcaLogger_1$8.McaLogger.info(this.prefix + 'Unlocked Cache: ' + dbgLock);
	        };
	        /**
	         * Checks and marks any expired items for deletion.
	         */
	        this.checkExpiredItem = (item, currentTime) => {
	            if (item.cacheControl.deletedFlag === mca$9.Constants.YES_FLAG) {
	                return; // already marked
	            }
	            if (item.cacheControl.sessionId) ;
	            if (currentTime - item.cacheControl.createTime > this.expiration) {
	                mcaLogger_1$8.McaLogger.warn(this.prefix + 'Expiring item: ' + item.getId());
	                item.cacheControl.deletedFlag = mca$9.Constants.YES_FLAG;
	                item.cacheControl.unloadTime = currentTime;
	            }
	        };
	        /**
	         * Sub-Classes may override if any outstanding events related to the item to be purged require processing.
	         * @returns false if the item should not be purged
	         */
	        this.purgeItem = (item) => {
	            const retVal = true;
	            return retVal;
	        };
	        /*
	         * Removes engagements marked for deletion from cache.
	         */
	        this.purgeCache = (map) => {
	            if (!map) {
	                return;
	            }
	            const size = map.size();
	            if (size >= this.maxSize) {
	                // tslint:disable-next-line: typedef
	                const sortable = [];
	                const ct = Date.now();
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'purgeCache: cleaning required');
	                const keys = map.keys();
	                for (const key of keys) {
	                    const item = map.get(key);
	                    if (!item) {
	                        continue;
	                    }
	                    this.checkExpiredItem(item, ct);
	                    if (item.cacheControl.deletedFlag !== mca$9.Constants.YES_FLAG) {
	                        continue;
	                    }
	                    else {
	                        sortable.push([key, item.cacheControl.unloadTime]);
	                    }
	                }
	                // tslint:disable-next-line: typedef
	                sortable.sort(function (a, b) {
	                    return a[1] - b[1];
	                });
	                const deleteSize = sortable.length - this.minSize;
	                for (let j = 0; j < deleteSize; j++) {
	                    const item = map.get(sortable[j][0]);
	                    if (!this.purgeItem(item)) ;
	                    map.remove(sortable[j][0]);
	                }
	                mcaLogger_1$8.McaLogger.info(this.prefix + 'purgeCache: removed ' + deleteSize + ' from cache');
	            }
	        };
	        /**
	         * Returns a RestHelper extensionObject for VB Unified App UI support
	         * null is returned if this app does not support the VB Unified App UI
	         */
	        this.getAppExtnObject = () => {
	            let retVal = this.appExtnObject;
	            if (!(retVal && retVal.extensionId && retVal.extensionId.trim().length > 0)) {
	                retVal = null;
	            }
	            return retVal;
	        };
	        this.getCacheLock = () => {
	            let lockString = localStorage.getItem(this.key + '-l');
	            if (!lockString) {
	                lockString = '{}';
	            }
	            const lock = mca$9.CacheLock.fromJSON(JSON.parse(lockString));
	            return lock;
	        };
	        this.initialize = () => {
	            mcaLogger_1$8.McaLogger.info(this.prefix + 'Initializing ...');
	            window.addEventListener(mca$9.McaEventType.unloadHandling, this.baseUnloadListener);
	            window.addEventListener('storage', this.storageListener, false);
	            const map = this.getMap();
	            const lock = map.getLock();
	            if (lock && lock.winName === window.name) {
	                mcaLogger_1$8.McaLogger.warn(this.prefix + 'Detected preexisting lock during initialization ' + window.name);
	                this.undoCheckOut(map);
	            }
	            // <TODO> check if any events need re-handled e.g. notifications
	            // also check if we need to purge our engagementMap...
	        };
	        this.key = key;
	        this.map = mapClass;
	        this.prefix += desc += '] ';
	        if (minSize) {
	            this.minSize = minSize;
	        }
	        if (maxSize) {
	            this.maxSize = maxSize;
	        }
	        if (expiration) {
	            this.expiration = expiration;
	        }
	        if (appExtnObject) {
	            this.appExtnObject = appExtnObject;
	        }
	        this.initialize();
	    }
	}
	mcaCacheManager.CacheManager = McaCacheManager;
	McaCacheManager.MAX_LOCK_WAIT = 1000 * 2; // MAX Time to Wait for obtaining a Cache Lock
	McaCacheManager.MAX_SIZE = 3000;
	McaCacheManager.MIN_SIZE = 0;
	McaCacheManager.EXPIRE = 1000 * 60 * 60 * 12; // Item Expiration Time - 12 Hours

	var __awaiter$8 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaEngagementManager, "__esModule", { value: true });
	mcaEngagementManager.EngagementManager = void 0;
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	const mca_adf_rest_helper_1$1 = mcaAdfRestHelper;
	const mcaLogger_1$7 = requireMcaLogger();
	const mca_cache_manager_1$2 = mcaCacheManager;
	const mca$8 = requireMcaCommonTypes();
	const oj_mca_common_1$9 = requireOjMcaCommon();
	const restHelper$1 = require$$5;
	class EngagementManager extends mca_cache_manager_1$2.CacheManager {
	    constructor(appExtnObject) {
	        super(EngagementManager.NAME, new mca$8.EngagementMap(), EngagementManager.desc, EngagementManager.MIN_CACHE_SIZE, EngagementManager.MAX_ENGAGEMENTS, EngagementManager.ENGAGEMENT_EXPIRATION, appExtnObject);
	        this.pre = '[EngagementManager] ';
	        this.eventTargetMap = new Map();
	        this.responseTargetMap = new Map();
	        this.responseWaiters = [];
	        this.isVbEnabled = true;
	        this.getUnknownCallerPageFromEngagement = (engagement) => {
	            const response = engagement.responseMap[mca$8.McaMethod.startComm];
	            if (response && response.actions) {
	                for (let i = 0; i < response.actions.length; i++) {
	                    const action = response.actions[i];
	                    if (!action || !action.name) {
	                        continue;
	                    }
	                    if (action.name === mca$8.ActionName.UnknownCallerPageInfo) {
	                        return action;
	                    }
	                }
	                return null;
	            }
	            else {
	                return null;
	            }
	        };
	        this.getCreateContactPageFromEngagement = (engagement) => {
	            const response = engagement.responseMap[mca$8.McaMethod.startComm];
	            if (response && response.actions) {
	                for (let i = 0; i < response.actions.length; i++) {
	                    const action = response.actions[i];
	                    if (!action || !action.name) {
	                        continue;
	                    }
	                    if (action.name === mca$8.ActionName.CreateContactPageInfo) {
	                        return action;
	                    }
	                }
	                return null;
	            }
	            else {
	                return null;
	            }
	        };
	        this.getCreateLeadPageFromEngagement = (engagement) => {
	            const response = engagement.responseMap[mca$8.McaMethod.startComm];
	            if (response && response.actions) {
	                for (let i = 0; i < response.actions.length; i++) {
	                    const action = response.actions[i];
	                    if (!action || !action.name) {
	                        continue;
	                    }
	                    if (action.name === mca$8.ActionName.CreateLeadPageInfo) {
	                        return action;
	                    }
	                }
	                return null;
	            }
	            else {
	                return null;
	            }
	        };
	        /**
	         * Called at the conclusion of Wrap Up/WrapUp to set the Engagement to Complete
	         * This must be called to ensure we don't continue to reload the Engagement Component in WrapUp Mode
	         * following page refresh.
	         */
	        this.setEngagementComplete = (engagementId) => __awaiter$8(this, void 0, void 0, function* () {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'setEngagementComplete ' + engagementId);
	            const stateChange = {};
	            stateChange.method = mca$8.McaMethod.closeComm;
	            stateChange.state = mca$8.EventState.complete;
	            const delta = new mca$8.EngagementChange(engagementId, stateChange, mca$8.DeltaType.data);
	            const map = yield this.checkOutMap();
	            // Now we are in lock scope ...
	            let writeMap = false;
	            try {
	                const engagement = map.get(engagementId);
	                if (!engagement) {
	                    mcaLogger_1$7.McaLogger.warn(this.pre + 'Engagement not found in map for setEngagementComplete: ');
	                }
	                else {
	                    const startCommEvent = engagement.responseMap[mca$8.McaMethod.startComm];
	                    if (startCommEvent && startCommEvent.actions) {
	                        for (let i = 0; i < startCommEvent.actions.length; i++) {
	                            const action = startCommEvent.actions[i];
	                            if (action && action.name === mca$8.ActionName.WrapUp) {
	                                startCommEvent.actions.splice(i, 1);
	                                writeMap = true;
	                                break;
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'setEngagementComplete error ' + err);
	            }
	            if (writeMap) {
	                map.setDelta(delta);
	                this.flushCache(map);
	            }
	            else {
	                this.undoCheckOut(map);
	            }
	        });
	        /***
	         * Add Client Action to Engagement
	         */
	        this.addClientActionToEngagement = (engagement, action) => __awaiter$8(this, void 0, void 0, function* () {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'addClientActionToEngagement, action name is ' + action.name);
	            const stateChange = {};
	            stateChange.method = mca$8.McaMethod.startComm;
	            stateChange.state = mca$8.EventState.complete;
	            const delta = new mca$8.EngagementChange(engagement.engagementId, stateChange, mca$8.DeltaType.data);
	            const map = yield this.checkOutMap();
	            // Now we are in lock scope ...
	            try {
	                let mapEngagement = map.get(engagement.engagementId);
	                if (!mapEngagement) {
	                    mcaLogger_1$7.McaLogger.error(this.pre +
	                        'Engagement not found in map for addClientActionToEngagement: ' +
	                        engagement.engagementId);
	                    mapEngagement = engagement;
	                    map.put(engagement.engagementId, engagement); // should we add it back
	                }
	                engagement = mapEngagement;
	                const response = engagement.responseMap[mca$8.McaMethod.startComm];
	                if (action.name === mca$8.ActionName.SearchContact) {
	                    // Add the new action to the startCommEvent
	                    if (response.actions) {
	                        response.actions.push(action);
	                    }
	                    else {
	                        response.actions = [action];
	                    }
	                }
	                else if (action.name === mca$8.ActionName.VerifyContact) {
	                    // remove VerifyContact action from the startCommEvent, add ContactVerified action to startCommEvent
	                    // add this section to fix engagement reloading issue after contact is verified
	                    let aa = null;
	                    for (const actionItem of response.actions) {
	                        if (actionItem.name !== action.name) {
	                            if (actionItem.name === mca$8.ActionName.ScreenPop) {
	                                aa = this.addAction(aa, mca$8.ActionName.ScreenPop, actionItem.data);
	                            }
	                        }
	                        else {
	                            aa = this.addAction(aa, mca$8.ActionName.ContactVerified);
	                            // Add token SVCMCA_BYPASS_CUSTOMER_VERIFICATION to avoid being verified again
	                            response.outData[mca$8.SystemToken.bypassCustomerVerification] = 'Y';
	                        }
	                    }
	                    response.actions = aa;
	                }
	                else if (action.name === mca$8.ActionName.WrapUp) {
	                    // remove ContactVerified action from the startCommEvent, add WrapUp action to startCommEvent
	                    // add this section to fix engagement reloading issue for wrapup
	                    // this fix is for inbound calls. Outbound calls does not have response.actions defined
	                    let aa = null;
	                    for (const actionItem of response.actions) {
	                        if (actionItem.name === mca$8.ActionName.ScreenPop) {
	                            aa = this.addAction(aa, mca$8.ActionName.ScreenPop, actionItem.data);
	                            break;
	                        }
	                    }
	                    aa = this.addAction(aa, mca$8.ActionName.WrapUp);
	                    response.actions = aa;
	                }
	                const previousState = mapEngagement.stateMap[stateChange.method];
	                if (previousState === stateChange.state) {
	                    mcaLogger_1$7.McaLogger.warn(this.pre +
	                        'Engagement seems to have already been completed: ' +
	                        engagement.engagementId +
	                        ' : ' +
	                        stateChange.method);
	                }
	                map.setDelta(delta);
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre +
	                    'Exception in addClientAction: ' +
	                    err +
	                    ' engagement: ' +
	                    engagement.engagementId);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            finally {
	                this.flushCache(map);
	            }
	            mcaLogger_1$7.McaLogger.info(this.pre + 'addClientActionToEngagement leaving');
	        });
	        /***
	         * Add MCA Client State to Engagement Data for Browser Refresh Handling
	         */
	        this.addTokensToEngagement = (engagementId, tokens) => __awaiter$8(this, void 0, void 0, function* () {
	            if ((!tokens || Object.keys(tokens).length <= 0) || !engagementId) {
	                mcaLogger_1$7.McaLogger.warn(`${this.pre}Missing args addTokensToEngagement engagementId ${engagementId}`);
	                return;
	            }
	            mcaLogger_1$7.McaLogger.info(this.pre + 'addTokensToEngagement ' + engagementId);
	            const tmpMap = this.getMap();
	            if (!tmpMap.has(engagementId)) {
	                mcaLogger_1$7.McaLogger.warn(`${this.pre}Engagement not found in map for addTokensToEngagement ${engagementId}`);
	                return;
	            }
	            const stateChange = {};
	            stateChange.method = mca$8.McaMethod.startComm;
	            stateChange.state = mca$8.EventState.complete;
	            const delta = new mca$8.EngagementChange(engagementId, stateChange, mca$8.DeltaType.none);
	            const map = yield this.checkOutMap();
	            // Now we are in lock scope ...
	            let doFlushCache = false;
	            try {
	                const engagement = map.get(engagementId);
	                if (!engagement) {
	                    mcaLogger_1$7.McaLogger.warn(`${this.pre}Engagement not found in synced map for addTokensToEngagement ${engagementId}`);
	                    return;
	                }
	                const response = engagement.responseMap[mca$8.McaMethod.startComm];
	                if (!response) {
	                    mcaLogger_1$7.McaLogger.warn(this.pre + 'Engagement response not found in addTokensToEngagement: ' + engagementId);
	                    return;
	                }
	                const inTokens = Object.keys(tokens);
	                for (const token of inTokens) {
	                    response.outData[token] = tokens[token];
	                }
	                map.setDelta(delta);
	                doFlushCache = true;
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(`${this.pre}Exception in addTokensToEngagement engagementId ${engagementId} ${err}`);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            finally {
	                if (!doFlushCache) {
	                    this.undoCheckOut(map);
	                }
	                else {
	                    this.flushCache(map);
	                }
	            }
	            mcaLogger_1$7.McaLogger.info(`${this.pre}addTokensToEngagement ${engagementId} leaving`);
	        });
	        this.updateTranscriptReadyStatusToEngagement = (engagementId, isReady) => __awaiter$8(this, void 0, void 0, function* () {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'updateTranscriptReadyStatusToEngagement to engagement ' + engagementId);
	            let writeMap = false;
	            const map = yield this.checkOutMap();
	            try {
	                const mapEngagement = map.get(engagementId);
	                if (mapEngagement) {
	                    const stateChange = {};
	                    stateChange.state = mca$8.EventState.complete;
	                    const delta = new mca$8.EngagementChange(mapEngagement.engagementId, stateChange, mca$8.DeltaType.none);
	                    mapEngagement.transcriptReadyStatus = isReady;
	                    map.setDelta(delta);
	                    writeMap = true;
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre +
	                    'Exception in updateTranscriptReadyStatusToEngagement: ' +
	                    err +
	                    ' engagement: ' +
	                    engagementId);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            finally {
	                if (writeMap) {
	                    this.flushCache(map);
	                }
	                else {
	                    this.undoCheckOut(map);
	                }
	            }
	            mcaLogger_1$7.McaLogger.info(this.pre + 'updateTranscriptReadyStatusToEngagement leaving');
	        });
	        /**
	         * Handle events generated from another window.
	         */
	        this.processStorageEvent = (map) => {
	            const delta = (map) ? map.getDelta() : null;
	            const engagement = map.get(delta.engagementId);
	            if (!engagement || delta == null || delta.state == null || engagement.eventMap == null) {
	                mcaLogger_1$7.McaLogger.warn(this.pre + 'No engagement found for storageEvent: ' + delta.toString());
	                return;
	            }
	            // <TODO> To improve the localStorage access performance check if the events and responses can be stored in indexedDB...
	            let event = engagement.eventMap[delta.state.method];
	            if (!event && delta && delta.state.eventMapKey) {
	                event = engagement.eventMap[delta.state.eventMapKey];
	            }
	            switch (delta.state.state) {
	                case mca$8.EventState.complete:
	                    const response = engagement.responseMap[delta.state.method];
	                    if (!response) {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + 'No response found for storageEvent: ' + delta.toString());
	                        break;
	                    }
	                    // 11-26-23 Ignoring Data Update Storage Events
	                    if (delta.type === mca$8.DeltaType.data || delta.type === mca$8.DeltaType.none) {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + 'Ignoring storageEvent for Data Update: ' + delta.toString());
	                        break;
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + '<TODO> OPTIMIZE the processStorageEvent!');
	                        // sjmD <TODO> We can probably ignore these storage events unless this is one of the following 3 windows:
	                        // focused window
	                        // primary window
	                        // event's engagement window
	                    }
	                    // since each event is only processed in a single window,
	                    // we must ensure the response is propagated and handled appropriately in all windows
	                    this.deliverResponse(response, event);
	                    // check if any pending events need processed...
	                    const pendingEvent = this.checkForPendingEvent(engagement);
	                    if (pendingEvent) {
	                        this.processEvent(pendingEvent);
	                    }
	                    break;
	                case mca$8.EventState.process:
	                    // Handle Event Preprocessing Actions in this window:
	                    switch (delta.state.method) {
	                        case mca$8.McaMethod.newComm:
	                            this.preProcessNewComm(engagement, delta.state, event);
	                            break;
	                        case mca$8.McaMethod.startComm:
	                            this.preProcessStartComm(engagement, delta.state);
	                            break;
	                        case mca$8.McaMethod.closeComm:
	                            this.preProcessCloseComm(engagement, delta.state);
	                            break;
	                        case mca$8.McaMethod.updateComm:
	                            this.preProcessUpdateComm(engagement, delta.state, event);
	                            break;
	                        case mca$8.McaMethod.getScreenPopDataEvent:
	                            this.preProcessGetScreenPopDataEvent(engagement, delta.state, event);
	                            break;
	                        default:
	                            mcaLogger_1$7.McaLogger.info(this.pre + 'no preprocessing required for storageEvent: ' + delta.toString());
	                            break;
	                    }
	                    this.deliverEvent(event);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'No action required for storageEvent: ' + delta.toString());
	                    break;
	            }
	        };
	        /**
	         * @override
	         */
	        this.purgeItem = (item) => {
	            const retVal = true;
	            const engagement = item;
	            if (this.responseWaiters) {
	                for (let i = 0; i < this.responseWaiters.length; i++) {
	                    const event = this.responseWaiters[i];
	                    if (event) {
	                        if (engagement.engagementId === event.data.engagementId) {
	                            mcaLogger_1$7.McaLogger.info(this.pre +
	                                'purgeCache: found undelivered response for event: ' +
	                                engagement.engagementId +
	                                ' : ' +
	                                event.method);
	                            const response = this.manufactureResponse(event, engagement);
	                            this.deliverResponse(response, event);
	                            this.responseWaiters.splice(i, 1); // delete
	                        }
	                    }
	                }
	            }
	            return retVal;
	        };
	        this.unloadListener = () => {
	            if (this.lock) {
	                mcaLogger_1$7.McaLogger.info(this.pre + 'Detected Unload with lock ...' + window.name);
	                const map = this.getMap();
	                this.forceRelease(map);
	            }
	        };
	        this.createEngagement = (event, map) => {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'Creating new Engagement for event: ');
	            const engagement = new mca$8.Engagement(event);
	            if (!engagement || engagement.cacheControl === undefined) {
	                mcaLogger_1$7.McaLogger.warn(this.pre + 'createEngagement: missing engagement!');
	                return;
	            }
	            engagement.cacheControl.createTime = Date.now();
	            if (this.pendingOutbound) {
	                let removeOutbound = false;
	                if (mca$8.McaMethod.outboundError === event.data.origMethod) {
	                    removeOutbound = true;
	                }
	                else if (event.data.inData && event.data.inData[mca$8.SystemToken.callId]) {
	                    if (this.pendingOutbound.uuid === event.data.inData[mca$8.SystemToken.callId]) {
	                        removeOutbound = true;
	                    }
	                }
	                if (removeOutbound) {
	                    engagement.windowName = this.pendingOutbound.windowName;
	                    engagement.data.inData[mca$8.SystemToken.direction] = mca$8.DirectionToken.outbound;
	                    this.pendingOutbound = null;
	                }
	                else {
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'Received an event that did not match the pending outbound call: ' + this.pendingOutbound.uuid, event);
	                }
	            }
	            map.put(engagement.engagementId, engagement);
	            return engagement;
	        };
	        /**
	         * Reprocess the event after retrieving an exclusive lock.
	         * 1. Ensures the event wasn't already processed by another window.
	         * 2. Centralizes/ensures lock release
	         */
	        this.dclProcessEvent = (event) => __awaiter$8(this, void 0, void 0, function* () {
	            const engagementId = event.data.engagementId;
	            if (!engagementId) {
	                mcaLogger_1$7.McaLogger.warn(this.pre + 'dclProcessEvent: missing engagementId!');
	                return;
	            }
	            const map = yield this.checkOutMap();
	            let stateChange = {};
	            let stateMap = new mca$8.McaEventStateMap();
	            let engagement = map.get(event.data.engagementId);
	            if (event.data.channelType === mca$8.ChannelType.chat) {
	                engagement = this.getActiveEngagementByEventId(map, event.data.eventId);
	                if (engagement) {
	                    event.data.engagementId = engagement.engagementId;
	                    mcaLogger_1$7.McaLogger.warn(`${this.pre} processEvent: existing engagement id : ${event.data.engagementId} for event method :${event.method}`);
	                }
	                else if (event.method === mca$8.McaMethod.closeComm) {
	                    // engagement not found when the close comm is already processed
	                    this.undoCheckOut(map);
	                    return;
	                }
	                else if (event.method === mca$8.McaMethod.updateComm && !engagement) {
	                    // for handling updatecomm after wrapup
	                    const latestEngagement = this.getLatestEngagementByEventId(event.data.eventId);
	                    engagement = map.get(latestEngagement.engagementId);
	                }
	                else {
	                    if (event.data.engagementId === event.data.eventId) {
	                        event.data.engagementId = event.data.engagementId + '_' + Date.now();
	                        mcaLogger_1$7.McaLogger.warn(`${this.pre} processEvent: new engagement id : ${event.data.engagementId} for event method :${event.method}`);
	                    }
	                    // else we use the engagement id that mercury client library computes                
	                }
	            }
	            try {
	                if (engagement) {
	                    stateMap = engagement.stateMap;
	                }
	                const method = event.method;
	                let eventMapKey = event.method;
	                if (method === mca$8.McaMethod.updateComm) {
	                    if (event.data.inData[mca$8.Constants.EVENT_MAP_KEY]) {
	                        eventMapKey = event.data.inData[mca$8.Constants.EVENT_MAP_KEY];
	                    }
	                    else {
	                        const ticket = engagement.getTicketNum();
	                        eventMapKey = method + '_' + ticket;
	                        event.data.inData[mca$8.Constants.EVENT_MAP_KEY] = eventMapKey;
	                    }
	                }
	                if (method === mca$8.McaMethod.getScreenPopDataEvent) {
	                    if (event.data.inData[mca$8.Constants.EVENT_MAP_KEY]) {
	                        eventMapKey = event.data.inData[mca$8.Constants.EVENT_MAP_KEY];
	                    }
	                    else {
	                        eventMapKey = method + '_' + event.data.eventId;
	                        event.data.inData[mca$8.Constants.EVENT_MAP_KEY] = eventMapKey;
	                    }
	                }
	                let primaryState = stateMap[eventMapKey];
	                if (!primaryState) {
	                    primaryState = mca$8.EventState.start;
	                    stateMap[eventMapKey] = primaryState;
	                }
	                stateChange.method = event.method;
	                stateChange.state = primaryState;
	                let changeType = mca$8.DeltaType.state;
	                if (!engagement) {
	                    engagement = this.createEngagement(event, map);
	                    engagement.stateMap = stateMap;
	                }
	                switch (event.method) {
	                    case mca$8.McaMethod.getCustomerData:
	                        switch (primaryState) {
	                            case mca$8.EventState.start:
	                                engagement.lastEvent = event; // fall thru
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessGetCustomerData(engagement, stateChange)) {
	                                    engagement.eventMap[mca$8.McaMethod.getCustomerData] = event;
	                                    this.processGetCustomerData(engagement, stateChange, event);
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                break;
	                        }
	                        break;
	                    case mca$8.McaMethod.newComm:
	                        const closeCommState = engagement.stateMap[mca$8.McaMethod.closeComm];
	                        switch (primaryState) {
	                            case mca$8.EventState.complete:
	                                if (!closeCommState) {
	                                    break;
	                                } // else this state must be for a previous instance of this same engagement, force recreation
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.start:
	                                if (closeCommState) {
	                                    // Theoretically we should NEVER get the same engagement sent to us twice.  But, as we've seen with
	                                    // oracle chat the same engagementId is used for ALL connections to a visitor chat session.
	                                    mcaLogger_1$7.McaLogger.warn(this.pre +
	                                        'force removing engagement, newComm detected after closeComm: ' +
	                                        engagementId);
	                                    if (closeCommState === mca$8.EventState.start || closeCommState === mca$8.EventState.wait) {
	                                        mcaLogger_1$7.McaLogger.warn(this.pre + 'Even worse the closeComm was NOT processed: ' + engagementId);
	                                        // Don't waste the effort of force sending the previous closeComm. Assume IH can handle the dangling interaction.
	                                    }
	                                    map.remove(engagementId);
	                                    engagement = this.createEngagement(event, map);
	                                    engagement.stateMap = new mca$8.McaEventStateMap();
	                                    engagement.stateMap[mca$8.McaMethod.newComm] = mca$8.EventState.start;
	                                    stateChange.state = mca$8.EventState.start;
	                                }
	                                engagement.lastEvent = event; // fall thru
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessNewComm(engagement, stateChange, event)) {
	                                    this.processNewComm(engagement, stateChange, event);
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                break;
	                        }
	                        break;
	                    case mca$8.McaMethod.startComm:
	                        switch (primaryState) {
	                            case mca$8.EventState.start:
	                                engagement.lastEvent = event; // fall thru
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessStartComm(engagement, stateChange)) {
	                                    engagement.eventMap[mca$8.McaMethod.startComm] = event;
	                                    this.processStartComm(engagement, stateChange, event);
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                // 10-20-21 - the mca.EventState.complete events should only come from restResponseHandler
	                                // we should probably do this for all events
	                                mcaLogger_1$7.McaLogger.warn(this.pre + 'processEvent: ignoring: ' + event.method + ' for state: ' + primaryState);
	                                changeType = mca$8.DeltaType.none;
	                                stateChange = null;
	                                break;
	                        }
	                        break;
	                    case mca$8.McaMethod.closeComm:
	                        switch (primaryState) {
	                            case mca$8.EventState.start:
	                                engagement.lastEvent = event; // fall thru
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessCloseComm(engagement, stateChange)) {
	                                    engagement.eventMap[mca$8.McaMethod.closeComm] = event;
	                                    this.processCloseComm(engagement, stateChange, event);
	                                    this.purgeCache(map); // TODO Potential PSR ER maybe we should do this async at another time...
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                break;
	                        }
	                        break;
	                    case mca$8.McaMethod.updateComm:
	                        if (!this.preProcessUpdateComm(engagement, stateChange, event)) {
	                            changeType = mca$8.DeltaType.none;
	                            stateChange = null;
	                        }
	                        else {
	                            this.processUpdateComm(engagement, stateChange, event);
	                            stateChange.eventMapKey = eventMapKey;
	                            engagement.eventMap[eventMapKey] = event;
	                        }
	                        break;
	                    case mca$8.McaMethod.getScreenPopDataEvent:
	                        switch (primaryState) {
	                            case mca$8.EventState.start:
	                                engagement = this.createEngagement(event, map);
	                                engagement.stateMap = stateMap;
	                                engagement.lastEvent = event;
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessGetScreenPopDataEvent(engagement, stateChange, event)) {
	                                    this.processGetScreenPopDataEvent(engagement, stateChange, event);
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                break;
	                        }
	                        break;
	                    case mca$8.McaMethod.previewComm:
	                        switch (primaryState) {
	                            case mca$8.EventState.start:
	                                engagement = this.createEngagement(event, map);
	                                engagement.stateMap = stateMap;
	                                engagement.lastEvent = event;
	                            // tslint:disable-next-line: no-switch-case-fall-through
	                            case mca$8.EventState.wait:
	                            case mca$8.EventState.process:
	                                if (this.preProcessPreviewComm(engagement, stateChange)) {
	                                    this.processPreviewComm(engagement, stateChange, event);
	                                }
	                                else {
	                                    changeType = mca$8.DeltaType.none;
	                                    stateChange = null;
	                                }
	                                break;
	                            default:
	                                break;
	                        }
	                        break;
	                    // TODO Implement Other Cases...
	                    default:
	                        mcaLogger_1$7.McaLogger.info(this.pre + 'processEvent: ignoring: ' + event.method);
	                        break;
	                }
	                if (stateChange) {
	                    stateMap[eventMapKey] = stateChange.state;
	                }
	                const delta = new mca$8.EngagementChange(engagement.engagementId, stateChange, changeType);
	                map.setDelta(delta);
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'dclProcessEvent error: ' + err);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            finally {
	                if (!stateChange) {
	                    this.undoCheckOut(map);
	                }
	                else {
	                    this.flushCache(map);
	                }
	            }
	            this.setWaitResponse(event, engagement);
	            return engagement;
	        });
	        /**
	         * Adds an event to the wait response queue.  This is needed to correlate the event uuids with the response.
	         * In case the same event was generated from a different window with a different uuid.
	         */
	        this.setWaitResponse = (event, engagement) => {
	            if (!engagement) {
	                return;
	            }
	            event.uuid;
	            let waiterExists = false;
	            for (let i = 0; i < this.responseWaiters.length; i++) {
	                const ievent = this.responseWaiters[i];
	                if (event.uuid === ievent.uuid) {
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'event with uuid: ' + event.uuid + ' already exists in responseWaiters!');
	                    waiterExists = true;
	                }
	                else if (event.method === ievent.method && event.data.engagementId === ievent.data.engagementId) {
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'Already waiting for event: ' + event.data.engagementId + ' : ' + event.method);
	                    // Do NOT add a waiter in the case we are processing events as a result of detection of a storageEvent for a previously completed event
	                    waiterExists = true;
	                }
	            }
	            if (waiterExists) {
	                return;
	            }
	            const stateMap = engagement.stateMap;
	            if (!stateMap) {
	                mcaLogger_1$7.McaLogger.info(this.pre + 'setWaitResponse: no stateMap found!');
	                return;
	            }
	            const state = stateMap[event.method];
	            const responseMap = engagement.responseMap;
	            let response;
	            if (state) {
	                if (state !== mca$8.EventState.complete) {
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'Waiting response for event uuid: ' + event.uuid);
	                    this.responseWaiters.push(event);
	                }
	                else if (responseMap && responseMap[event.method]) {
	                    response = responseMap[event.method];
	                    // need to convert the uuid here since it's not getting delivered via the responseWaiters list
	                    response.uuid = event.uuid;
	                    this.deliverResponse(response, event);
	                }
	                else {
	                    mcaLogger_1$7.McaLogger.warn('No response found but, event already complete: ' +
	                        event.uuid +
	                        ' method: ' +
	                        event.method +
	                        'engagement: ' +
	                        event.data.engagementId);
	                    // <TODO> see if this can be covered in a test case...
	                    response = this.manufactureResponse(event, engagement);
	                    this.deliverResponse(response, event);
	                }
	            }
	        };
	        /**
	         * If we got a response for an event, we check the waiting queue to see if we need to process any events that were pending this response...
	         */
	        this.checkForPendingEvent = (engagement) => {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'checkForPendingEvent: ');
	            let pendingEvent;
	            const stateMap = engagement.stateMap;
	            if (stateMap) {
	                for (const method in stateMap) {
	                    if (stateMap.hasOwnProperty(method)) {
	                        const state = stateMap[method];
	                        if (state === mca$8.EventState.wait) {
	                            // if multiple events waiting get the 1st one...
	                            if (!pendingEvent) {
	                                pendingEvent = engagement.eventMap[method];
	                                mcaLogger_1$7.McaLogger.info(this.pre + 'Found pending event: ' + pendingEvent.method);
	                                continue;
	                            }
	                            if (EngagementManager.EVENT_SEQUENCE[method]) {
	                                const idx = EngagementManager.EVENT_SEQUENCE.indexOf(method);
	                                const oldIdx = EngagementManager.EVENT_SEQUENCE.indexOf(pendingEvent.method);
	                                if (idx < oldIdx) {
	                                    pendingEvent = engagement.eventMap[method];
	                                    mcaLogger_1$7.McaLogger.info(this.pre + 'Found earlier pending event: ' + pendingEvent.method);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return pendingEvent;
	        };
	        /**
	         * Check configurations and do getCustomerData preprocessing
	         * Returns true if the getCustomerDataEvent needs processed on the server.
	         * The getCustomerDataEvent may be detected in multiple windows. So, we need to make sure the preProcess is run in ALL windows
	         * but make sure the actual server processing only occurs once.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         * * *NOTE2* ALL Updates to the Engagement State should be done in processGetCustomerData because changes made in this method may not be saved
	         */
	        this.preProcessGetCustomerData = (engagement, state) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessGetCustomerData: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'GetCustomerData already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            if (retVal) {
	                if (engagement.eventMap && engagement.eventMap[mca$8.McaMethod.getCustomerData]) {
	                    const event = engagement.eventMap[mca$8.McaMethod.getCustomerData];
	                    event.actions = null;
	                }
	            }
	            return retVal;
	        };
	        /**
	         * Prepares GetCustomerDataEvent for REST processing
	         * * *NOTE* This may be running within our lock scope. Any expensive ops should be exec'ed in a promise.
	         */
	        this.processGetCustomerData = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processGetCustomerData: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    retVal = true;
	                    state.state = mca$8.EventState.process;
	                    this.invokeRest(engagement, mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'startComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Check configurations and do newComm preprocessing e.g. trigger a Notification Dialog display
	         * Returns true if the newCommEvent needs processed.
	         * The new CommEvent may be detected in multiple windows. So, we need to make sure the preProcess is run in all windows
	         * but make sure the actual processing only occurs once.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         * *NOTE2* ALL Updates to the Engagement State should be done in processNewComm because these may not be saved
	         */
	        this.preProcessNewComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessNewComm: ' + engagement.engagementId);
	            let sendNotification = false;
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    sendNotification = true;
	                    retVal = true;
	                    // sjmD: <TODO> Check Configs
	                    // Fire Notification Event... mca-main or a designated Notification component will listen/display notification
	                    // See if we can figure out a "potential" pageKey. So, that we may attempt to switch focus prior to REST call.
	                    break;
	                case mca$8.EventState.process:
	                case mca$8.EventState.wait:
	                    sendNotification = true;
	                    // leave retVal = false so we don't reprocess the event
	                    // sjmD: <TODO> Same checks/events as start state, we need this because only the 1st window where the event was detected
	                    // will ever see the start state; all other windows will only see the wait or process state...
	                    // fall thru;
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'newComm already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            const saveActions = mcaEvent.actions;
	            mcaEvent.actions = null;
	            // Trigger Notification For Inbound Only
	            if (sendNotification) {
	                if (!this.isOutbound(engagement)) {
	                    const actions = [{ name: mca$8.ActionName.Notify }];
	                    if (!saveActions) {
	                        mcaLogger_1$7.McaLogger.info(this.pre + 'Server did not return any Notify Action for newCommEvent but, this is being forced here');
	                    }
	                    mcaEvent.actions = actions;
	                    this.deliverAsyncEvent(mcaEvent);
	                }
	            }
	            return retVal;
	        };
	        /**
	         * Prepares newCommEvent for REST processing
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be exec'ed in a promise.
	         */
	        this.processNewComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processNewComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    retVal = true;
	                    state.state = mca$8.EventState.process;
	                    // TODO add to inData for extra newCommEvent debug details
	                    // DEBUG_MULTI_MATCH":"Y"
	                    this.invokeRest(engagement, mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'newComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Check configurations and do startComm preprocessing e.g. trigger close of Notification Dialog display
	         * Returns true if the startCommEvent needs processed on the server.
	         * The startCommEvent may be detected in multiple windows. So, we need to make sure the preProcess is run in ALL windows
	         * but make sure the actual server processing only occurs once.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         * * *NOTE2* ALL Updates to the Engagement State should be done in processStartComm because changes made in this method may not be saved
	         */
	        this.preProcessStartComm = (engagement, state) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessStartComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    retVal = true;
	                    // <TODO> Check Configs
	                    // Fire Start Event... mca-main or a designated Notification component will listen/close notification
	                    break;
	                case mca$8.EventState.process:
	                // leave retVal = false so we don't reprocess the event
	                // <TODO> Same checks/events as start state...
	                // fall thru;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'startComm already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            if (retVal) {
	                // Ensure the Notification is Cleared
	                if (engagement.eventMap && engagement.eventMap[mca$8.McaMethod.newComm]) {
	                    const event = engagement.eventMap[mca$8.McaMethod.newComm];
	                    event.actions = null;
	                }
	            }
	            return retVal;
	        };
	        /**
	         * Prepares startCommEvent for REST processing
	         * * *NOTE* This may be running within our lock scope. Any expensive ops should be exec'ed in a promise.
	         */
	        this.processStartComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processStartComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    const stateMap = engagement.stateMap;
	                    stateMap[mca$8.McaMethod.closeComm];
	                    const newCommState = stateMap[mca$8.McaMethod.newComm];
	                    if (newCommState) {
	                        if (newCommState === mca$8.EventState.start ||
	                            newCommState === mca$8.EventState.wait ||
	                            newCommState === mca$8.EventState.process) {
	                            // must wait for newComm processing to complete before processing startComm
	                            retVal = true;
	                            state.state = mca$8.EventState.wait;
	                            mcaLogger_1$7.McaLogger.info(this.pre +
	                                'Waiting for newComm response before processing startComm: ' +
	                                engagement.engagementId);
	                            break;
	                        }
	                    }
	                    retVal = true;
	                    //
	                    // Set default SVCMCA_UI_TYPE_CD to 'ORA_SVC_REDWOOD'
	                    //
	                    // For test purpose, keep the option SVCMCA_UI_TYPE_CD = 'ORA_SVC_ADF' open if specifed.
	                    //
	                    //  20210610 HHUANG
	                    //  Temporarily hide the default Redwood Screen pop option
	                    //    must specify SVCMCA_UI_TYPE_CD = ORA_SVC_REDWOOD to activate Redwood Screen pop
	                    //
	                    if (!mcaEvent.data.inData.SVCMCA_UI_TYPE_CD) {
	                        mcaEvent.data.inData.SVCMCA_UI_TYPE_CD = 'ORA_SVC_REDWOOD';
	                        // mcaEvent.data.inData.SVCMCA_UI_TYPE_CD = 'ORA_SVC_ADF';
	                    }
	                    state.state = mca$8.EventState.process;
	                    this.invokeRest(engagement, mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'startComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Check configurations and do closeComm preprocessing e.g. trigger close of Notification Dialog display
	         * Returns true if the closeCommEvent needs processed on the server.
	         * The closeCommEvent may be detected in multiple windows. So, we need to make sure the preProcess is run in ALL windows
	         * but make sure the actual server processing only occurs once.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         * * *NOTE2* ALL Updates to the Engagement State should be done in processStartComm because these may not be saved
	         */
	        this.preProcessCloseComm = (engagement, state) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessCloseComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    retVal = true;
	                    // <TODO> Check Configs
	                    // Fire Close Event... mca-main or a designated Notification component will listen/close notification
	                    break;
	                case mca$8.EventState.process:
	                // leave retVal = false so we don't reprocess the event
	                // <TODO> Same checks/events as start state...
	                // fall thru;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'closeComm already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Prepares closeCommEvent for REST processing
	         * * *NOTE* This may be running within our lock scope. Any expensive ops should be exec'ed in a promise.
	         */
	        this.processCloseComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processCloseComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    const stateMap = engagement.stateMap;
	                    for (const key in stateMap) {
	                        if (key === mca$8.McaMethod.closeComm) {
	                            continue;
	                        }
	                        const prevState = stateMap[key];
	                        if (prevState === mca$8.EventState.start ||
	                            prevState === mca$8.EventState.wait ||
	                            prevState === mca$8.EventState.process) {
	                            // must wait for previous event processing to complete before processing closeComm
	                            retVal = true;
	                            state.state = mca$8.EventState.wait;
	                            mcaLogger_1$7.McaLogger.info(this.pre +
	                                'Waiting for previous response before processing closeComm: ' +
	                                engagement.engagementId);
	                            break;
	                        }
	                    }
	                    if (retVal) {
	                        break;
	                    }
	                    engagement.cacheControl.deletedFlag = mca$8.Constants.YES_FLAG;
	                    engagement.cacheControl.unloadTime = Date.now();
	                    retVal = true;
	                    state.state = mca$8.EventState.process;
	                    let byPassRest = false;
	                    if (this.isOutbound(engagement)) {
	                        if (!engagement.stateMap || !engagement.stateMap[mca$8.McaMethod.newComm]) {
	                            // Outbound call failed or was aborted
	                            byPassRest = true;
	                            mcaLogger_1$7.McaLogger.info(this.pre + 'Skipping REST for Aborted Outbound Call');
	                            const fakeResponse = {
	                                channel: engagement.data.channel,
	                                channelId: '<MISSING>',
	                                channelType: engagement.data.channelType,
	                                engagementId: engagement.engagementId,
	                                eventId: engagement.engagementId,
	                                eventSource: mca$8.EventSource.toolbar,
	                                method: mca$8.McaMethod.closeComm,
	                                objectType: '',
	                                origin: engagement.lastEvent.origin,
	                                outData: {},
	                                result: mca$8.Result.success,
	                                toolbarName: engagement.lastEvent.toolbarName,
	                                uuid: engagement.lastEvent.uuid,
	                                windowName: engagement.windowName
	                            };
	                            const fakeData = { result: JSON.stringify(fakeResponse) };
	                            this.handleRestResponse(fakeData, engagement, mcaEvent);
	                        }
	                    }
	                    if (!byPassRest) {
	                        this.invokeRest(engagement, mcaEvent);
	                    }
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'closeComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Returns true if the getScreenPopDataEvent needs to be processed.
	         * Although the getScreenPopDataEvent is only detected in a single window, this method may be invoked via
	         * storage events to ensure toolbar updates are fired in all windows.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         */
	        this.preProcessGetScreenPopDataEvent = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessGetScreenPopDataEvent: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    // only ever seen in the 1st window where the event was detected
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                case mca$8.EventState.wait:
	                    // all other windows will only see the wait or process state...
	                    // ensure the event is sent to the toolbar in all windows
	                    this.deliverAsyncEvent(mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'getScreenPopData already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            return retVal;
	        };
	        this.processGetScreenPopDataEvent = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processGetScreenPopDataEvent: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    //
	                    //    must specify SVCMCA_UI_TYPE_CD = ORA_SVC_REDWOOD to activate Redwood Screen pop procesing logic
	                    //
	                    if (!mcaEvent.data.inData.SVCMCA_UI_TYPE_CD) {
	                        mcaEvent.data.inData.SVCMCA_UI_TYPE_CD = 'ORA_SVC_REDWOOD';
	                        // mcaEvent.data.inData.SVCMCA_UI_TYPE_CD = 'ORA_SVC_ADF';
	                    }
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                case mca$8.EventState.wait: // fall thru
	            }
	            if (retVal) {
	                state.state = mca$8.EventState.process;
	                // mcaEvent.method = mca.McaMethod.getScreenPopDataEvent;
	                this.invokeRest(engagement, mcaEvent);
	            }
	            return retVal;
	        };
	        /**
	         * Returns true if the updateCommDataEvent needs processed.
	         * Although the updateCommDataEvent is only detected in a single window, this method may be invoked via
	         * storage events to ensure toolbar updates are fired in all windows.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         */
	        this.preProcessUpdateComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessUpdateComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    // only ever seen in the 1st window where the event was detected
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                case mca$8.EventState.wait:
	                    // all other windows will only see the wait or process state...
	                    // ensure the event is sent to the toolbar in all windows
	                    this.deliverAsyncEvent(mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'updateComm already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            if (retVal) {
	                // Check If Data Has Changed...
	                const inData = mcaEvent.data.inData;
	                let dataChanged = false;
	                if (inData) {
	                    const newData = Object.keys(inData);
	                    if (newData && newData.length > 0) {
	                        for (const newToken of newData) {
	                            switch (newToken) {
	                                case mca$8.Constants.EVENT_MAP_KEY:
	                                case mca$8.SystemToken.unknownFlow:
	                                    continue; // ignore the keys we added for mapping
	                            }
	                            const cachedVal = engagement.data.outData[newToken];
	                            if (cachedVal && cachedVal === inData[newToken]) {
	                                mcaLogger_1$7.McaLogger.info(this.pre + 'FINEST: Token Value Already Set ' + newToken + ':' + inData[newToken]);
	                                // This token value was already set!!!
	                            }
	                            else {
	                                dataChanged = true;
	                                // Just copy to the engagement outData; because all the outData is added to the REST call
	                                engagement.data.outData[newToken] = inData[newToken];
	                                if (newToken === mca$8.SystemToken.contactName) {
	                                    // Special Processing to Update Toolbar Display
	                                    engagement.data.outData[mca$8.SystemToken.displayName] = inData[newToken];
	                                    inData[mca$8.SystemToken.displayName] = inData[newToken];
	                                }
	                                // FINEST LEVEL LOGGING...
	                                mcaLogger_1$7.McaLogger.info(this.pre + 'FINEST: setting new Token Value ' + newToken + ':' + inData[newToken]);
	                            }
	                        }
	                    }
	                }
	                if (dataChanged) {
	                    this.deliverAsyncEvent(mcaEvent);
	                }
	                else {
	                    retVal = false;
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'updateComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                }
	            }
	            return retVal;
	        };
	        this.processUpdateComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processUpdateComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                    // only ever seen in the 1st window where the event was detected
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                case mca$8.EventState.wait: // fall thru
	            }
	            if (retVal) {
	                state.state = mca$8.EventState.process;
	                this.invokeRest(engagement, mcaEvent);
	            }
	            return retVal;
	        };
	        /**
	         * Check configurations and do previewComm preprocessing
	         * Returns true if the previewCommEvent needs processed on the server.
	         * The Event may be detected in multiple windows. So, we need to make sure the preProcess is run in ALL windows
	         * but make sure the actual server processing only occurs once.
	         * *NOTE* This may be running within our lock scope. Any expensive ops should be execed in a promise/async function.
	         */
	        this.preProcessPreviewComm = (engagement, state) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'preProcessPreviewComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    retVal = true;
	                    break;
	                case mca$8.EventState.process:
	                // leave retVal = false so we don't reprocess the event
	                // fall thru;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'previewComm already processed for: ' + engagement.engagementId);
	                    break;
	            }
	            return retVal;
	        };
	        /**
	         * Prepares previewCommEvent for REST processing
	         * * *NOTE* This may be running within our lock scope. Any expensive ops should be exec'ed in a promise.
	         */
	        this.processPreviewComm = (engagement, state, mcaEvent) => {
	            let retVal = false;
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processPreviewComm: ' + engagement.engagementId);
	            switch (state.state) {
	                case mca$8.EventState.start:
	                case mca$8.EventState.wait:
	                    engagement.cacheControl.deletedFlag = mca$8.Constants.YES_FLAG;
	                    engagement.cacheControl.unloadTime = Date.now();
	                    retVal = true;
	                    state.state = mca$8.EventState.process;
	                    this.invokeRest(engagement, mcaEvent);
	                    break;
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'previewComm processing not required for: ' + engagement.engagementId + ' : ' + state.state);
	                    break;
	            }
	            return retVal;
	        };
	        this.isOutbound = (engagement) => {
	            let isOutbound = false;
	            if (engagement && engagement.data && engagement.data.inData) {
	                if (engagement.data.inData[mca$8.SystemToken.direction] === mca$8.DirectionToken.outbound) {
	                    isOutbound = true;
	                }
	            }
	            return isOutbound;
	        };
	        // NOT used
	        // private getRestBodyForMcaEvent(engagement: mca.Engagement, mcaEvent: mca.McaEvent): string {
	        //     const method: mca.McaMethod = mcaEvent.method;
	        //     const param0: any = { eventName: method };
	        //     const event: any = this.getEventForRestCall(engagement, mcaEvent);
	        //     const eventString: string = JSON.stringify(event);
	        //     // let param1: any = {paramsJson: event};
	        //     const param1: any = { paramsJson: eventString };
	        //     const params: any = [param0, param1];
	        //     const retJson: any = { name: 'processEvent', parameters: params };
	        //     return JSON.stringify(retJson);
	        // }
	        /**
	         * Invokes the multiChannelAdapterEvents processEvent for processing MCA Comm Events.
	         */
	        this.invokeRest = (engagement, mcaEvent) => {
	            try {
	                if (this.isVbEnabled) {
	                    this.invokeRestVB(engagement, mcaEvent);
	                }
	                else {
	                    this.invokeRestAPI(engagement, mcaEvent);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'invokeRest FAILED!');
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	        };
	        /**
	         * For REST access in ADF runtime
	         */
	        this.invokeRestAPI = (engagement, mcaEvent) => {
	            const event = this.getEventForRestCall(engagement, mcaEvent);
	            const eventString = JSON.stringify(event);
	            const method = mcaEvent.method;
	            const endPoint = '/crmRestApi/resources/latest/multiChannelAdapterEvents/action/processEvent';
	            const endPointOptions = {
	                body: JSON.stringify({
	                    'eventName': method,
	                    'paramsJson': eventString
	                }),
	                headers: {
	                    'Content-Type': 'application/vnd.oracle.adf.action+json',
	                    'REST-Framework-Version': '9'
	                },
	                method: 'POST'
	            };
	            mca_adf_rest_helper_1$1.McaAdfRestHelper.getInstance()
	                .fetch(endPoint, endPointOptions)
	                .then((result) => {
	                const jsonResult = JSON.parse(result);
	                this.handleRestResponse(jsonResult, engagement, mcaEvent);
	            })
	                .catch((reason) => {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'VB REST FAILED! Error ');
	                mcaLogger_1$7.McaLogger.error(reason);
	                this.handleRestResponse({}, engagement, mcaEvent);
	            });
	        };
	        /**
	         * For REST Access in VB Runtime
	         */
	        this.invokeRestVB = (engagement, mcaEvent) => {
	            const operation = 'doall_processEvent_multiChannelAdapterEvents';
	            // operation =  "create_multiChannelAdapterEvents"; //sjmD alternate access method - not working in vbdt
	            // const endPoint: string = mca.ServiceName.mcaEvents + '/' + operation;
	            const endPoint = oj_mca_common_1$9.McaCommon.getApiGroupMultiChannelAdapterEvents() + '/' + operation;
	            const event = this.getEventForRestCall(engagement, mcaEvent);
	            const eventString = JSON.stringify(event);
	            let request = null;
	            const appExtnObject = this.getAppExtnObject();
	            if (appExtnObject) {
	                request = restHelper$1.get(appExtnObject.extensionId + ':' + endPoint, appExtnObject);
	            }
	            else {
	                request = restHelper$1.get(endPoint);
	            }
	            const method = mcaEvent.method;
	            request.body({
	                'eventName': method,
	                'paramsJson': eventString
	            });
	            mcaLogger_1$7.McaLogger.info(this.pre + 'Invoking REST using VB with eventName: ' + method);
	            mcaLogger_1$7.McaLogger.info(this.pre + 'Passing REST body: paramsJson : ' + eventString);
	            request
	                .fetch()
	                .then((result) => {
	                let resultBody = {};
	                if (!result || !result.response || !result.response.status || !result.body) {
	                    mcaLogger_1$7.McaLogger.error(this.pre + 'VB REST FAILED! Invalid response');
	                    mcaLogger_1$7.McaLogger.error(result);
	                }
	                else {
	                    const status = result.response.status;
	                    if (status === 200) {
	                        mcaLogger_1$7.McaLogger.info(this.pre + 'VB REST SUCCESS! ' + method);
	                        resultBody = result.body;
	                    }
	                    else {
	                        const statusText = result.response.statusText;
	                        mcaLogger_1$7.McaLogger.error(this.pre + 'VB REST FAILED! ' + status + ' ' + statusText + ' Details: ' + result.body);
	                    }
	                }
	                this.handleRestResponse(resultBody, engagement, mcaEvent);
	            })
	                .catch((err) => {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'VB REST FAILED! Error ');
	                mcaLogger_1$7.McaLogger.error(err);
	                this.handleRestResponse({}, engagement, mcaEvent);
	            });
	        };
	        this.manufactureResponse = (event, engagement) => {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'manufactureResponse');
	            const response = {};
	            let outData = {};
	            response.uuid = event.uuid;
	            response.result = mca$8.Result.success;
	            response.method = event.method;
	            response.channelType = engagement.channelType;
	            response.toolbarName = event.toolbarName;
	            response.origin = engagement.origin;
	            response.eventId = engagement.engagementId;
	            response.engagementId = engagement.engagementId;
	            if (engagement.data.outData) {
	                outData = engagement.data.outData;
	            }
	            response.outData = outData;
	            return response;
	        };
	        /**
	         * Support for Single Page Service (aka MSI) App where Inbound Screen Pops are made in the
	         * same app window.
	         */
	        this.getScreenPopDisplayMode = (mcaEvent) => {
	            let mode = mca$8.PageDisplayMode.NewWindow;
	            if (oj_mca_common_1$9.McaCommon.getMsiEnabled()) {
	                if (mcaEvent.data && mcaEvent.data.appClassification === 'ORA_SERVICE' ||
	                    mcaEvent.data && mcaEvent.data.appClassification === '') {
	                    mode = mca$8.PageDisplayMode.MsiWindow;
	                }
	            }
	            return mode;
	        };
	        /**
	         * Process the multiChannelAdapterEvents processEvent REST Response Payload.
	         * Should be called for All responses whether the call was succesful or not to ensure proper state management and
	         * toolbar event response.
	         */
	        this.handleRestResponse = (data, engagement, mcaEvent) => __awaiter$8(this, void 0, void 0, function* () {
	            var _a;
	            const myFunc = 'handleRestResponse: ';
	            const outData = {};
	            const response = {};
	            if (!mcaEvent) {
	                mcaLogger_1$7.McaLogger.error(this.pre + myFunc + 'Missing event for response: ', data);
	                return;
	            }
	            let eventMapKey = mcaEvent.method;
	            const method = mcaEvent.method;
	            if (!method) {
	                mcaLogger_1$7.McaLogger.error(this.pre + 'Unexpected Response no Method defined', data);
	                return;
	            }
	            switch (method) {
	                case mca$8.McaMethod.updateComm:
	                    // support multiple updateCommEvents per engagement
	                    eventMapKey = mcaEvent.data.inData[mca$8.Constants.EVENT_MAP_KEY];
	                    break;
	                case mca$8.McaMethod.getScreenPopDataEvent:
	                    // support multiple getScreenPopDataEvents per engagement
	                    eventMapKey = mcaEvent.data.inData[mca$8.Constants.EVENT_MAP_KEY];
	                    break;
	            }
	            let isValidResponse = true;
	            // let errMsg: string = "Error: ";
	            response.outData = outData;
	            let resultString = null;
	            const demoOverrideActions = false; // for Demo Hack
	            try {
	                if (data && data.result) {
	                    resultString = data.result;
	                    mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'mcaEvents REST response: ' + resultString);
	                    const result = JSON.parse(resultString);
	                    if (result.result) {
	                        response.result = result.result;
	                        if (result.result === mca$8.Result.error) {
	                            mcaLogger_1$7.McaLogger.error(this.pre + myFunc + 'mcaEvents REST returned an error Response for ' + result.method);
	                            mcaLogger_1$7.McaLogger.error(result);
	                        }
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST missing result ' + result.method);
	                    }
	                    if (result.method) {
	                        response.method = result.method;
	                        if (response.method !== method) {
	                            mcaLogger_1$7.McaLogger.error(this.pre +
	                                myFunc +
	                                'mcaEvents REST expected response for: ' +
	                                method +
	                                ' but, got: ' +
	                                response.method);
	                        }
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST missing method ');
	                    }
	                    if (result.origin) {
	                        response.origin = result.origin;
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST missing origin ');
	                    }
	                    if (result.toolbarName) {
	                        response.toolbarName = result.toolbarName;
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST missing toolbarName ');
	                    }
	                    if (result.uuid) {
	                        response.uuid = result.uuid;
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST missing uuid: ' + result.method);
	                    }
	                    if (result.channelType) {
	                        response.channelType = result.channelType;
	                    }
	                    if (result.channelId) {
	                        response.channelId = result.channelId;
	                    }
	                    if (result.eventId) {
	                        response.eventId = result.eventId;
	                        response.engagementId = result.engagementId;
	                    }
	                    if (result.eventSource) {
	                        response.eventSource = result.eventSource;
	                    }
	                    if (result.windowName) {
	                        response.windowName = result.windowName;
	                        if (mcaEvent && !mcaEvent.window) {
	                            mcaEvent.window = result.windowName;
	                        }
	                    }
	                    if (result.errorMessage) {
	                        response.errorMessage = result.errorMessage;
	                    }
	                    if (result.outData) {
	                        response.outData = result.outData;
	                        // Retrieve common outData attributes
	                        if (result.outData.channelType) {
	                            response.channelType = result.outData.channelType;
	                        }
	                        if (result.outData.channelId) {
	                            response.channelId = result.outData.channelId;
	                        }
	                        if (result.outData.eventId) {
	                            response.eventId = result.outData.eventId;
	                            response.engagementId = engagement.engagementId;
	                        }
	                        if (result.outData[mca$8.SystemToken.interactionId]) {
	                            response.interactionId = result.outData[mca$8.SystemToken.interactionId];
	                        }
	                        if (result.outData[mca$8.SystemToken.wrapupId]) {
	                            response.wrapupId = result.outData[mca$8.SystemToken.wrapupId];
	                        }
	                    }
	                    else {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + myFunc + 'mcaEvents REST return missing outData');
	                        isValidResponse = false;
	                    }
	                    if (result.actions) {
	                        response.actions = result.actions;
	                    }
	                    // Substitute the pageKey Tokens up front
	                    if (response.actions && response.actions.length > 0) {
	                        for (let i = 0; i < response.actions.length; i++) {
	                            const action = response.actions[i];
	                            const pageKey = (_a = action.data) === null || _a === void 0 ? void 0 : _a.pageKey;
	                            if (pageKey) {
	                                // 11-26-23 Now making the pageKey unique to always force Screen Pops in a new Window
	                                const formattedPageKey = oj_mca_common_1$9.McaCommon.substitutePageKeyTokens(pageKey, response.outData);
	                                // TO Switch Back to Original Mode where we reuse Screen Pop windows comment out above line and uncomment following line
	                                // const formattedPageKey: string = McaCommon.substituePageKeyTokens(pageKey, response.outData, false);
	                                action.data.pageKey = formattedPageKey;
	                            }
	                        }
	                    }
	                    switch (method) {
	                        case mca$8.McaMethod.updateComm:
	                            // TODO add new property in the ObjectActionEvent to control this...
	                            response.screenPopMode = mca$8.PageDisplayMode.CurrentWindow;
	                            if (!this.checkAction(response.actions, mca$8.ActionName.ScreenPop)) {
	                                mcaLogger_1$7.McaLogger.info(this.pre + 'ScreenPop Action Missing for updateCommData response');
	                                if (result.outData[mca$8.SystemToken.unknownFlow] === true ||
	                                    result.outData[mca$8.SystemToken.unknownFlow] === 'true') {
	                                    mcaLogger_1$7.McaLogger.info(this.pre + 'Forcing ScreenPop Action for Unknown Flow');
	                                    response.actions = this.addAction(response.actions, mca$8.ActionName.ScreenPop);
	                                    delete result.outData[mca$8.SystemToken.unknownFlow];
	                                }
	                            }
	                            if (result.outData[mca$8.SystemToken.spFailOverHandled] === 'Y') {
	                                // change response result back to success in case of screen pop failure
	                                // handling, fix to enable Edit Contact Page Engagement display
	                                //
	                                response.result = mca$8.Result.success;
	                            }
	                            break;
	                        case mca$8.McaMethod.getScreenPopDataEvent:
	                            // TODO add new property in the ObjectActionEvent to control this...
	                            response.screenPopMode = mca$8.PageDisplayMode.NewWindow;
	                            mcaLogger_1$7.McaLogger.info(this.pre + 'ScreenPop Action is added to getScreenPopData response');
	                            response.actions = this.addAction(response.actions, mca$8.ActionName.ScreenPop, result.outData);
	                            const responseString = JSON.stringify(response);
	                            mcaLogger_1$7.McaLogger.log('handleRestResponse API getScreenPopData resposne: ' + responseString);
	                            break;
	                        case mca$8.McaMethod.startComm:
	                            /* Always show unknown Page for an unknown caller.
	                             * Check if StartCommEvent when ContactId and LeadId are not available
	                             * if "SearchContact" action is not present, add it to actions liset
	                             */
	                            let screenPopActionItem = null;
	                            let callDirection = null;
	                            if (response.outData) {
	                                const contactId = response.outData.SVCMCA_CONTACT_ID;
	                                const leadId = response.outData.SVCMCA_LEAD_ID;
	                                const personId = response.outData.SVCMCA_PER_PERSON_ID;
	                                const accountId = response.outData.SVCMCA_ORG_ID;
	                                callDirection = response.outData.SVCMCA_COMMUNICATION_DIRECTION;
	                                // Check SearchContact Action and ScreenPop Action
	                                let searchActionItem = null;
	                                if (response.actions && response.actions.length > 0) {
	                                    for (let i = 0; i < response.actions.length; i++) {
	                                        const action = response.actions[i];
	                                        if (!action || !action.name) {
	                                            continue;
	                                        }
	                                        if (action.name === mca$8.ActionName.SearchContact) {
	                                            searchActionItem = action;
	                                        }
	                                        if (action.name === mca$8.ActionName.ScreenPop) {
	                                            screenPopActionItem = action;
	                                        }
	                                        if (action.name === mca$8.ActionName.ScreenPopFailure) {
	                                            screenPopActionItem = action;
	                                        }
	                                    }
	                                }
	                                if (!contactId && !leadId && !personId) {
	                                    if (this.isOutbound(engagement) && (response.outData.SVCMCA_ORG_ID || response.outData.SVCMCA_INTERACTION_REF_OBJ_ID)) {
	                                        if (searchActionItem) {
	                                            response.actions = this.removeAction(response.actions, mca$8.ActionName.SearchContact);
	                                        }
	                                    }
	                                    else if (!accountId) {
	                                        // Check SearchContact Action for unknown contact
	                                        if (!searchActionItem) {
	                                            response.actions = this.addAction(response.actions, mca$8.ActionName.SearchContact);
	                                        }
	                                        // Do screen pop for unknown contact page even screen pop is disabled
	                                        if (!screenPopActionItem) {
	                                            response.actions = this.addAction(response.actions, mca$8.ActionName.ScreenPop);
	                                            screenPopActionItem = mca$8.ActionName.ScreenPop;
	                                        }
	                                    }
	                                }
	                            }
	                            if (response.actions) {
	                                response.screenPopMode = this.getScreenPopDisplayMode(mcaEvent);
	                                if (demoOverrideActions && this.isOutbound(engagement)) ;
	                                if (callDirection === mca$8.DirectionToken.inbound && !screenPopActionItem) {
	                                    // SVC-139499 Inbound Call: When screen pop is disabled then don't display engagement component
	                                    mcaLogger_1$7.McaLogger.info(this.pre + 'Inbound Call with no screen pop action - Removing inbound Actions!');
	                                    response.actions = null;
	                                }
	                            }
	                            else {
	                                if (!this.isOutbound(engagement)) {
	                                    if (demoOverrideActions) ;
	                                    else {
	                                        mcaLogger_1$7.McaLogger.warn(this.pre + '*WARNING* Suspicious behavior, startCommEvent Actions usually expected for Inbound/Update');
	                                    }
	                                }
	                            }
	                            break;
	                        case mca$8.McaMethod.newComm:
	                            if (response.outData[mca$8.SystemToken.contactName]) {
	                                mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'mcaEvents REST Contact FOUND: ' + response.outData[mca$8.SystemToken.contactName]);
	                            }
	                            if (response.outData[mca$8.SystemToken.displayName]) {
	                                mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'current DISPLAY_NAME is : ' + response.outData[mca$8.SystemToken.displayName]);
	                            }
	                            if (!response.outData[mca$8.SystemToken.contactName] &&
	                                !response.outData[mca$8.SystemToken.displayName] &&
	                                response.outData[mca$8.SystemToken.leadName]) {
	                                response.outData[mca$8.SystemToken.displayName] = response.outData[mca$8.SystemToken.leadName];
	                                mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'DISPLAY_NAME is replaced by LEAD_NAME : ' + response.outData[mca$8.SystemToken.leadName]);
	                                mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'current DISPLAY_NAME is : ' + response.outData[mca$8.SystemToken.displayName]);
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                else {
	                    mcaLogger_1$7.McaLogger.info(this.pre + myFunc + 'mcaEvents REST invalid response: ' + data);
	                    mcaLogger_1$7.McaLogger.info(data);
	                    isValidResponse = false;
	                }
	            }
	            catch (err) {
	                isValidResponse = false;
	                mcaLogger_1$7.McaLogger.error(this.pre + myFunc + 'Error processing response: ' + resultString);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            if (!isValidResponse) {
	                // TODO this is just temp to update toolbar when we have an invalid response from the server...
	                // see if there is additional error handling necessary
	                if (engagement.data.inData[mca$8.SystemToken.ani]) {
	                    outData[mca$8.SystemToken.displayName] = engagement.data.inData[mca$8.SystemToken.ani];
	                }
	                else if (engagement.data.inData[mca$8.SystemToken.email]) {
	                    outData[mca$8.SystemToken.displayName] = engagement.data.inData[mca$8.SystemToken.email];
	                }
	                else {
	                    outData[mca$8.SystemToken.displayName] = 'UNKNOWN';
	                }
	                response.result = mca$8.Result.error;
	                if (!response.uuid) {
	                    response.uuid = mcaEvent.uuid;
	                }
	                if (!response.toolbarName) {
	                    response.toolbarName = mcaEvent.toolbarName;
	                }
	                if (!response.eventId) {
	                    response.eventId = mcaEvent.data.eventId;
	                    response.engagementId = mcaEvent.data.eventId;
	                }
	                if (!response.method) {
	                    response.method = method;
	                }
	            }
	            const eventState = mca$8.EventState.complete;
	            const stateChange = {};
	            stateChange.method = method;
	            stateChange.state = eventState;
	            if (method !== eventMapKey) {
	                stateChange.eventMapKey = eventMapKey;
	            }
	            const delta = new mca$8.EngagementChange(engagement.engagementId, stateChange, mca$8.DeltaType.state);
	            const map = yield this.checkOutMap();
	            // Now we are in lock scope ...
	            let skipFlush = false;
	            try {
	                let mapEngagement = map.get(engagement.engagementId);
	                if (!mapEngagement) {
	                    mcaLogger_1$7.McaLogger.error(this.pre +
	                        'Engagement not found in map while waiting response: ' +
	                        engagement.engagementId +
	                        ' : ' +
	                        stateChange.method);
	                    mapEngagement = engagement;
	                    map.put(engagement.engagementId, engagement);
	                }
	                engagement = mapEngagement;
	                const previousState = mapEngagement.stateMap[stateChange.method];
	                if (previousState === stateChange.state) {
	                    mcaLogger_1$7.McaLogger.warn(this.pre +
	                        'Engagement seems to have already been completed: ' +
	                        engagement.engagementId +
	                        ' : ' +
	                        stateChange.method);
	                }
	                if (!mapEngagement.stateMap[eventMapKey]) {
	                    // Handle case where mercury keeps resending the same engagement,
	                    // If the closeCommEvent Response comes after we have cleared out the previous engagement
	                    // just ignore it
	                    mcaLogger_1$7.McaLogger.warn(`${this.pre} Ignoring unexpected or expired response for ${eventMapKey}`);
	                    this.undoCheckOut(map);
	                    skipFlush = true;
	                    return;
	                }
	                mapEngagement.stateMap[eventMapKey] = stateChange.state;
	                mapEngagement.responseMap[eventMapKey] = response;
	                if (method === mca$8.McaMethod.updateComm) {
	                    // Overwrite the startCommEvent Response Map; so that any future events delivered
	                    // as part of page reload processing contain all the latest updates
	                    if (this.checkAction(mapEngagement.responseMap[mca$8.McaMethod.startComm].actions, mca$8.ActionName.WrapUp)) {
	                        // Check if we are already in wrapup and add that action before copying over.
	                        // This is required to ensure that we will load the engagement component in wrapup mode if
	                        // necessary following the screen pop in the unknown flow.
	                        response.actions = this.addAction(response.actions, mca$8.ActionName.WrapUp);
	                    }
	                    mapEngagement.responseMap[mca$8.McaMethod.startComm] = response;
	                }
	                if (!mapEngagement.interactionId) {
	                    mapEngagement.interactionId = response.interactionId;
	                }
	                if (!mapEngagement.data.channelId) {
	                    mapEngagement.data.channelId = response.channelId;
	                }
	                if (response.actions) {
	                    // Fix page refresh issue during wrapup by adding the wrapup action to the engagement's startCommEvent
	                    for (let i = 0; i < response.actions.length; i++) {
	                        const action = response.actions[i];
	                        if (action.name === mca$8.ActionName.WrapUp) {
	                            const startCommEvent = engagement.responseMap[mca$8.McaMethod.startComm];
	                            if (startCommEvent) {
	                                let startActions = startCommEvent.actions;
	                                if (!startActions) {
	                                    startActions = [];
	                                    startCommEvent.actions = startActions;
	                                }
	                                startActions.push(action);
	                                break;
	                            }
	                        }
	                    }
	                }
	                map.setDelta(delta);
	                if (!mapEngagement.data.outData) {
	                    mapEngagement.data.outData = {};
	                }
	                for (const key in response.outData) {
	                    if (response.outData.hasOwnProperty(key)) {
	                        switch (key) {
	                            case mca$8.Constants.EVENT_MAP_KEY:
	                            case mca$8.SystemToken.unknownFlow:
	                            // case mca.Constants.CHANNEL_TYPE:
	                            case mca$8.Constants.EVENT_ID:
	                            case mca$8.Constants.CHANNEL:
	                                // TODO Add other attributes we don't want to cache here
	                                continue; // Don't Cache These!!!
	                            default:
	                                break;
	                        }
	                        mapEngagement.data.outData[key] = response.outData[key];
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.error(this.pre +
	                    'Exception in post REST state update: ' +
	                    err +
	                    ' engagement: ' +
	                    engagement.engagementId +
	                    ' : ' +
	                    stateChange.method);
	                mcaLogger_1$7.McaLogger.error(err);
	            }
	            finally {
	                if (!skipFlush) {
	                    this.flushCache(map);
	                }
	            }
	            this.deliverResponse(response, mcaEvent);
	            const pendingEvent = this.checkForPendingEvent(engagement);
	            if (pendingEvent) {
	                this.processEvent(pendingEvent);
	            }
	        });
	        this.handleLogCallResponse = (response, event) => {
	            if (event.previewMode) {
	                response.previewMode = event.previewMode;
	            }
	            if (event.previewMode === 'MANUAL') {
	                if (event && event.method === mca$8.McaMethod.previewComm) {
	                    const respEventId = event.data.engagementId;
	                    ({
	                        contactName: event.data.inData[mca$8.SystemToken.displayName],
	                        data: event.data,
	                        phoneNumber: event.data.inData[mca$8.SystemToken.ani],
	                        previewMode: 'MANUAL'
	                    });
	                    const origCmd = this.getLogCallCommand();
	                    try {
	                        const commandResp = new mca$8.CommandResponse(origCmd.command, event.data.result, respEventId, respEventId, response.outData);
	                        if (origCmd.responseCallback) {
	                            origCmd.responseCallback(commandResp);
	                        }
	                    }
	                    catch (err) {
	                        mcaLogger_1$7.McaLogger.info(this.pre + 'Error delivering Command Response ', err);
	                    }
	                }
	            }
	        };
	        /**
	         * Deliver server/REST event responses to the target container i.e. toolbar.
	         */
	        this.deliverResponse = (response, event) => {
	            const uuid = response.uuid;
	            for (let i = 0; i < this.responseWaiters.length; i++) {
	                const ievent = this.responseWaiters[i];
	                if (ievent.data.engagementId === response.engagementId) {
	                    if (ievent.method === response.method) {
	                        mcaLogger_1$7.McaLogger.info(this.pre + 'deliverResponse: uuid: ' + uuid + ' converted to: ' + ievent.uuid);
	                        response.uuid = ievent.uuid; // this listener is expecting a specific uuid for this event
	                        event.uuid = ievent.uuid;
	                        this.responseWaiters.splice(i, 1);
	                        break;
	                    }
	                }
	            }
	            // Now We have one response handler for each event source: 1. toolbar 2. mercury
	            try {
	                mcaLogger_1$7.McaLogger.info(this.pre +
	                    'Delivering response: ' +
	                    response.engagementId +
	                    ' : ' +
	                    response.method +
	                    ' uuid: ' +
	                    response.uuid);
	                let eventSource = mca$8.EventSource.toolbar;
	                if (event.eventSource === mca$8.EventSource.mercury) {
	                    eventSource = mca$8.EventSource.mercury;
	                }
	                else if (event.eventSource === mca$8.EventSource.application) {
	                    eventSource = mca$8.EventSource.application;
	                }
	                const handler = this.responseTargetMap.get(eventSource);
	                if (!handler) {
	                    mcaLogger_1$7.McaLogger.error(this.pre + 'No response handler registered for eventSource: ' + eventSource);
	                }
	                else {
	                    handler(response, event);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.warn(this.pre + 'Exception in target response handler detected: ' + err);
	                mcaLogger_1$7.McaLogger.warn(err);
	            }
	        };
	        /**
	         * Deliver events to registered listener.  This ensures that all events are detected in ALL windows.
	         * This is required for auto expand/collapse sync across all windows, etc.
	         */
	        this.deliverEvent = (event) => {
	            // Responses are delivered to the event source ie. mercury or [toolbar]container
	            let retVal = mca$8.Result.success;
	            try {
	                // <TODO> Deliver in a Promise to ensure async processing
	                let eventSource = mca$8.EventSource.toolbar;
	                if (event.eventSource === mca$8.EventSource.mercury) {
	                    eventSource = mca$8.EventSource.mercury;
	                }
	                mcaLogger_1$7.McaLogger.info(this.pre + 'Delivering event: ' + event.data.engagementId + ' : ' + event.method);
	                const handler = this.eventTargetMap.get(eventSource);
	                if (!handler) {
	                    mcaLogger_1$7.McaLogger.error(this.pre + 'No event handler registered for eventSource: ' + eventSource);
	                }
	                else {
	                    handler(event);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$7.McaLogger.warn(this.pre + 'Exception in target event handler detected: ' + err);
	                mcaLogger_1$7.McaLogger.warn(err);
	                retVal = mca$8.Result.error;
	            }
	            return retVal;
	        };
	        this.deliverAsyncEvent = (event) => __awaiter$8(this, void 0, void 0, function* () {
	            const retVal = this.deliverEvent(event);
	            return retVal;
	        });
	        this.checkAction = (actions, actionName) => {
	            let retVal = false;
	            if (actions && actions.length > 0) {
	                for (const action of actions) {
	                    if (action.name === actionName) {
	                        retVal = true;
	                        break;
	                    }
	                }
	            }
	            return retVal;
	        };
	        this.addAction = (actions, actionName, data) => {
	            if (!actions) {
	                actions = [];
	            }
	            if (!data) {
	                data = {};
	            }
	            const action = { name: actionName, data };
	            actions.push(action);
	            return actions;
	        };
	        this.removeAction = (actions, actionName) => {
	            if (!actions) {
	                actions = [];
	            }
	            const newActions = [];
	            for (let i = 0; i < actions.length; i++) {
	                if (actions[i].name === actionName) {
	                    continue;
	                }
	                newActions.push(actions[i]);
	            }
	            return newActions;
	        };
	        if (window.vb && window.vb.version) {
	            this.isVbEnabled = true;
	        }
	        else {
	            this.isVbEnabled = false;
	        }
	    }
	    /**
	     *
	     * @param appExtnObject - optional JSON object in form {"extensionId": "<Application Extension ID"}
	     * This is required to enable REST access to Unified VB App UI based applications
	     */
	    static getInstance(appExtnObject) {
	        if (!EngagementManager.instance) {
	            EngagementManager.instance = new EngagementManager(appExtnObject);
	        }
	        return EngagementManager.instance;
	    }
	    /**
	     * Async Engagement event processor.
	     * The engagement returned does NOT contain the server response.  Server Event Responses are delivered via the callback registered in
	     * setResponseTarget.
	     * @param event - The McaEvent for processing, the following events are supported: newCommEvent, startCommEvent, closeCommEvent,
	     * upgradeCommEvent, downgradeCommEvent.
	     */
	    processEvent(event) {
	        return __awaiter$8(this, void 0, void 0, function* () {
	            mcaLogger_1$7.McaLogger.info(this.pre + 'processEvent: ' + event.method + ' :' + event.data.engagementId);
	            if (!event.data.engagementId) {
	                throw new Error('Event missing data.eventId');
	            }
	            let engagement = this.getLatestEngagementByEventId(event.data.eventId);
	            let doDcl = false;
	            switch (event.method) {
	                case mca$8.McaMethod.getCustomerData:
	                    if (!engagement) {
	                        doDcl = true;
	                    }
	                    else if (engagement.cacheControl.okForDelete()) {
	                        doDcl = true;
	                    }
	                    break;
	                case mca$8.McaMethod.newComm:
	                    if (!engagement) {
	                        doDcl = true;
	                    }
	                    else if (engagement.cacheControl.okForDelete()) {
	                        doDcl = true;
	                    }
	                    break;
	                case mca$8.McaMethod.startComm:
	                case mca$8.McaMethod.closeComm: // should be exact same logic
	                    if (!engagement) {
	                        doDcl = true;
	                    }
	                    else {
	                        const stateMap = engagement.stateMap;
	                        if (stateMap[event.method]) {
	                            if (stateMap[event.method] === mca$8.EventState.wait) {
	                                doDcl = true;
	                            }
	                        }
	                        else {
	                            doDcl = true;
	                        }
	                    }
	                    if (event.method === mca$8.McaMethod.startComm && doDcl === true) {
	                        event.data.timestamp = Date.now();
	                    }
	                    break;
	                case mca$8.McaMethod.updateComm:
	                    if (!engagement) {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + 'No engagement found to update.');
	                        return; // early exit!!!
	                    }
	                    else {
	                        // Assumptions:
	                        // 1.  updateCommEvents are initiated from the fusion app which means only a
	                        //   single window will fire the event
	                        // 2. all updateCommEvents will be processed in other words we won't have duplicate
	                        //   updateCommEvents
	                        // 3. we're only tracking updateCommEvents for Active Engagements if the closeCommEvent
	                        //   was already recevied these are ignored.
	                        doDcl = true;
	                    }
	                    break;
	                case mca$8.McaMethod.previewComm:
	                case mca$8.McaMethod.getScreenPopDataEvent:
	                    // getScreenPopDataEvent is not related to any newCommEvent or startCommEvent
	                    if (!engagement) {
	                        doDcl = true;
	                    }
	                    else if (engagement.cacheControl.okForDelete()) {
	                        doDcl = true;
	                    }
	                    break;
	                case mca$8.McaMethod.transferedToQueue:
	                    if (!engagement) {
	                        mcaLogger_1$7.McaLogger.warn(this.pre + 'No engagement found to transfer.');
	                        return; // early exit!!!
	                    }
	                    else {
	                        // We'll process a close comm event for this
	                        event.method = mca$8.McaMethod.closeComm;
	                        event.data.reason = mca$8.CloseCommReason.transferred;
	                        doDcl = true;
	                    }
	                    break;
	                // TODO implement other cases!!!
	                default:
	                    mcaLogger_1$7.McaLogger.info(this.pre + 'processEvent: ignoring: ' + event.method);
	                    return; // early exit!!!
	            }
	            if (doDcl) {
	                engagement = yield this.dclProcessEvent(event);
	                if (!engagement) {
	                    mcaLogger_1$7.McaLogger.info(this.pre + ' Missing engagement as it is already processed: ' + event.data.eventId + ' : ' + event.method);
	                    return;
	                }
	            }
	            else {
	                mcaLogger_1$7.McaLogger.info(this.pre + 'Already processed: ' + engagement.engagementId + ' : ' + event.method);
	            }
	            const origEvent = engagement.eventMap[event.method];
	            if (origEvent && origEvent.uuid !== event.uuid) {
	                if (origEvent.actions) {
	                    event.actions = origEvent.actions;
	                }
	                this.setWaitResponse(event, engagement);
	            }
	            return engagement;
	        });
	    }
	    /**
	     * Retrieves the identified engagement from the Engagement Cache.
	     * @param engagementId - identifies the engagement to retrieve. null is returned if no corresponding
	     * engagement is found.
	     */
	    getEngagement(engagementId) {
	        const map = this.getMap();
	        return map.get(engagementId);
	    }
	    /**
	     * Retrieve the count of currently "active" engagements.  Engagements are counted as active if there
	     * has been a startCommEvent received but, no closeCommEvent has yet been received.
	     */
	    getActiveEngagementCount() {
	        let retVal = 0;
	        const map = this.getMap();
	        const keys = map.keys();
	        for (const id of keys) {
	            const engagement = map.get(id);
	            if (engagement) {
	                const stateMap = engagement.stateMap;
	                if (stateMap) {
	                    const started = stateMap[mca$8.McaMethod.startComm];
	                    if (started) {
	                        const completed = stateMap[mca$8.McaMethod.closeComm];
	                        if (!completed) {
	                            retVal++;
	                        }
	                    }
	                }
	            }
	        }
	        mcaLogger_1$7.McaLogger.info(this + 'getActiveEngagementCount: ' + retVal);
	        return retVal;
	    }
	    setOutboundCall(data) {
	        this.pendingOutbound = data;
	    }
	    isEngagementClosedWithoutStartComm(engagementId) {
	        const map = this.getMap();
	        const engagement = map.get(engagementId);
	        if (engagement) {
	            const stateMap = engagement.stateMap;
	            if (stateMap) {
	                return (stateMap[mca$8.McaMethod.newComm] && stateMap[mca$8.McaMethod.closeComm] && !stateMap[mca$8.McaMethod.startComm] ||
	                    !stateMap[mca$8.McaMethod.newComm] && stateMap[mca$8.McaMethod.closeComm] && !stateMap[mca$8.McaMethod.startComm]);
	            }
	        }
	        return false;
	    }
	    /**
	     * Sets the callback for returning MCA REST Service responses back to the event initiator.
	     * @param responseHandler
	     * @param eventSource - specified the source of events handled
	     */
	    setResponseTarget(responseHandler, eventSource) {
	        this.responseTargetMap.set(eventSource, responseHandler);
	    }
	    /**
	     * Sets the McaEventHandler for communicating events generated in other windows back to the local
	     * MCA Container.
	     * @param eventHandler
	     */
	    setEventTarget(eventHandler, eventSource) {
	        this.eventTargetMap.set(eventSource, eventHandler);
	    }
	    /**
	     * Sets the command for returning log call responses back to the event initiator.
	     * @param responseHandler
	     */
	    setLogCallCommand(command) {
	        this.logCallCommand = command;
	    }
	    getLogCallCommand() {
	        return this.logCallCommand;
	    }
	    getLatestEngagementByEventId(eventId) {
	        const map = this.getMap();
	        let selectedEngagement;
	        for (const id of map.keys()) {
	            const engagement = map.get(id);
	            if (engagement.eventId === eventId && (!selectedEngagement
	                || selectedEngagement.cacheControl.createTime < engagement.cacheControl.createTime)) {
	                selectedEngagement = engagement;
	            }
	        }
	        return selectedEngagement;
	    }
	    getActiveEngagementByEventId(map, eventId) {
	        let selectedEngagement;
	        for (const id of map.keys()) {
	            const engagement = map.get(id);
	            if (engagement.eventId === eventId && !engagement.cacheControl.okForDelete()) {
	                selectedEngagement = engagement;
	                break;
	            }
	        }
	        return selectedEngagement;
	    }
	    /**
	     * Ensure all results from previous calls are included in the subsequent request.
	     * For example if newCommEvent returns an InteractionId or ContactId we need to ensure
	     * that information is included in the startCommEvent call.
	     * This MUST Be Called prior to any REST Calls for commEvents!!!
	     * @param engagement
	     * @param method
	     */
	    getEventForRestCall(engagement, event) {
	        if (engagement.data && engagement.data.outData) {
	            // Ensure we update the current event input with any response data from previous events
	            const cachedTokens = Object.keys(engagement.data.outData);
	            if (!event.data.inData) {
	                event.data.inData = {};
	            }
	            for (const cachedToken of cachedTokens) {
	                const cachedVal = engagement.data.outData[cachedToken];
	                // Note: we are overwriting everything, we could be more selective...
	                // Fix bug 32016248
	                if (cachedToken === mca$8.SystemToken.secondCallType) ;
	                else {
	                    event.data.inData[cachedToken] = cachedVal;
	                }
	            }
	            // Fix bug 33489461
	            if (event.data.inData[mca$8.SystemToken.appClassification]) {
	                event.data.appClassification = event.data.inData[mca$8.SystemToken.appClassification];
	            }
	        }
	        return event;
	    }
	}
	mcaEngagementManager.EngagementManager = EngagementManager;
	EngagementManager.IDX_TRANSCRIPT_TABLE = 'transcripts';
	EngagementManager.NAME = 'oj-mca-engagement';
	EngagementManager.MAX_ENGAGEMENTS = 10; // We only maintain up to 10 simultaneous engagements in cache
	EngagementManager.MIN_CACHE_SIZE = 3;
	EngagementManager.ENGAGEMENT_EXPIRATION = 1000 * 60 * 60 * 1; // Engagment Expiration Time - 1 hour
	EngagementManager.EVENT_SEQUENCE = [
	    mca$8.McaMethod.getCustomerData,
	    mca$8.McaMethod.newComm,
	    mca$8.McaMethod.startComm,
	    mca$8.McaMethod.upgradeComm,
	    mca$8.McaMethod.downgradeComm,
	    mca$8.McaMethod.closeComm
	];
	EngagementManager.desc = 'Engagements';

	var mcaRestHelper = {};

	var ToolbarLoadState = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ToolbarLoadState = void 0;
		(function (ToolbarLoadState) {
		    ToolbarLoadState["preLoad"] = "PRELOAD";
		    ToolbarLoadState["loading"] = "LOADING";
		    ToolbarLoadState["notConfigured"] = "NOT_CONFIGURED";
		    ToolbarLoadState["invalidConfigured"] = "INVALID_CONFIGURATION";
		    ToolbarLoadState["invalidUrl"] = "INVALID_URL";
		    ToolbarLoadState["restFailed"] = "REST_FAILED";
		    ToolbarLoadState["loaded"] = "LOADED"; // Success
		})(exports.ToolbarLoadState || (exports.ToolbarLoadState = {}));
		
	} (ToolbarLoadState));

	var __awaiter$7 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaRestHelper, "__esModule", { value: true });
	mcaRestHelper.McaRestHelper = void 0;
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	const ko$5 = knockoutLatestExports;
	const mcaLogger_1$6 = requireMcaLogger();
	const ToolbarLoadState_1$2 = ToolbarLoadState;
	const oj_mca_common_1$8 = requireOjMcaCommon();
	const restHelper = require$$5;
	const mca_indexed_db_manager_1 = requireMcaIndexedDbManager();
	/**
	 * User Login Session Based REST Cacheing Utility
	 * Relies upon IndexedDB for cacheing the REST Response Data.
	 */
	class McaRestHelper {
	    /**
	     *
	     * @param endPoint
	     * @param contentType - if special type McaRestHelper.NO_REST, then we will not invoke REST.  In this case the object data should
	     * get set via the manualCacheData method
	     */
	    constructor(endPoint, contentType, extensionObject) {
	        this.pre = '[McaRestHelper] ';
	        this.fetchResponse = ko$5.observable();
	        // Added to reuse existing connection
	        this.dbOpenRequest = null;
	        this.doCacheResponse = true;
	        this.fetch = () => {
	            const fetchPromise = new Promise((resolve, reject) => __awaiter$7(this, void 0, void 0, function* () {
	                if (this.readFail) {
	                    mcaLogger_1$6.McaLogger.warn(`${this} Seems to be a new fetch while waiting for prev response ` + this.endPoint);
	                    // Clear out prev fetch Promise
	                    this.dbGetError({});
	                }
	                this.readFail = reject;
	                this.readSuccess = resolve;
	                // If we are just fetching manual cache updates we don't want to rewrite that to storage
	                if (McaRestHelper.NO_REST === this.contentType) {
	                    this.doCacheResponse = false;
	                }
	                // Read IndexedDB
	                this.getRecordFromIDB();
	            }));
	            return fetchPromise;
	        };
	        /**
	         * manualCacheData is used to store configurations retrieved via Non-REST based events.
	         * This returns a Promise that resolves once the Indexed DB update is complete.
	         */
	        this.manualCacheData = (data) => {
	            mcaLogger_1$6.McaLogger.info(this.pre + 'Manually cacheing ' + this.endPoint);
	            const writePromise = new Promise((resolve, reject) => __awaiter$7(this, void 0, void 0, function* () {
	                this.writeSuccess = resolve;
	                this.writeFail = reject;
	                this.doCacheResponse = true;
	                this.handleRestResponse(data);
	            }));
	            return writePromise;
	        };
	        this.delete = () => {
	            return mca_indexed_db_manager_1.McaIndexedDbManager.getInstance().performIndexDbOperation({
	                data: this.endPoint,
	                objectStorage: McaRestHelper.TABLE,
	                operation: mca_indexed_db_manager_1.Operation.DELETE
	            });
	        };
	        this.getSessionId = () => {
	            let sessionId = oj_mca_common_1$8.McaCommon.getSessionId();
	            if (!sessionId) {
	                // We were unable to retrieve the applcore/fnd user session; just create a new id to force the rest call
	                sessionId = 'NOTFOUND_' + Date.now();
	            }
	            return sessionId;
	        };
	        this.getRecordFromIDB = () => {
	            mcaLogger_1$6.McaLogger.info(`${this.pre} Retrieving record ` + this.endPoint);
	            mca_indexed_db_manager_1.McaIndexedDbManager.getInstance().performIndexDbOperation({
	                data: this.endPoint,
	                objectStorage: McaRestHelper.TABLE,
	                operation: mca_indexed_db_manager_1.Operation.GET
	            })
	                .then(this.dbGetSuccess)
	                .catch(this.dbGetError);
	        };
	        this.dbGetSuccess = (event) => {
	            mcaLogger_1$6.McaLogger.info(this.pre + 'DB Request Success ' + this.endPoint);
	            const result = event;
	            let doRest = true;
	            if (result && result.sessionId && result.payload) {
	                if (result.sessionId === this.sessionId) {
	                    this.handleRestResponse(result.payload);
	                    mcaLogger_1$6.McaLogger.info(this.pre + 'Bypassing REST, DB Successfully loaded ' + this.endPoint);
	                    doRest = false;
	                }
	                else {
	                    mcaLogger_1$6.McaLogger.info(`${this.pre} New User Session Detected [${this.sessionId}] Local DB refresh required ${this.endPoint}`);
	                }
	            }
	            if (doRest) {
	                this.invokeRest();
	            }
	        };
	        this.dbGetError = (event) => {
	            mcaLogger_1$6.McaLogger.info(this.pre + 'DB Request Error ' + this.endPoint);
	            this.invokeRest();
	        };
	        this.invokeRest = () => {
	            if (McaRestHelper.NO_REST === this.contentType) {
	                mcaLogger_1$6.McaLogger.info(this.pre + 'No REST Call required for externally sourced data: ' + this.endPoint);
	                this.handleRestResponse({ failReason: McaRestHelper.NO_REST });
	                return;
	            }
	            mcaLogger_1$6.McaLogger.info(this.pre + 'Invoking REST: ' + this.endPoint);
	            const appExtnObject = this.getAppExtnObject();
	            if (appExtnObject) {
	                this.restRequest = restHelper.get(appExtnObject.extensionId + ':' + this.endPoint, appExtnObject);
	            }
	            else {
	                this.restRequest = restHelper.get(this.endPoint);
	            }
	            if (this.contentType) {
	                const initConfig = { headers: { 'Content-Type': this.contentType } };
	                this.restRequest.initConfiguration(initConfig);
	            }
	            this.restRequest
	                .fetch()
	                .then((result) => {
	                let resultBody = {};
	                if (!result || !result.response || !result.response.status || !result.body) {
	                    mcaLogger_1$6.McaLogger.error(this.pre + 'VB REST FAILED! Invalid response', result);
	                    resultBody.failReason = ToolbarLoadState_1$2.ToolbarLoadState.restFailed;
	                }
	                else {
	                    const status = result.response.status;
	                    if (status === 200) {
	                        mcaLogger_1$6.McaLogger.info(this.pre + 'VB REST SUCCESS: ' + this.endPoint);
	                        resultBody = result.body.result;
	                    }
	                    else {
	                        const statusText = result.response.statusText;
	                        mcaLogger_1$6.McaLogger.error(this.pre + 'VB REST FAILED: ' + this.endPoint + ' status: ' + status +
	                            ' ' + statusText + ' Details: ' + result.body);
	                        resultBody.failReason = ToolbarLoadState_1$2.ToolbarLoadState.restFailed;
	                    }
	                }
	                this.handleRestResponse(resultBody);
	            })
	                .catch((err) => {
	                mcaLogger_1$6.McaLogger.error(this.pre + 'VB REST FAILED! ' + this.endPoint);
	                mcaLogger_1$6.McaLogger.error(err);
	                this.handleRestResponse({ failReason: ToolbarLoadState_1$2.ToolbarLoadState.restFailed });
	            });
	        };
	        this.handleRestResponse = (result) => {
	            this.fetchResponse(result);
	            if (!result) {
	                // We must set the fetchResponse to complete the fetch promise!
	                this.fetchResponse({});
	                return;
	            }
	            if (!this.doCacheResponse) {
	                return;
	            }
	            if (result.failReason) {
	                return;
	            }
	            mcaLogger_1$6.McaLogger.info(this.pre + 'Cacheing ' + this.endPoint);
	            try {
	                const record = { endPoint: this.endPoint, payload: result, sessionId: this.sessionId };
	                mca_indexed_db_manager_1.McaIndexedDbManager.getInstance().performIndexDbOperation({
	                    data: record,
	                    objectStorage: McaRestHelper.TABLE,
	                    operation: mca_indexed_db_manager_1.Operation.PUT
	                })
	                    .then(this.dbUpdateSuccess)
	                    .catch(this.dbUpdateError);
	            }
	            catch (err) {
	                mcaLogger_1$6.McaLogger.warn(this.pre + 'Error cacheing Results in Local DB ' + this.endPoint);
	                mcaLogger_1$6.McaLogger.warn(err);
	                // Ensure the Promises get resolved
	                const errResponse = { failReason: err };
	                this.dbUpdateError(err.response);
	                this.fetchResponse(errResponse);
	            }
	        };
	        this.dbUpdateSuccess = (event) => {
	            mcaLogger_1$6.McaLogger.info(this.pre + 'DB Update Success ' + this.endPoint);
	            if (this.writeSuccess) {
	                try {
	                    this.writeSuccess(event);
	                }
	                catch (err) {
	                }
	                finally {
	                    this.writeSuccess = null;
	                    this.writeFail = null;
	                }
	            }
	        };
	        this.dbUpdateError = (event) => {
	            mcaLogger_1$6.McaLogger.warn(this.pre + 'DB Update Error ' + this.endPoint);
	            if (this.writeFail) {
	                try {
	                    this.writeFail(event);
	                }
	                catch (err) {
	                }
	                finally {
	                    this.writeFail = null;
	                    this.writeSuccess = null;
	                }
	            }
	        };
	        /**
	         * Resolves Promise returned by fetch
	         */
	        this.onFetchResponseHandler = (response) => {
	            mcaLogger_1$6.McaLogger.info(`${this.pre}fetchResponseHandler invoked ` + this.endPoint);
	            try {
	                if (response && response.failReason) {
	                    if (this.readFail) {
	                        this.readFail(response);
	                    }
	                }
	                else {
	                    if (this.readSuccess) {
	                        this.readSuccess(response);
	                    }
	                }
	            }
	            catch (err) {
	            }
	            finally {
	                this.readSuccess = null;
	                this.readFail = null;
	            }
	        };
	        /**
	         * Returns a RestHelper extensionObject for VB Unified App UI support
	         * null is returned if this app does not support the VB Unified App UI
	         */
	        this.getAppExtnObject = () => {
	            let retVal = this.appExtnObject;
	            if (!(retVal && retVal.extensionId && retVal.extensionId.trim().length > 0)) {
	                retVal = null;
	            }
	            return retVal;
	        };
	        this.endPoint = endPoint;
	        this.contentType = contentType;
	        this.sessionId = this.getSessionId();
	        this.appExtnObject = extensionObject;
	        this.fetchResponse.subscribe(this.onFetchResponseHandler);
	    }
	}
	mcaRestHelper.McaRestHelper = McaRestHelper;
	McaRestHelper.NO_REST = 'NO_REST';
	McaRestHelper.DBNAME = 'oj-mca';
	McaRestHelper.DBVERSION = 2;
	McaRestHelper.TABLE = 'objects';

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var mcaWindowManager = {};

	var __awaiter$6 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaWindowManager, "__esModule", { value: true });
	mcaWindowManager.WindowManager = void 0;
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	const mcaLogger_1$5 = requireMcaLogger();
	const mca_cache_manager_1$1 = mcaCacheManager;
	const mca$7 = requireMcaCommonTypes();
	const mca_engagement_manager_1$4 = mcaEngagementManager;
	const oj_mca_common_1$7 = requireOjMcaCommon();
	class WindowManager extends mca_cache_manager_1$1.CacheManager {
	    constructor() {
	        super(WindowManager.NAME, new mca$7.McaWindowMap(), WindowManager.desc);
	        this.pre = '[WindowManager] ';
	        this.autoName = 'mcaauto';
	        this.debugMode = true;
	        this.initialized = false;
	        this.attnMsgToggle = false;
	        this.handles = new Map();
	        this.unknownCallerPage = false;
	        this.webNotificationsEnabled = true;
	        this.disableBeforeUnload = false;
	        this.mcaBundle = null;
	        this.isMsiWin = false;
	        this.notificationAudio = null;
	        this.replayAudio = false;
	        this.audioFilePath = null;
	        this.skipThisForUnitTest = false;
	        this.unitTestsOnly = (screenPopTest, engagement5Test, startCommEventSampleTest) => {
	            this.skipThisForUnitTest = true;
	            const map = new mca$7.McaWindowMap();
	            const state = mca$7.McaWindowState.opened;
	            const delta = new mca$7.McaWindowChange('Test', state, mca$7.DeltaType.data);
	            delta.state = mca$7.McaWindowState.focusChanged;
	            map.setDelta(delta);
	            this.processStorageEvent(map);
	            this.updateCacheForReload();
	            this.unloadListener(screenPopTest);
	            this.beforeUnloadListener(screenPopTest);
	            this.updateCacheForUnload();
	            this.checkDupWindow('11', null);
	            this.checkDupWindow('11', 'Test');
	            this.updateCacheForDelete('11');
	            this.getActiveWindowWithKey('11', map);
	            this.updateWindowTitle(null);
	            this.animateTitle();
	            this.setWindowAttn(null);
	            this.focusWindow(null, true);
	            this.focusWindow(null, false);
	            this.updateWindowStatus(screenPopTest);
	            this.updateWindowStatus(null);
	            this.notifyEngagementComplete(engagement5Test.engagementId, engagement5Test.channelType);
	            this.localUpdateWindowStatus(null, screenPopTest);
	            const et = startCommEventSampleTest;
	            et.method = mca$7.McaMethod.closeComm;
	            this.setWindowStatusForEvent(null, et);
	            et.method = mca$7.McaMethod.newMessage;
	            this.setWindowStatusForEvent(null, et);
	            et.method = mca$7.McaMethod.startComm;
	            this.setWindowStatusForEvent(null, et);
	            et.method = mca$7.McaMethod.getConfig;
	            this.setWindowStatusForEvent(null, et);
	            this.skipThisForUnitTest = false;
	            return true;
	        };
	        /**
	         * Implements base class method for processing storage events impacting this window.
	         */
	        this.processStorageEvent = (map) => {
	            const delta = map.getDelta();
	            let ignore = true;
	            if (delta && delta.windowName && delta.windowName === window.name && delta.type !== mca$7.DeltaType.none) {
	                ignore = false;
	            }
	            if (ignore) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring storageEvent ' + delta.toString());
	                return;
	            }
	            if (delta.state === mca$7.McaWindowState.focusChanged) {
	                mcaLogger_1$5.McaLogger.log(`${this.pre} Ignoring storageEvent for focusChanged`);
	                // TODO Check if these should be ignored ...
	                return;
	            }
	            if (delta.windowName === window.name && delta.state === mca$7.McaWindowState.forceClose) {
	                this.closeCurrentWindow();
	                return;
	            }
	            const winMap = this.getMap();
	            const win = winMap.get(window.name);
	            if (!win) {
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'Current window: ' + window.name + ' not found in cache!');
	                if (this.screenPop) {
	                    // We must have been orphaned because a window in a different window
	                    // heirarchy opened a new window with the exact same page key
	                    // Just put an indicator icon in the Tab Title and clear any page reference
	                    const iconPath = this.getImagePath(WindowManager.orphanTabIcon);
	                    this.setFavicon(iconPath);
	                    this.restoreIcon = iconPath;
	                    this.screenPop = null;
	                }
	                return;
	            }
	            if (win.restoreIcon) {
	                this.restoreIcon = win.restoreIcon;
	                this.setFavicon(win.restoreIcon);
	            }
	            if (win.reloadRequired && win.page) {
	                this.updateCacheForReload();
	            }
	            if (win.attnRequired) {
	                this.setWindowAttn(win);
	                // window.alert("****sjmD*** TESTING ON FF!");
	            }
	            // Added for MSI App Screen Pop
	            if (delta.state === mca$7.McaWindowState.engagementAdded && delta.engagementId) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'MSI App Handling trigger ScreenPop for engagement: ' + delta.engagementId);
	                // verify this is an active engagement for this window
	                const engagement = this.getActiveEngagementForMsiWin(win, delta.engagementId);
	                if (engagement) {
	                    this.fireReload(win, null, delta.engagementId);
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'MSI App Handling ignoring ScreenPop for inactive engagement: ' + delta.engagementId);
	                }
	            }
	        };
	        this.updateCacheForReload = () => __awaiter$6(this, void 0, void 0, function* () {
	            if (this.currentWindowName !== window.name) {
	                yield this.updateMapWithWindowChangedName();
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Reload current window: ' + window.name);
	            const winMap = yield this.checkOutMap();
	            const win = winMap.get(window.name);
	            win.reloadRequired = false;
	            const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.none);
	            winMap.setDelta(delta);
	            this.flushCache(winMap);
	            this.updateWindowTitle(win); // added 02-27-20
	            this.fireReload(win);
	        });
	        /**
	         * Override Base Class unload handling, ensure we are handling page reloads
	         */
	        this.unloadListener = (event) => {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Unloading App Window ...' + window.name);
	            const winMap = this.getMap();
	            let win = winMap.get(window.name);
	            if (!win) {
	                win = winMap.get(this.currentWindowName);
	                if (!win) {
	                    return;
	                }
	            }
	            this.updateCacheForUnload();
	        };
	        /**
	         * The beforeUnloadListener will raise a browser Warning Dialog if there is an Active Engagement
	         * associated with the Current Window.
	         * For most browsers the message displayed in the dialog is controlled by the browser.
	         */
	        this.beforeUnloadListener = (event) => {
	            if (this.currentWindowName !== window.name) {
	                this.updateMapWithWindowChangedName();
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'beforeUnload Window ...' + window.name);
	            if (this.isVbEnabled()) {
	                sessionStorage.setItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME, window.name);
	            }
	            const winMap = this.getMap();
	            const win = winMap.get(window.name);
	            let warnMsg = null;
	            if (!win) {
	                return warnMsg;
	            }
	            if (win.page && win.page.engagementId) {
	                // if (this.isUknownCallerPage) {
	                // We Expect a Redirect from the Unknown Contact page so don't raise the Warning Dialog
	                //    return warnMsg;
	                // }
	                if (this.disableBeforeUnload) {
	                    this.disableBeforeUnload = false;
	                    // Don't raise the Warning Dialog when beforeUnload is disabled
	                    return warnMsg;
	                }
	                const engagement = mca_engagement_manager_1$4.EngagementManager.getInstance().getEngagement(win.page.engagementId);
	                if (engagement && engagement.isActive()) {
	                    // Raise the Browsers Unsaved Changes Warning
	                    // warnMsg = this.bundle.activeWarning;
	                    warnMsg = this.getMcaBundleString('activeWarning');
	                    if (!warnMsg) {
	                        warnMsg = 'Are you sure you want to leave during a conversation?';
	                    }
	                    if (event) {
	                        event.returnValue = warnMsg;
	                    }
	                }
	            }
	            if (win.msiPops && win.msiPops.length > 0) {
	                // Trigger Dirty Data Warning for MSI Window!!!
	                warnMsg = this.getMcaBundleString('activeWarning');
	                if (!warnMsg) {
	                    warnMsg = 'Are you sure you want to leave during a conversation?';
	                }
	                if (event) {
	                    event.returnValue = warnMsg;
	                }
	            }
	            return warnMsg;
	        };
	        this.getMcaBundleString = (key) => {
	            let returnString = null;
	            if (this.mcaBundle) {
	                returnString = this.mcaBundle[key];
	            }
	            if (!returnString) {
	                if (this.bundle[key]) {
	                    returnString = this.bundle[key];
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.error(this.pre + 'unable to find mca translation bundle with String key ==> ' + key);
	                    returnString = '*' + key;
	                }
	            }
	            return returnString;
	        };
	        /**
	         * Safety check to ensure we don't reoopen the current page in a new window
	         */
	        this.ensureNewUrl = (url, screenPop) => {
	            let retVal = true;
	            const checkUrl = window.location.href;
	            if (!checkUrl.includes('?')) {
	                return retVal; // if the current page has no params assume it's not a screen pop target
	            }
	            if (url.startsWith(checkUrl)) {
	                const engagement = this.getActiveEngagement();
	                if (engagement && engagement.engagementId !== screenPop.engagementId) {
	                    mcaLogger_1$5.McaLogger.warn(`${this.pre} Opening another instance of this page for new Engagement; old engagementId [${this.screenPop.engagementId}] new engagementId [${screenPop.engagementId}]`);
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'Ignoring Attempt To Open Up Existing Window!');
	                    retVal = false;
	                }
	            }
	            else {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} ensureNewUrl: [${url}] does NOT startsWith [${checkUrl}]`);
	            }
	            return retVal;
	        };
	        this.getImagePath = (imageName) => {
	            if (!this.isVbEnabled()) {
	                return '';
	            }
	            else {
	                // Images are stored in a central location, for details
	                // https://confluence.oraclecorp.com/confluence/display/REX/Uptaking+Oracle+Images+in+Web+Application
	                const imagePath = commonjsRequire.toUrl('oj-ux-icon/' + imageName);
	                return imagePath;
	            }
	        };
	        /**
	         * Update the local window status based upon McaEvent.
	         * This just updates the current window object for use within an existing cache lock.
	         */
	        this.localUpdateWindowStatus = (win, event) => {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Local Updating Current window Status for event: ' + event.method);
	            if (win == null) {
	                return;
	            }
	            this.setWindowStatusForEvent(win, event);
	            if (win.restoreIcon) {
	                this.restoreIcon = win.restoreIcon;
	                this.setFavicon(win.restoreIcon);
	            }
	        };
	        /**
	         * Update the window status for the specified event.
	         */
	        this.setWindowStatusForEvent = (win, event) => {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'setWindowStatus: event: ' + event.method + ' window: ' + ((win) ? win.name : ''));
	            const data = (event) ? event.data : null;
	            let icon;
	            let iconPath;
	            if (!data) {
	                return;
	            }
	            switch (event.method) {
	                case mca$7.McaMethod.closeComm:
	                    icon = WindowManager.channelImageMap[data.channelType].disconnected;
	                    win.engagementActive = false;
	                    break;
	                case mca$7.McaMethod.startComm:
	                    icon = WindowManager.channelImageMap[data.channelType].connected;
	                    win.engagementActive = true;
	                    break;
	                case mca$7.McaMethod.newMessage:
	                    icon = WindowManager.channelImageMap[data.channelType].connected;
	                    win.attnRequired = true;
	                    win.attnIcon = this.getImagePath(WindowManager.channelImageMap[data.channelType].newMessage);
	                    win.engagementActive = true;
	                    break;
	                case mca$7.McaMethod.getScreenPopDataEvent:
	                    // Skip, getScreenPopDataEvent does not change existing active engeagement
	                    // win.engagementActive = false;
	                    break;
	                default:
	                    // For Now Just Assume Active for all unspecified events...
	                    icon = WindowManager.channelImageMap[data.channelType].connected;
	                    win.engagementActive = true;
	                    break;
	            }
	            if (icon) {
	                iconPath = this.getImagePath(icon);
	                win.restoreIcon = iconPath;
	            }
	        };
	        /**
	         * Window Unload Handler.
	         * Ensure we set the unloadTime for this window for cache cleanup.
	         * We can't just remove this from cache now because we must handle the browser refresh case.
	         * Updated 02-28-23 with MSI App Window Handling
	         */
	        this.updateCacheForUnload = () => __awaiter$6(this, void 0, void 0, function* () {
	            if (this.currentWindowName !== window.name) {
	                yield this.updateMapWithWindowChangedName();
	            }
	            const winMap = yield this.checkOutMap();
	            const myWin = winMap.get(window.name);
	            if (!myWin) {
	                this.undoCheckOut(winMap);
	                return;
	            }
	            myWin.unloadTime = new Date().getTime();
	            myWin.appType = null;
	            if (this.restoreIcon) {
	                myWin.restoreIcon = this.restoreIcon;
	            }
	            let newPrimary = null;
	            if (myWin.isPrimary) {
	                // Check if we need to migrate isPrimary to another window
	                for (const key of winMap.keys()) {
	                    const tempWin = winMap.get(key);
	                    if (myWin.name === tempWin.name) {
	                        continue;
	                    }
	                    if (!tempWin.unloadTime) {
	                        newPrimary = tempWin;
	                        if (tempWin.isMsi) {
	                            // Setting another MSI Window to the primary
	                            break;
	                        }
	                    }
	                }
	            }
	            if (newPrimary) {
	                myWin.isPrimary = false;
	                myWin.isMsi = null; // if we are doing a browser refresh this will be reset during page reload
	                newPrimary.isPrimary = true;
	            }
	            const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.unloading, mca$7.DeltaType.state);
	            winMap.setDelta(delta);
	            this.flushCache(winMap);
	        });
	        this.fireReload = (win, screenPop, engagementId) => {
	            if (win.name !== window.name) {
	                return;
	            }
	            const detail = {};
	            if (screenPop && screenPop.engagementId) {
	                detail.engagementId = screenPop.engagementId;
	            }
	            else if (engagementId) {
	                detail.engagementId = engagementId;
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Firing mcaForceReload event engagementId: ' + detail.engagementId);
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const ce = new CustomEvent(mca$7.McaEventType.forceReload, formattedEvent);
	            window.dispatchEvent(ce);
	        };
	        this.visibilityListener = (event) => {
	            const hasFocus = !document.hidden;
	            if (hasFocus === this.hasFocus) {
	                return; // no change required
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'visibilitychange: ' + hasFocus, event);
	            this.setFocusChange(hasFocus);
	        };
	        this.setFocusChange = (hasFocus) => __awaiter$6(this, void 0, void 0, function* () {
	            if (this.currentWindowName !== window.name) {
	                yield this.updateMapWithWindowChangedName();
	            }
	            this.hasFocus = hasFocus;
	            {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} No longer caching window focus state`);
	                return;
	            }
	        });
	        this.findWinByKey = (searchKey, winMap) => {
	            let win;
	            for (const key of winMap.keys()) {
	                win = winMap.get(key);
	                if (searchKey === win.key) {
	                    break;
	                }
	                else {
	                    win = null;
	                }
	            }
	            return win;
	        };
	        this.findWinByEngagement = (engagementId, winMap) => {
	            var _b, _c, _d, _e, _f, _g, _h;
	            let win = null;
	            for (const key of winMap.keys()) {
	                win = winMap.get(key);
	                if (win.isMsi && win.msiPops) {
	                    const activeEngagement = this.getActiveEngagementForMsiWin(win, engagementId);
	                    if (activeEngagement) {
	                        break;
	                    }
	                }
	                const interactionId = (_c = (_b = mca_engagement_manager_1$4.EngagementManager.getInstance()) === null || _b === void 0 ? void 0 : _b.getEngagement(engagementId)) === null || _c === void 0 ? void 0 : _c.interactionId;
	                const windowEngagementId = (_d = win === null || win === void 0 ? void 0 : win.page) === null || _d === void 0 ? void 0 : _d.engagementId;
	                const windowInteractionId = (_h = (_g = (_f = (_e = win === null || win === void 0 ? void 0 : win.page) === null || _e === void 0 ? void 0 : _e.mcaRefEvent) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.inData) === null || _h === void 0 ? void 0 : _h.SVCMCA_INTERACTION_ID;
	                if (windowEngagementId !== undefined && windowInteractionId !== undefined && engagementId === windowEngagementId && interactionId === windowInteractionId) {
	                    break;
	                }
	                else {
	                    win = null;
	                }
	            }
	            return win;
	        };
	        /**
	         * async function to ensure no windows with the specified key exist.
	         * If so, it will auto close this window and send a notification to the existing
	         * window to start the Attention Indicator. This was intended to prevent right-click on object links from
	         * opening duplicate windows.
	         */
	        this.checkDupWindow = (key, notifyMsg) => __awaiter$6(this, void 0, void 0, function* () {
	            if (!notifyMsg) {
	                notifyMsg = 'Link Opened';
	            }
	            const dbgStart = Date.now();
	            while (true) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Waiting on original window with key: ' + key);
	                yield oj_mca_common_1$7.McaCommon.sleep(5000);
	                const winMap = this.getMap();
	                let win = this.getActiveWindowWithKey(key, winMap);
	                if (win) {
	                    // another window with this key is active, shutdown this window
	                    this.notifyWindowForPageKey(key, notifyMsg);
	                    this.closeCurrentWindow();
	                    break;
	                }
	                else {
	                    // check if another window w/ this key is still reloading ...
	                    for (const name of winMap.keys()) {
	                        win = winMap.get(name);
	                        if (key === win.key && win.unloadTime && win.name !== window.name) {
	                            break;
	                        }
	                        else {
	                            win = null;
	                        }
	                    }
	                }
	                if (!win) {
	                    // orig must be closed!!!
	                    mcaLogger_1$5.McaLogger.info(this.pre + '[OK] Original window with key: ' + key + ' must be closed');
	                    break;
	                }
	                else {
	                    if (win.unloadTime) {
	                        const currTime = Date.now();
	                        if (currTime - win.unloadTime > WindowManager.CLOSE_TIMEOUT) {
	                            mcaLogger_1$5.McaLogger.info(this.pre +
	                                'Force Removing Original window (' +
	                                win.name +
	                                ') with key: ' +
	                                key +
	                                ', exceeded timeout');
	                            this.updateCacheForDelete(win.name);
	                            break;
	                        }
	                        continue; // wait some more...
	                    }
	                }
	            }
	            const dbgEnd = Date.now();
	            mcaLogger_1$5.McaLogger.info(this.pre + 'checkDupWindow leaving after ' + (dbgEnd - dbgStart) + ' ms');
	        });
	        this.updateCacheForDelete = (name) => __awaiter$6(this, void 0, void 0, function* () {
	            let winMap = this.getMap();
	            const win = winMap.get(name);
	            if (win) {
	                winMap = yield this.checkOutMap();
	                winMap.remove(name);
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.deleted, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                this.flushCache(winMap);
	            }
	        });
	        /**
	         * Retrieve an "active" window with the specified key that is not this window
	         */
	        this.getActiveWindowWithKey = (searchKey, winMap) => {
	            let retVal;
	            let win;
	            for (const key of winMap.keys()) {
	                win = winMap.get(key);
	                if (searchKey === win.key && !win.unloadTime && win.name !== window.name) {
	                    retVal = win;
	                    break;
	                }
	                else {
	                    win = null;
	                }
	            }
	            return retVal;
	        };
	        this.requestPermission = () => {
	            mcaLogger_1$5.McaLogger.info(`${this.pre} requesting Notification permissions`);
	            Notification.requestPermission()
	                .then((permission) => {
	                if (permission === mca$7.Permission.granted) {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} Notifications are granted`);
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} Notifications are disabled ${permission}`);
	                }
	            })
	                .catch((err) => {
	                mcaLogger_1$5.McaLogger.error(`${this.pre} Error in requestPermission`, err);
	            });
	        };
	        /**
	         * Invoked during window initialization to:
	         * 1. Insert this window into cache if not there
	         * 2. Update this window cache entry to active in browser refresh/navigation case
	         * 3. Clean Up Previously Closed / Windows from an Old Session
	         * 4. Ensure there is always a single Primary Window set in case we removed the primary window
	         * @returns
	         */
	        this.init = () => __awaiter$6(this, void 0, void 0, function* () {
	            var _b;
	            if (this.initialized) {
	                return;
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Loading App Window ...');
	            this.bundle = Object.assign({}, oj_mca_common_1$7.McaCommon.mcaCoreStrings);
	            this.requestPermission();
	            // EventListener(s) now set in base class
	            window.addEventListener('visibilitychange', this.visibilityListener);
	            window.addEventListener('focus', this.visibilityListener);
	            window.addEventListener('blur', this.visibilityListener);
	            window.addEventListener('beforeunload', this.beforeUnloadListener);
	            const winMap = yield this.checkOutMap();
	            try {
	                const name = window.name;
	                let win;
	                // Logic to handle previous window name while navigating back and forth between Redwood and ADF pages
	                this.currentWindowName = name;
	                // If this is a Screen Pop this returns the Parent Window
	                const checkPrevWinName = sessionStorage.getItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME);
	                if (checkPrevWinName === this.currentWindowName) {
	                    // removing the entry from session storage for page refresh
	                    sessionStorage.removeItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME);
	                }
	                if (this.isVbEnabled()) { // Redwood window
	                    const currentWin = winMap.get(this.currentWindowName);
	                    if (checkPrevWinName && checkPrevWinName !== name && !(currentWin === null || currentWin === void 0 ? void 0 : currentWin.engagementActive)) { // engagementActive true for screenpop so donot replace with prev win
	                        const openerName = (_b = window.opener) === null || _b === void 0 ? void 0 : _b.name;
	                        if (checkPrevWinName !== openerName) {
	                            // sjmD: We are returning to a Redwood Window from an ADF Window
	                            // If the Old Window is found in Cache Rename it to the name Changed by ADF
	                            // this.currentWindowName = checkPrevWinName; 
	                            if (winMap.has(checkPrevWinName)) {
	                                console.warn(`${this.pre}Renaming old Window ${checkPrevWinName} --> ${name}`);
	                                win = winMap.get(checkPrevWinName);
	                                winMap.remove(checkPrevWinName);
	                                win.name = name;
	                                winMap.put(name, win);
	                            }
	                        }
	                    }
	                }
	                const state = mca$7.McaWindowState.opened;
	                if (winMap.has(name)) {
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'This app window was already defined: ' + name);
	                    win = winMap.get(name);
	                    this.updateWindowTitle(win);
	                    this.screenPop = win.page;
	                    if (win.isMsi) {
	                        this.isMsiWin = win.isMsi;
	                    }
	                    // if (win.page && win.page.pageName === mca.Constants.UNKNOWN_PAGE) {
	                    if (win.page && win.page.isUnknownCallerPage) {
	                        this.unknownCallerPage = true;
	                    }
	                }
	                else {
	                    win = {};
	                    win.name = name;
	                    // Handle links opened in new Browser Tabs
	                    win.key = this.getPageParam(WindowManager.PARAM_KEYS.PAGE_KEY);
	                    if (win.key) {
	                        const blockDups = this.getPageParam(WindowManager.PARAM_KEYS.BLOCK_DUPS);
	                        mcaLogger_1$5.McaLogger.info(this.pre + 'Checking pageKey: ' + win.key + ' blockDupWindows: ' + blockDups);
	                        let altWin = this.findWinByKey(win.key, winMap);
	                        if (altWin && blockDups === 'true') {
	                            mcaLogger_1$5.McaLogger.info(this.pre + 'Preexisting window found with pageKey: ' + win.key);
	                            // A window with this key already exists!
	                            // if (this.focusWindow(altWin))  This is just a waste of time
	                            // If this window was manually opened (e.g. right click on link and "open in new tab")
	                            // we can't get a handle to the existing window
	                            if (!altWin.unloadTime) {
	                                this.notifyWindowForPageKey(win.key, 'Link Opened', null, winMap);
	                                window.close();
	                                return;
	                            }
	                            else {
	                                altWin = this.getActiveWindowWithKey(win.key, winMap);
	                                if (altWin) {
	                                    this.notifyWindowForPageKey(win.key, 'Link Opened', null, winMap);
	                                    window.close();
	                                    return;
	                                }
	                                mcaLogger_1$5.McaLogger.info(this.pre + 'Seems another window with this pageKey may be reloading ... starting waiter');
	                                // Invoke async method to wait for the original page to either finish reloading or be marked as closed...
	                                this.checkDupWindow(win.key);
	                            }
	                        }
	                    }
	                    else {
	                        mcaLogger_1$5.McaLogger.info(this.pre + 'This window unavailable for search/focus missing param: pageKey');
	                        win.key = name; // no need to search for these
	                    }
	                    const favicon = document.querySelector('link[rel="icon"]');
	                    if (favicon) {
	                        this.restoreIcon = favicon.getAttribute('href');
	                    }
	                    if (this.isFocused()) {
	                        win.hasFocus = true;
	                        // Clear focus on all other windows
	                        const keys = winMap.keys();
	                        for (const key of keys) {
	                            const existingWin = winMap.get(key);
	                            if (existingWin) {
	                                existingWin.hasFocus = false;
	                            }
	                        }
	                    }
	                    else {
	                        win.hasFocus = false;
	                    }
	                    winMap.put(name, win);
	                }
	                // sjm - 05-07-21 Always reset session and time
	                win.sessionId = oj_mca_common_1$7.McaCommon.getSessionId();
	                // 02-28-23 - Ensure the sessionId is ALWAYS set!!!
	                if (win.sessionId === 'NOT_SET' || win.sessionId === 'NOT_AVAILABLE') {
	                    if (window.faConfig && window.faConfig.APPL_SESSION_ID) {
	                        win.sessionId = window.faConfig.APPL_SESSION_ID;
	                        oj_mca_common_1$7.McaCommon.setSessionId(win.sessionId);
	                    }
	                    else {
	                        mcaLogger_1$5.McaLogger.error(this.pre + 'Unable to set sessionId for window');
	                    }
	                }
	                win.createTime = new Date().getTime();
	                win.unloadTime = null;
	                win.appType = this.isVbEnabled() ? mca$7.UiTypeToken.redwood : mca$7.UiTypeToken.adf;
	                let primaryFound = false;
	                if (winMap.size() > 1) {
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'Found (' + winMap.size() + ') existing App Windows');
	                    const currTime = new Date().getTime();
	                    // TODO reuse base class purge processing .....
	                    // Clean up stale windows
	                    this.cleanupStaleWindows(winMap);
	                    // Prevent case where we end up with engagements in multiple MSI Windows.
	                    // In case we migrated the primary window to an alternate MSI Window following
	                    // a browser refresh while in an MSI Window with Active Engagements
	                    let resetPrimary = false;
	                    if (win.msiPops && win.msiPops.length > 0 && !win.isPrimary) {
	                        resetPrimary = true;
	                    }
	                    for (const key of winMap.keys()) {
	                        const val = winMap.get(key);
	                        if (val.isPrimary && !val.unloadTime) {
	                            primaryFound = true;
	                            if (key === name) {
	                                mcaLogger_1$5.McaLogger.info(this.pre + 'This is already set as the Primary App Window.');
	                            }
	                            else {
	                                if (resetPrimary) {
	                                    mcaLogger_1$5.McaLogger.warn(this.pre + 'Detected Active Engagements in this MSI Window. Stealing Primary from ' + val.name);
	                                    val.isPrimary = false;
	                                    win.isPrimary = true;
	                                }
	                                else if (val.appType !== mca$7.UiTypeToken.redwood && win.appType === mca$7.UiTypeToken.redwood) {
	                                    mcaLogger_1$5.McaLogger.warn(this.pre + 'Forcing Primary Window from  ADF to a Redwood Page.  Stealing Primary from ' + val.name);
	                                    val.isPrimary = false;
	                                    win.isPrimary = true;
	                                }
	                            }
	                            break;
	                        }
	                    }
	                }
	                if (!primaryFound && win.name !== mca$7.Constants.TOOLBAR_WINDOW) {
	                    win.isPrimary = true;
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'Setting this as the Primary App Window.');
	                }
	                const delta = new mca$7.McaWindowChange(window.name, state);
	                this.flushCache(winMap);
	                this.initialized = true;
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(`${this.pre} Exception in init ${err}`);
	                this.undoCheckOut(winMap);
	            }
	        });
	        /**
	         * Get URL param for current page
	         * @param param - The name of the parameter to retrieve
	         */
	        this.getPageParam = (param) => {
	            const pgUrl = window.location.href;
	            const url = new URL(pgUrl);
	            const retVal = url.searchParams.get(param);
	            return retVal;
	        };
	        this.localIsPrimaryWindow = (winMap) => {
	            let retVal = false;
	            const winName = window.name;
	            if (winMap.has(winName)) {
	                const win = winMap.get(winName);
	                retVal = win.isPrimary;
	            }
	            else if (winName !== this.currentWindowName && winMap.has(this.currentWindowName)) {
	                const winCache = winMap.get(this.currentWindowName);
	                retVal = winCache.isPrimary;
	                // will need to replace the entry in map with the new window name
	                this.updateMapWithWindowChangedName();
	            }
	            else {
	                mcaLogger_1$5.McaLogger.warn(this.pre + "isPrimaryWindow: can't find current window entry!");
	            }
	            return retVal;
	        };
	        // <TODO This should no longer be necessary>
	        this.updateMapWithWindowChangedName = () => __awaiter$6(this, void 0, void 0, function* () {
	            let winMap = this.getMap();
	            const winCache = winMap.get(this.currentWindowName);
	            if (winCache) {
	                winMap = yield this.checkOutMap();
	                winCache.name = window.name;
	                winCache.unloadTime = null;
	                const currentWindow = winMap.get(window.name);
	                if (currentWindow) {
	                    winCache.isMsi = currentWindow.isMsi;
	                    winCache.hasFocus = currentWindow.hasFocus;
	                }
	                winMap.put(window.name, winCache);
	                mcaLogger_1$5.McaLogger.warn(`${this.pre} Removing ${this.currentWindowName}`);
	                winMap.remove(this.currentWindowName); // sjmD - This is deleting our Windows during Screen Pop Window Loading!!!)
	                const delta = new mca$7.McaWindowChange(this.currentWindowName, mca$7.McaWindowState.deleted, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                this.flushCache(winMap);
	                const winHandle = this.handles.get(this.currentWindowName);
	                if (winHandle) {
	                    this.handles.set(window.name, winHandle);
	                }
	                this.currentWindowName = window.name;
	            }
	        });
	        this.updateWindowTitle = (win) => {
	            let iconPath = (win) ? win.restoreIcon : '';
	            if (win && win.page) {
	                const title = win.page.pageTitle;
	                if (title) {
	                    document.title = title;
	                }
	                if (!iconPath) {
	                    let icon = win.page.pageIcon;
	                    if (!icon) {
	                        icon = WindowManager.orphanTabIcon;
	                    }
	                    iconPath = this.getImagePath(icon);
	                }
	            }
	            this.restoreIcon = iconPath;
	            this.setFavicon(iconPath);
	        };
	        this.setFavicon = (iconPath) => {
	            if (!iconPath || iconPath.trim() === '') {
	                return;
	            }
	            let favicon = document.querySelector('link[rel="icon"]');
	            if (!favicon) {
	                favicon = document.createElement('link');
	                favicon.setAttribute('type', 'image/x-icon');
	                favicon.setAttribute('rel', 'icon'); // 'shortcut icon'
	                document.getElementsByTagName('head')[0].appendChild(favicon);
	            }
	            favicon.setAttribute('href', iconPath);
	        };
	        this.animateTitle = () => __awaiter$6(this, void 0, void 0, function* () {
	            if (this.isFocused()) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'stopping attnTimer: ' + this.attnTimer);
	                clearInterval(this.attnTimer);
	                this.attnTimer = null;
	                document.title = this.restoreTitle;
	                this.setFavicon(this.restoreIcon);
	                const winMap = yield this.checkOutMap();
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                const freshWin = winMap.get(window.name);
	                if (freshWin) {
	                    freshWin.attnRequired = false;
	                    freshWin.attnMessage = '';
	                    freshWin.attnIcon = null;
	                }
	                this.flushCache(winMap);
	                this.mWin = null;
	                this.attnIcon = null;
	                this.attnMsgToggle = false;
	                return;
	            }
	            this.attnMsgToggle = true; // DEV NOTE: Comment Out this line to Animate the Browser Tab Icon!!!
	            this.attnMsgToggle = !this.attnMsgToggle;
	            if (this.attnMsgToggle) {
	                document.title = this.restoreTitle;
	                this.setFavicon(this.restoreIcon);
	            }
	            else {
	                document.title = this.mWin.attnMessage;
	                const winMap = this.getMap();
	                const win = winMap.get(window.name);
	                if (win && win.attnIcon) {
	                    this.setFavicon(win.attnIcon);
	                    document.title = win.attnMessage;
	                }
	                else {
	                    this.setFavicon(this.attnIcon);
	                }
	            }
	        });
	        /**
	         * Starts Browser Tab Animation for the Current Window
	         */
	        this.setWindowAttn = (win) => {
	            if (this.attnTimer || win == null) {
	                // McaLogger.info(this.pre + 'Ignoring window attention for: ' + win.attnMessage);
	                return;
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Starting window attention for: ' + ((win) ? win.attnMessage : ''));
	            this.mWin = win;
	            this.restoreTitle = document.title;
	            if (win.attnIcon) {
	                this.attnIcon = win.attnIcon;
	            }
	            this.animateTitle();
	            // somewhere along the way the node.js  setInterval typing started getting used for tsc...
	            this.attnTimer = window.setInterval(this.animateTitle, 1000);
	            mcaLogger_1$5.McaLogger.info(this.pre + 'started attnTimer: ' + this.attnTimer);
	            if (this.isMsiApp()) {
	                if (!this.isFocused()) {
	                    // fill in the logic to determine event type (call/chat) here
	                    if (win.attnChannelType) {
	                        if (win.attnChannelType === mca$7.ChannelType.chat) {
	                            const iconPathChat = commonjsRequire.toUrl('oj-mca/main/images/push-notify-chat.png');
	                            const chatWebNotification = {
	                                engagementId: '1',
	                                icon: iconPathChat,
	                                initialDisplay: false,
	                                message: this.getMcaBundleString('switchTabForChatDetail'),
	                                title: this.getMcaBundleString('switchTabForChat')
	                            };
	                            this.displayWebNotification(chatWebNotification);
	                        }
	                        else {
	                            const iconPathCall = commonjsRequire.toUrl('oj-mca/main/images/push-notify-phone.png');
	                            const callWebNotification = {
	                                engagementId: '1',
	                                icon: iconPathCall,
	                                initialDisplay: false,
	                                message: this.getMcaBundleString('switchTabForCallDetail'),
	                                title: this.getMcaBundleString('switchTabForCall')
	                            };
	                            this.displayWebNotification(callWebNotification);
	                        }
	                    }
	                    // following no longer forcefully grabs focus in chrome
	                    // window.alert(win.attnMessage);
	                }
	            }
	        };
	        this.getAppWindowSpecs = () => {
	            const specs = '';
	            // Forces new browser window! specs = "location=no,";
	            return specs;
	        };
	        this.genAutoWinName = (winMap) => {
	            let ts = new Date().getTime();
	            let retVal = ts.toString(36).substr(2);
	            while (winMap.has(retVal)) {
	                ts++;
	                retVal = ts.toString(36).substr(2);
	            }
	            return retVal;
	        };
	        /**
	         * Returns the Screen Pop Page Path, the MSI App Path if Required
	         */
	        this.getPagePath = (screenPop) => {
	            let pagePath = screenPop.pagePath;
	            if (screenPop.displayMode === mca$7.PageDisplayMode.MsiWindow) {
	                let msiPath = null;
	                let vbDtSupport = false;
	                switch (oj_mca_common_1$7.McaCommon.getAppName()) {
	                    case mca$7.AppName.mca:
	                        // msiPath = '/vp/main/servicelist/main-mca-contact/main-mca-contact-msi';
	                        msiPath = '/vp/main/servicelist/main-mca-contact/main-mca-communication-wrapper-test';
	                        vbDtSupport = true;
	                        break;
	                    case mca$7.AppName.service:
	                        msiPath = '/redwood/service/ec';
	                        vbDtSupport = true;
	                        break;
	                    case mca$7.AppName.spectra:
	                        msiPath = '/vp/sp-comp-usage-demos/oj-mca-presence-demo';
	                        vbDtSupport = true;
	                        break;
	                    default:
	                        msiPath = '/redwood/service/ec';
	                        break;
	                }
	                const isVbDtMode = this.isVbMode(mca$7.Constants.VB_DT_MODE);
	                if (isVbDtMode && vbDtSupport) {
	                    pagePath = msiPath;
	                }
	                if (!isVbDtMode) {
	                    pagePath = msiPath;
	                }
	            }
	            return pagePath;
	        };
	        this.isVbEnabled = () => {
	            if (window.vb && window.vb.version) {
	                return true;
	            }
	            else {
	                return false;
	            }
	        };
	        this.isVbMode = (vbMode) => {
	            let retVal = false;
	            let vbConfig = [];
	            if (window[mca$7.Constants.VB_CONFIG]) {
	                vbConfig = window[mca$7.Constants.VB_CONFIG];
	            }
	            retVal = vbConfig[vbMode];
	            return retVal;
	        };
	        this.constructUrl = (screenPop) => {
	            const pagePath = this.getPagePath(screenPop);
	            const pageParams = screenPop.pageParams;
	            const path = window.location.pathname;
	            let url = '';
	            let vbConfig = [];
	            if (window[mca$7.Constants.VB_CONFIG]) {
	                vbConfig = window[mca$7.Constants.VB_CONFIG];
	            }
	            const isAdfEnabled = !this.isVbEnabled();
	            const isVbDtMode = this.isVbMode(mca$7.Constants.VB_DT_MODE);
	            const isLocalMode = this.isVbMode(mca$7.Constants.LOCAL_MODE);
	            if (isAdfEnabled) {
	                let baseUrl = window.location.protocol + '//' + window.location.host;
	                if (screenPop.crossAppNaviFaEndpoint === 'ORA_FSCM_UI') {
	                    baseUrl = baseUrl + '/fscmUI';
	                }
	                else if (screenPop.crossAppNaviFaEndpoint === 'ORA_CRM_UI') {
	                    baseUrl = baseUrl + '/crmUI';
	                }
	                else {
	                    baseUrl = baseUrl + '/fscmUI';
	                }
	                url = baseUrl + pagePath;
	            }
	            else if (isVbDtMode) {
	                // Running in VBDT
	                let baseUrl = vbConfig[mca$7.Constants.VB_DT_APP_CONFIG].applicationUrl;
	                // Note: the baseUrl ends with the appName and the pagePath begins with appName
	                if (baseUrl.endsWith('/')) {
	                    baseUrl = baseUrl.substr(0, baseUrl.length - 1);
	                }
	                const lastIndex = baseUrl.lastIndexOf('/');
	                if (lastIndex !== -1) {
	                    baseUrl = baseUrl.substr(0, lastIndex);
	                }
	                url = baseUrl + pagePath;
	            }
	            else if (isLocalMode) {
	                // Run in local express server
	                // Only support screen pops in local mca app
	                let index = path.indexOf(mca$7.AppName.mca);
	                if (index > 0) {
	                    index += mca$7.AppName.mca.length;
	                    const baseUrl = path.substring(0, index);
	                    url = baseUrl + pagePath;
	                }
	                else {
	                    // Error No Screen Pop Supported
	                    mcaLogger_1$5.McaLogger.error(`${this.pre} Screenpop supported locally only in MCA test application.`);
	                    throw new Error('Screenpop supported locally only in MCA test application');
	                }
	            }
	            else {
	                // Run in deployed environment
	                // GET URL Base using faEndPoint: baseUrl = window.FAEndPoints[faEndPoint]; realUrl = baseUrl + pagePath; }
	                let baseFaEndPoint = null;
	                if (window[mca$7.Constants.FA_ENDPOINTS]) {
	                    const endPoints = window[mca$7.Constants.FA_ENDPOINTS];
	                    baseFaEndPoint = endPoints[screenPop.crossAppNaviFaEndpoint];
	                }
	                if (!baseFaEndPoint) { // This maybe an issue
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'window variable ' + screenPop.crossAppNaviFaEndpoint + ' is not defined!!');
	                    const index = path.indexOf('/vp/');
	                    if (index < 0) {
	                        mcaLogger_1$5.McaLogger.info(this.pre + 'constructUrl: URL Path does not have expected format - using as is: ' + path);
	                        baseFaEndPoint = path;
	                    }
	                    else {
	                        baseFaEndPoint = path.substring(0, index);
	                    }
	                    url = baseFaEndPoint + '/vp/ec/container/contacts/unknown-caller';
	                }
	                else {
	                    if (baseFaEndPoint.endsWith('/')) {
	                        // If baseFaEndPoint ends with "/", remove it, as pathPath starts with "/"
	                        baseFaEndPoint = baseFaEndPoint.substr(0, baseFaEndPoint.length - 1);
	                    }
	                    url = baseFaEndPoint + pagePath;
	                }
	            }
	            // only need to substitute parameters with token in default screen pop maps
	            // Redwood Screen pop data already proivde the parameters with values
	            if (pageParams && screenPop.useDefaultScreenPopData) {
	                let paramString = null;
	                if (!screenPop.paramMapUsed) {
	                    // If screen pop param map is not used
	                    if (url.includes('?')) {
	                        paramString = '&';
	                    }
	                    else {
	                        paramString = '?';
	                    }
	                    let ftt = true;
	                    for (const key of Object.keys(pageParams)) {
	                        if (ftt) {
	                            ftt = false;
	                        }
	                        else {
	                            paramString += '&';
	                        }
	                        const val = pageParams[key];
	                        const encPair = encodeURI(key + '=' + val);
	                        paramString += encPair;
	                    }
	                    // Handle screen pop failure, add screen pop failure parameteres
	                    //
	                    if (screenPop.screenPopFailureHandling === true) {
	                        let spHandlingString = '&screenPopFailureHandling=Y';
	                        // Add callerName, callType, callerId to parameter for screen pop failure handling
	                        if (pageParams[mca$7.SystemToken.contactId] != null) {
	                            spHandlingString += '&callerType=contact&callerId=' + pageParams[mca$7.SystemToken.contactId];
	                            if (pageParams[mca$7.SystemToken.contactName] !== null) {
	                                spHandlingString += '&callerName=' + pageParams[mca$7.SystemToken.contactName];
	                            }
	                        }
	                        else if (pageParams[mca$7.SystemToken.leadId] != null) {
	                            spHandlingString += '&callerType=lead&callerId=' + pageParams[mca$7.SystemToken.leadId];
	                            if (pageParams[mca$7.SystemToken.leadName] !== null) {
	                                spHandlingString += '&callerName=' + pageParams[mca$7.SystemToken.leadName];
	                            }
	                        }
	                        paramString += spHandlingString;
	                    }
	                }
	                else {
	                    // If screen pop param map used
	                    let ftt = true;
	                    for (const key of Object.keys(pageParams)) {
	                        if (ftt) {
	                            ftt = false;
	                        }
	                        else {
	                            paramString += '^^';
	                        }
	                        const val = pageParams[key];
	                        const encPair = encodeURI(key + '=' + val);
	                        paramString += encPair;
	                    }
	                    paramString += '^^';
	                }
	                url += paramString;
	            }
	            return url;
	        };
	        this.getActiveEngagementForMsiWin = (win, engagementId) => {
	            let engagement = null;
	            try {
	                if (win.msiPops && win.msiPops.length > 0) {
	                    for (let i = 0; i < win.msiPops.length; i++) {
	                        const screenPop = win.msiPops[i];
	                        if (screenPop && screenPop.engagementId === engagementId) {
	                            engagement = mca_engagement_manager_1$4.EngagementManager.getInstance().getEngagement(screenPop.engagementId);
	                            if (!engagement.isActive()) {
	                                engagement = null;
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(`${this}Error finding activeMsiEngagement ${err}`);
	            }
	            return engagement;
	        };
	        /**
	         * Adds the ScreenPop to the MSI Window.
	         * @returns false if this Screen Pop is already in the Window
	         */
	        this.addMsiScreenPop = (win, screenPop) => {
	            let retVal = true;
	            if (!win.msiPops) {
	                win.msiPops = new Array();
	            }
	            for (let i = 0; i < win.msiPops.length; i++) {
	                if (win.msiPops[i] && win.msiPops[i].engagementId === screenPop.engagementId) {
	                    mcaLogger_1$5.McaLogger.warn(`${this.pre}Screen Pop already in MSI App Window for Engagement ${screenPop.engagementId}`);
	                    retVal = false;
	                }
	            }
	            if (retVal) {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Adding Screen Pop to MSI App Window for Engagement ${screenPop.engagementId}`);
	                win.msiPops.push(screenPop);
	            }
	            return retVal;
	        };
	        /**
	         * Retrieves the "MSI App Window".  There is only a single MSI App Window where we show Engagements.
	         * This should be the Primary Window but, just in case we have an MSI App Window that is NOT tagged as such
	         * then check the one with Engagements. Lastly, just return the last MSI App Window in our map.
	         */
	        this.findMsiAppWin = (winMap) => {
	            let win;
	            const msiWinList = new Array();
	            let foundPrimaryMsiWin = null;
	            for (const key of winMap.keys()) {
	                win = winMap.get(key);
	                if (win.unloadTime) {
	                    continue;
	                }
	                if (win.isPrimary && win.isMsi) {
	                    foundPrimaryMsiWin = win;
	                    break;
	                }
	                if (win.isMsi) {
	                    msiWinList.push(win);
	                }
	            }
	            if (!foundPrimaryMsiWin && msiWinList.length > 0) {
	                for (let i = 0; i < msiWinList.length; i++) {
	                    const msiWin = msiWinList[i];
	                    if (msiWin.msiPops && msiWin.msiPops.length > 0 || msiWin.hasFocus) {
	                        foundPrimaryMsiWin = msiWin;
	                        foundPrimaryMsiWin.isPrimary = true;
	                        break;
	                    }
	                    else {
	                        foundPrimaryMsiWin = win;
	                    }
	                }
	            }
	            return foundPrimaryMsiWin;
	        };
	        /**
	         * Used in case we are unable to auto-focus a Window in a different Window Heirarchy
	         * This will "animate" the Browser Tab by switching the Title/Icon
	         */
	        this.setTriggerTabAttention = (win, screenPop) => {
	            // Set attn indicator in case focus isn't honored
	            const icon = WindowManager.orphanTabIcon;
	            const iconPath = this.getImagePath(icon);
	            if (screenPop && screenPop.mcaRefEvent && screenPop.mcaRefEvent.data) {
	                win.attnChannelType = screenPop.mcaRefEvent.data.channelType;
	            }
	            win.attnIcon = iconPath;
	            win.attnMessage = this.getMcaBundleString('statusActive');
	            win.attnRequired = true;
	        };
	        this.openUrl = (url, specs, win, screenPop, winMap, searchKey, delta) => {
	            let retVal = true;
	            const winName = win.name;
	            try {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Opening URL: ' + url);
	                const handle = window.open(url, winName, specs);
	                if (handle) {
	                    const ref = handle.location.href;
	                    handle.sessionStorage.removeItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME);
	                    this.handles.set(winName, handle);
	                    handle.focus();
	                    window.blur();
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.error(this.pre + "**Check Your Popup Blocker** couldn't open window " + winName + ' at ' + url);
	                    // 10-22-21 No longer removing the entry because Rajesh wants the call to show up via the popup blocker link
	                    // winMap.remove(winName);
	                    retVal = false;
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(this.pre + 'Exception in openUrl');
	                mcaLogger_1$5.McaLogger.error(err);
	                retVal = false;
	            }
	            return retVal;
	        };
	        /**
	         * Creates a new MSI App Window and inserts it into the winMap.
	         * Will set the new window as the Primary Window.
	         */
	        this.createMsiAppWin = (winMap) => {
	            const win = {};
	            let winName = 'orasvcmsi';
	            let ctr = 0;
	            while (winMap.has(winName)) {
	                // TODO check if these need cleaned up
	                winName = winName + ctr;
	                ctr++;
	            }
	            win.name = winName;
	            win.key = winName;
	            win.sessionId = oj_mca_common_1$7.McaCommon.getSessionId();
	            win.createTime = new Date().getTime();
	            win.isMsi = true;
	            winMap.put(winName, win);
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Creating new MSI App Window ' + winName);
	            return win;
	        };
	        this.updateScreenPopId = (screenPop) => {
	            if (!screenPop.screenPopId) {
	                if (screenPop.engagementId) {
	                    screenPop.screenPopId = screenPop.engagementId;
	                }
	                else {
	                    screenPop.screenPopId = oj_mca_common_1$7.McaCommon.localUuidV4();
	                }
	            }
	        };
	        /**
	         * This removes closed windows or windows from a previous session from cache.
	         *
	         * DEVELOPER NOTES:
	         * This Should ONLY be invoked with a Checked Out Map.
	         * This Should ONLY be invoked during new Window Initialization to ensure the SessionId is valid.
	         *
	         * @param winMap
	         */
	        this.cleanupStaleWindows = (winMap) => {
	            const currTime = new Date().getTime();
	            if (winMap) {
	                let removedPrimary = false;
	                let candidatePrimary = null;
	                for (const key of winMap.keys()) {
	                    const val = winMap.get(key);
	                    if (val.name === window.name || val.name === this.currentWindowName) {
	                        // Don't remove this window
	                        continue;
	                    }
	                    if (val.name === sessionStorage.getItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME)) {
	                        // Setting this value so that, the previous window should not be chosen as primary window and should be removed  if not returned to
	                        // this page within 5 min
	                        val.unloadTime = Date.now() + WindowManager.INACTIVE_IDLE_TIMEOUT;
	                    }
	                    if (val.unloadTime) {
	                        if (currTime - val.unloadTime > WindowManager.CLOSE_TIMEOUT) {
	                            mcaLogger_1$5.McaLogger.warn(this.pre + 'Removing Stale Window Ref with key: ' + key);
	                            winMap.remove(key);
	                            if (val.isPrimary) {
	                                removedPrimary = true;
	                            }
	                            continue;
	                        }
	                    }
	                    // sjm - 05-07-21 Ensure we only do this for old windows
	                    if (val.createTime && ((currTime - val.createTime) > WindowManager.PURGE_TIME)) {
	                        // sjm - 10-15-20 Added sessionId check to the window purge process
	                        if (val.sessionId !== oj_mca_common_1$7.McaCommon.getSessionId()) {
	                            mcaLogger_1$5.McaLogger.warn(this.pre + 'Removing Window Ref from Old Session with key: ' + key);
	                            winMap.remove(key);
	                            if (val.isPrimary) {
	                                removedPrimary = true;
	                            }
	                            continue;
	                        }
	                        if (val.isMsi && !val.unloadTime) {
	                            candidatePrimary = val;
	                        }
	                    }
	                    // If we removed the Primary Window we need to assign a new Primary window
	                    if (removedPrimary) {
	                        if (!candidatePrimary) {
	                            candidatePrimary = winMap.get(window.name);
	                        }
	                        if (candidatePrimary) {
	                            candidatePrimary.isPrimary = true;
	                        }
	                    }
	                }
	            }
	        };
	        /**
	         * Retrieves the "Primary App Window".  If no window is tagged as The Primary App Window the last window in the map
	         * is considered as the Primary.
	         */
	        this.findPrimaryWin = (winMap) => {
	            let win;
	            for (const key of winMap.keys()) {
	                win = winMap.get(key);
	                if (win.unloadTime) {
	                    continue;
	                }
	                if (win.isPrimary) {
	                    break;
	                }
	            }
	            return win;
	        };
	        this.getPrimaryWindow = () => {
	            const winMap = this.getMap();
	            let retVal = null;
	            if (winMap) {
	                const keys = winMap.keys();
	                for (const key of keys) {
	                    const win = winMap.get(key);
	                    if (!win.unloadTime && win.isPrimary) {
	                        retVal = win;
	                        break;
	                    }
	                }
	            }
	            if (!retVal) {
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'No Primary Window Found!');
	            }
	            return retVal;
	        };
	        this.isFocused = () => {
	            // return document.hasFocus();
	            return !document.hidden;
	        };
	        this.focusWindow = (win, block) => {
	            if (win == null || win.name === window.name && this.isFocused()) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'focusWindow: already focused');
	                return true;
	            }
	            else if (win.name === window.name) {
	                window.focus();
	                return;
	            }
	            let handle = window.open('', win.name);
	            if (handle) {
	                const href = handle.location.href;
	                if (href === 'about:blank') {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + "Couldn't focus " + win.name + ' key: ' + win.key);
	                    handle.close();
	                    handle = null;
	                }
	                else {
	                    handle.focus();
	                    window.blur();
	                    this.handles.set(win.name, handle);
	                }
	                if (!block) {
	                    setTimeout(() => {
	                        this.focusWindow(win, true);
	                    }, 200);
	                }
	            }
	            if (!handle) {
	                if (win.unloadTime) {
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'We should reopen previously closed window.');
	                    // this.openTab(win.page);
	                    // return false; moved below
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'Unable to focus a window in a different window hierarchy!');
	                }
	                return false;
	            }
	            return true;
	        };
	        this.checkIsSameWindowUrl = (url) => {
	            try {
	                const urlString = url.trim();
	                const newLoc = new URL(urlString);
	                return newLoc && window.location.hostname === newLoc.hostname && window.location.pathname === newLoc.pathname;
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.warn(this.pre + ' Invalid URL to verify: ' + url, err);
	                return false;
	            }
	        };
	        this.initializeWebWorker = () => {
	            let blobURL = URL.createObjectURL(new Blob(['(', function () {
	                    let isInitialized = false;
	                    self.addEventListener('message', (event) => {
	                        switch (event.data) {
	                            case 'ping':
	                                if (!isInitialized) {
	                                    isInitialized = true;
	                                    setInterval(() => self.postMessage('pong'), 2000);
	                                }
	                                break;
	                        }
	                    }, false);
	                }.toString(), ')()'], { type: 'application/javascript' }));
	            if (blobURL.includes('blob:http://localhost')) {
	                // Dummy Url for unit test flow
	                blobURL = 'test.js';
	            }
	            const webWorker = new Worker(blobURL);
	            webWorker.addEventListener('message', () => {
	                if (this.isPrimaryWindow()) {
	                    let detailString = localStorage.getItem(mca$7.Constants.PRIMARY_WINDOW);
	                    if (!detailString) {
	                        detailString = '{}';
	                    }
	                    try {
	                        const detail = JSON.parse(detailString);
	                        detail.pingTime = Date.now();
	                        detail.winName = window.name;
	                        detailString = JSON.stringify(detail);
	                        localStorage.setItem(mca$7.Constants.PRIMARY_WINDOW, detailString);
	                    }
	                    catch (err) {
	                        console.error('Error on primary window err', err);
	                    }
	                }
	            });
	            webWorker.postMessage('ping');
	        };
	        this.setWindowName();
	        this.init();
	        this.initializeWebWorker();
	    }
	    /**
	     * Retrieve an instance to the global WindowManager object
	     */
	    static getInstance() {
	        if (!WindowManager._instance) {
	            WindowManager._instance = new WindowManager();
	        }
	        return WindowManager._instance;
	    }
	    /**
	     * Notifies the MCA Framework the current Page has Timed Out due to inactivity
	     */
	    notifySessionTimeout() {
	        mcaLogger_1$5.McaLogger.warn(this.pre + 'TODO Implement notifySessionTimeout');
	    }
	    setMcaBundle(_mcaBundle) {
	        if (!this.mcaBundle) {
	            this.mcaBundle = _mcaBundle;
	        }
	    }
	    disableBeforeUnloadHandleing() {
	        this.disableBeforeUnload = true;
	    }
	    /**
	     * Resets the ScreenPop, ie page, for the optional specified window
	     * If no window name is specified the current window is assumed
	     * An mcaForceReload event is fired in the specified window to ensure any refresh
	     * behavior is invoked.
	     * @param screenPop - Page Definitions to associate with the window
	     * @param windowName - optional, if not specified the current window is assumed
	     */
	    setScreenPop(screenPop, windowName) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'setScreenPop key: ' + screenPop.pageKey + ' engagementId: " ' + screenPop.engagementId);
	            if (!windowName) {
	                if (this.currentWindowName !== window.name) {
	                    // will need to replace the entry in map with the new window name
	                    this.updateMapWithWindowChangedName();
	                }
	                windowName = window.name;
	            }
	            let winMap = this.getMap();
	            let win = winMap.get(windowName);
	            if (win && win.page && win.page.engagementId && screenPop) {
	                if (win.page.engagementId === screenPop.engagementId) {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} Ignoring setScreenPop, win ${windowName} already set for engagementId: ${screenPop.engagementId}`);
	                    return; // exit before checkout!!!
	                }
	            }
	            if (screenPop.displayMode === mca$7.PageDisplayMode.MsiWindow) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring setScreenPop for engagementId: ' + screenPop.engagementId + ' for MSI APP Window:  ' + win.name);
	                return;
	            }
	            winMap = yield this.checkOutMap();
	            const delta = new mca$7.McaWindowChange(windowName, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	            winMap.setDelta(delta);
	            win = winMap.get(windowName);
	            if (win) {
	                win.page = screenPop;
	                mcaLogger_1$5.McaLogger.info(this.pre + 'setScreenPop for engagementId: ' + screenPop.engagementId + ' for window:  ' + win.name);
	                if (screenPop.mcaRefEvent) {
	                    this.localUpdateWindowStatus(win, screenPop.mcaRefEvent);
	                }
	                if (windowName !== window.name) {
	                    win.reloadRequired = true;
	                }
	                this.flushCache(winMap);
	            }
	            else {
	                this.undoCheckOut(winMap);
	            }
	            if (win && (windowName === window.name)) {
	                this.fireReload(win);
	            }
	            if (!win) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Attempting to setScreenPop on Window: ' + windowName + ' which must have been orphaned');
	            }
	        });
	    }
	    /**
	     * Tag/Untag this as the Single Page (MSI) App Window.
	     * This will update cache and may migrate the Primary Window to/from this Window.
	     * We will always make the Primary Window an MSI Window if possible because the Primary MSI Window is
	     * where we show the MSI Engagements in case we have multiple MSI Windows.
	     * @param isMsiAppWindow Set to true to indicate this is an MSI App Window.
	     */
	    setMsiAppWindow(isMsiAppWindow) {
	        var _b;
	        return __awaiter$6(this, void 0, void 0, function* () {
	            if (this.isMsiWin === isMsiAppWindow) {
	                return; // ignore dup calls
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Setting the MSI App Window' + isMsiAppWindow);
	            this.isMsiWin = isMsiAppWindow;
	            const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	            const winMap = yield this.checkOutMap();
	            let doFlush = false;
	            let isFlushed = false;
	            let primaryWin = null;
	            let primaryMsiWin = null;
	            const msiWinList = new Array();
	            try {
	                const myWin = winMap.get(window.name);
	                myWin.isMsi = isMsiAppWindow;
	                doFlush = true;
	                if (myWin.isPrimary && isMsiAppWindow) {
	                    // This is already the primary window, nothing else to set
	                }
	                else { // Otherwise we may need to migrate the primary window
	                    for (const key of winMap.keys()) {
	                        const win = winMap.get(key);
	                        // We only show active engagements in the Primary MSI App Window
	                        if (win.isMsi && !win.unloadTime) {
	                            if (win.isPrimary) {
	                                primaryMsiWin = win;
	                            }
	                            if (win.name !== window.name) {
	                                msiWinList.push(win);
	                            }
	                        }
	                        else if (win.isPrimary && !win.unloadTime) {
	                            // Will need to migrate this.
	                            primaryWin = win;
	                        }
	                    }
	                    if (primaryMsiWin) {
	                        if (primaryMsiWin.name === window.name) {
	                            if (!isMsiAppWindow) {
	                                // We are unsetting this as an MSI App Window
	                                // Need to find another Primary MSI App Window
	                                if (msiWinList.length > 0) {
	                                    msiWinList[0].isPrimary = true;
	                                }
	                                myWin.isPrimary = false;
	                                doFlush = true;
	                            } // else This window is already tagged as the Primary MSI App Window
	                        }
	                        else if (isMsiAppWindow && (primaryMsiWin.msiPops == null || ((_b = primaryMsiWin.msiPops) === null || _b === void 0 ? void 0 : _b.length) < 1)) { // No screenpop present in current primary window then allocate it to current msi window
	                            myWin.isPrimary = true;
	                            primaryMsiWin.isPrimary = false;
	                            doFlush = true;
	                        } // else set the current win as primary and unset the current primary window
	                    }
	                    else if (primaryWin) {
	                        if (isMsiAppWindow) {
	                            // A non-MSI Window is the Primary, make this the new Primary
	                            myWin.isPrimary = true;
	                            primaryWin.isPrimary = false;
	                            doFlush = true;
	                        }
	                    }
	                    else {
	                        // No Primary Exists! Shouldn't happen
	                        myWin.isPrimary = true;
	                        doFlush = true;
	                    }
	                }
	                if (doFlush) {
	                    winMap.setDelta(delta);
	                    this.flushCache(winMap);
	                    isFlushed = true;
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(this.pre + '=>setMsiEnabled Exception');
	                mcaLogger_1$5.McaLogger.error(err);
	            }
	            finally {
	                if (!isFlushed) {
	                    this.undoCheckOut(winMap);
	                }
	            }
	            return;
	        });
	    }
	    /**
	     * Removes a Screen Pop from the MSI App window cache once an engagement is complete
	     * @param engagementId
	     */
	    removeScreenPopForEngagement(engagementId) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            const winMap = yield this.checkOutMap();
	            const win = winMap.get(window.name);
	            if (!win || !win.msiPops) {
	                this.undoCheckOut(winMap);
	                return;
	            }
	            let doFlush = false;
	            let isFlushed = false;
	            try {
	                const screenPops = win.msiPops;
	                if (screenPops && screenPops.length > 0) {
	                    for (let i = 0; i < screenPops.length; i++) {
	                        if (screenPops[i] && screenPops[i].engagementId === engagementId) {
	                            mcaLogger_1$5.McaLogger.info(`${this.pre} Removing Screen Pop from MSI App Window for Engagement ${engagementId}`);
	                            win.msiPops.splice(i, 1);
	                            doFlush = true;
	                            break;
	                        }
	                    }
	                }
	                if (doFlush) {
	                    const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	                    winMap.setDelta(delta);
	                    this.flushCache(winMap);
	                    isFlushed = true;
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(this.pre + '=>removeScreenPopForEngagement Exception');
	                mcaLogger_1$5.McaLogger.error(err);
	            }
	            finally {
	                if (!isFlushed) {
	                    this.undoCheckOut(winMap);
	                }
	            }
	        });
	    }
	    /**
	     * Launches the Single Page MSI Application in a new Browser tab if it is not already open and triggers
	     * a Nested Page Tab Pop.
	     * @param screenPop
	     */
	    openMsiAppTab(screenPop) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            const func = this.pre + 'openMsiAppTab';
	            const result = {};
	            result.result = mca$7.Result.success;
	            let winMap = this.getMap();
	            let win = this.findMsiAppWin(winMap);
	            // Pre-Checkout Check
	            if (win) {
	                if (screenPop.engagementId) {
	                    const engagement = this.getActiveEngagementForMsiWin(win, screenPop.engagementId);
	                    if (engagement) {
	                        if (window.name === win.name) {
	                            mcaLogger_1$5.McaLogger.info(func + 'Pre-Checkout Triggering ScreenPop in this MSI App Window for ' + engagement.engagementId);
	                            this.fireReload(win, screenPop);
	                            return;
	                        }
	                        // There is already an Active Engagement in the MSI App Window
	                        if (this.focusWindow(win)) {
	                            mcaLogger_1$5.McaLogger.info(func + 'Ignoring there is an MSI App Window associated to this engagement.');
	                            return;
	                        }
	                        // TODO check this case ...
	                        mcaLogger_1$5.McaLogger.error(func + 'Unable to Focus MSI App Window for existing Engagement');
	                        return;
	                    }
	                }
	            }
	            // Reassign to the Checked Out Map
	            winMap = yield this.checkOutMap();
	            let isFlushed = false;
	            let fireForceReload = false;
	            try {
	                this.updateScreenPopId(screenPop);
	                win = this.findMsiAppWin(winMap);
	                const currTime = new Date().getTime();
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.opening, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                let createNew = false;
	                if (win) {
	                    mcaLogger_1$5.McaLogger.info(func + 'MSI App Window already exists');
	                    delta.state = mca$7.McaWindowState.engagementAdded;
	                    delta.engagementId = screenPop.engagementId;
	                }
	                else {
	                    createNew = true;
	                    win = this.createMsiAppWin(winMap);
	                }
	                delta.windowName = win.name;
	                this.addMsiScreenPop(win, screenPop);
	                result.windowName = win.name;
	                result.screenPopId = screenPop.screenPopId;
	                if (win.name === window.name) {
	                    // This is the MSI App Window, trigger ScreenPop here
	                    fireForceReload = true;
	                }
	                else if (createNew) {
	                    // Open MSI App Window in a new Tab
	                    const url = this.constructUrl(screenPop);
	                    const specs = this.getAppWindowSpecs();
	                    if (!this.openUrl(url, specs, win, screenPop, winMap)) {
	                        result.result = mca$7.Result.error;
	                    }
	                }
	                else {
	                    // MSI App Window present in another tab
	                    if (!this.focusWindow(win)) {
	                        this.setTriggerTabAttention(win, screenPop);
	                        // TODO check this case ...
	                        mcaLogger_1$5.McaLogger.error(func + 'Unable to Focus MSI App Window for new ScreenPop');
	                    }
	                }
	                this.flushCache(winMap);
	                isFlushed = true;
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(func + 'Exception');
	                mcaLogger_1$5.McaLogger.error(err);
	            }
	            finally {
	                if (!isFlushed) {
	                    this.undoCheckOut(winMap);
	                }
	            }
	            if (fireForceReload) {
	                // This triggers ScreenPop
	                mcaLogger_1$5.McaLogger.info(func + 'Post-Checkin Triggering ScreenPop in this MSI App Window for ' + screenPop.engagementId);
	                this.fireReload(win, screenPop);
	            }
	            return result;
	        });
	    }
	    /**
	     * Launches a new Browser Tab and initiates the specified ScreenPop in the new Window.
	     * If the Browser Tab is already opened, as indicated by the pageKey attribute, then
	     * the focus will be switched to the existing Browswer Tab.
	     */
	    openTab(screenPop, attempt) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + '=>openTab');
	            const tmpWinMap = this.getMap();
	            // SVC-246651 - 02-27-23 Now only initiate Screen Pops from the Primary Window
	            if (!this.isPrimaryWindow() && !screenPop.launchedFromUnknownCaller && screenPop.displayMode !== mca$7.PageDisplayMode.CurrentWindow) {
	                let primaryChanged = false;
	                // if (!this.isFocused()) { //
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'Ignoring only initiate ScreenPops from Primary Window.');
	                if (this.isFocused()) {
	                    // 02-27-23 Now that we are initiating Screen Pops from the Primary Window, try to focus it.
	                    // Otherwise in the MSI Window case we will not auto-focus the MSI Window when we Accept
	                    // from a non-MSI window
	                    primaryChanged = WindowManager.checkWindowOpenAndSetPrimary();
	                    const primaryWin = this.getPrimaryWindow();
	                    if (primaryWin) {
	                        if ((screenPop === null || screenPop === void 0 ? void 0 : screenPop.displayMode) === mca$7.PageDisplayMode.MsiWindow) {
	                            mcaLogger_1$5.McaLogger.info(this.pre + 'Focus Primary Window.');
	                            this.focusWindow(primaryWin);
	                        }
	                        else {
	                            const altWin = this.findWinByKey(screenPop.pageKey, tmpWinMap);
	                            if (altWin) {
	                                mcaLogger_1$5.McaLogger.info(this.pre + 'Focus Existing Window with key: ' + screenPop.pageKey);
	                                this.focusWindow(altWin);
	                            }
	                        }
	                    }
	                }
	                if (!primaryChanged) {
	                    return;
	                }
	            }
	            if (attempt !== undefined) {
	                if (attempt > 1) {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'openTab: Blocking Retry Attempt: ' + attempt);
	                    return;
	                }
	            }
	            else {
	                attempt = 0;
	            }
	            // 05-11-22 Open the Single Page MSI App Window
	            if (screenPop && screenPop.displayMode === mca$7.PageDisplayMode.MsiWindow) {
	                return this.openMsiAppTab(screenPop);
	            }
	            // 03-26-21 Added new check before checking out map...
	            if (screenPop && screenPop.engagementId) {
	                const tmpWin = this.findWinByEngagement(screenPop.engagementId, tmpWinMap);
	                if (tmpWin) {
	                    if (screenPop.displayMode === mca$7.PageDisplayMode.CurrentWindow) {
	                        // This may be the case where an update happened from another window such as
	                        // Contact Verification following Unknown Caller Identification
	                        if (tmpWin.name !== window.name) {
	                            mcaLogger_1$5.McaLogger.warn(this.pre + 'Ignoring event initiated from another window');
	                            return;
	                        }
	                    }
	                    if (tmpWin.key === screenPop.pageKey) {
	                        if (this.focusWindow(tmpWin)) {
	                            mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring: there is a window associated to this engagement.');
	                            return;
	                        }
	                        mcaLogger_1$5.McaLogger.warn(this.pre + 'Removing Stale Cache Window Ref with key: ' + tmpWin.key);
	                        const tmpDelta = new mca$7.McaWindowChange(tmpWin.name, mca$7.McaWindowState.deleted, mca$7.DeltaType.state);
	                        const tmpWinMap2 = yield this.checkOutMap();
	                        tmpWinMap2.setDelta(tmpDelta);
	                        tmpWinMap2.remove(tmpWin.key);
	                        this.flushCache(tmpWinMap2);
	                    }
	                    else {
	                        mcaLogger_1$5.McaLogger.info(this.pre + 'Found a window for this engagement but this must be for Unknown Handling.');
	                    }
	                }
	            }
	            // end 03-26-21 check
	            let result = {};
	            result.result = mca$7.Result.success;
	            let searchKey = screenPop.pageKey;
	            let winName;
	            const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.opening, mca$7.DeltaType.state);
	            const winMap = yield this.checkOutMap();
	            winMap.setDelta(delta);
	            if (!searchKey) {
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'Missing ScreenPop.pageKey, required to avoid dup Tabs.');
	                searchKey = '';
	            }
	            const specs = this.getAppWindowSpecs();
	            let url = this.constructUrl(screenPop);
	            const replace = true;
	            let win = this.findWinByKey(searchKey, winMap);
	            const currTime = new Date().getTime();
	            let createNew = true;
	            let closeThisWindow = false; // special corner case for uknown caller page redirect to existing tab
	            if (win) {
	                winName = win.name;
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Window ' + winName + ', key: ' + searchKey + ' already exists');
	                createNew = false;
	                if (win.unloadTime) {
	                    const remote = this.handles.get(winName);
	                    if (!remote) {
	                        mcaLogger_1$5.McaLogger.info(this.pre + 'No handle found for previously opened window: ' + winName + ' key: ' + searchKey);
	                        winMap.remove(winName);
	                        createNew = true;
	                    }
	                    try {
	                        if (!remote.location || !remote.location.origin) {
	                            mcaLogger_1$5.McaLogger.info(this.pre + 'Detected close for previously opened window: ' + winName + ' key: ' + searchKey);
	                            winMap.remove(winName);
	                            createNew = true;
	                        }
	                    }
	                    catch (err) {
	                        mcaLogger_1$5.McaLogger.info(this.pre +
	                            'URL Redirect detected for previously opened window: ' +
	                            winName +
	                            ' key: ' +
	                            searchKey);
	                        winMap.remove(winName); // If user redirected treat this as gone for good
	                        createNew = true;
	                    }
	                    if (!createNew) {
	                        const elapsed = currTime - win.unloadTime;
	                        if (elapsed > WindowManager.CLOSE_TIMEOUT) {
	                            mcaLogger_1$5.McaLogger.warn(this.pre + 'Assuming previously opened window is closed: ' + winName + ' key: ' + searchKey);
	                            winMap.remove(winName); // TODO Test This
	                            createNew = true;
	                        }
	                    }
	                }
	            }
	            if (createNew) {
	                createNew = this.ensureNewUrl(url, screenPop);
	            }
	            if (createNew) {
	                winName = this.genAutoWinName(winMap);
	                win = {};
	                if (screenPop.displayMode === mca$7.PageDisplayMode.CurrentWindow) {
	                    // Repurpose this window for redirection
	                    winName = window.name;
	                    const oldWin = winMap.get(window.name);
	                    winMap.remove(oldWin.key);
	                    win.previousKey = oldWin.key;
	                }
	                win.name = winName;
	                win.key = searchKey;
	                win.sessionId = oj_mca_common_1$7.McaCommon.getSessionId();
	                win.createTime = new Date().getTime();
	                win.appType = mca$7.UiTypeToken.redwood;
	                this.updateScreenPopId(screenPop);
	                winMap.put(winName, win);
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Creating new window ' + winName + ' with key: ' + searchKey);
	            }
	            else {
	                delta.state = mca$7.McaWindowState.dataChanged;
	                if (!win) {
	                    // For the rare case where we do an inbound screenpop and we already happen to be on that page
	                    win = winMap.get(window.name);
	                    if (!win) {
	                        win = {};
	                        win.name = window.name;
	                        winMap.put(win.name, win);
	                    }
	                    win.key = searchKey;
	                    win.sessionId = oj_mca_common_1$7.McaCommon.getSessionId();
	                    if (!screenPop.screenPopId) {
	                        if (screenPop.engagementId) {
	                            screenPop.screenPopId = screenPop.engagementId;
	                        }
	                        else {
	                            screenPop.screenPopId = oj_mca_common_1$7.McaCommon.localUuidV4();
	                        }
	                    }
	                }
	                if (win.name !== window.name) {
	                    win.reloadRequired = true;
	                    this.setTriggerTabAttention(win);
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'Switching to window ' + winName + ' with key: ' + searchKey);
	                    url = '';
	                }
	            }
	            if (screenPop.mcaRefEvent) {
	                this.setWindowStatusForEvent(win, screenPop.mcaRefEvent);
	            }
	            let doForceClose = false;
	            let doRedirect = false;
	            result.windowName = win.name;
	            result.screenPopId = screenPop.screenPopId;
	            let fireForceReload = false;
	            if (win.name !== window.name) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Opening URL: ' + url);
	                oj_mca_common_1$7.McaCommon.sendToUef({
	                    engagementId: screenPop.engagementId,
	                    engagementType: screenPop.mcaRefEvent.data.channel,
	                    method: 'TabOpen',
	                    tabId: win.name,
	                });
	                const handle = window.open(url, winName, specs, replace);
	                if (handle) {
	                    const ref = handle.location.href;
	                    if (url === '' && ref === 'about:blank') {
	                        // when a new window is launched the href is initially always about:blank!!!
	                        // Revisit this if the attn indicator isn't sufficient...
	                        mcaLogger_1$5.McaLogger.warn(this.pre + "Couldn't switch to existing window " + winName + ' key: ' + searchKey);
	                        mcaLogger_1$5.McaLogger.warn(this.pre +
	                            'This is a known issue if the current window and the window we are trying to switch to are in a diff heirarchy');
	                        handle.close();
	                        /*** This block of code should fix Jira Issue: SVC-130968 ***/
	                        doForceClose = true;
	                        if (screenPop.engagementId && win.page) {
	                            if (screenPop.engagementId === win.page.engagementId) {
	                                mcaLogger_1$5.McaLogger.info(this.pre + 'ScreenPop already handled by: ' + winName + ' key: ' + searchKey + ' engagementId: ' + screenPop.engagementId);
	                                // The preexisting window has already handled this screenpop
	                                doForceClose = false;
	                            }
	                        }
	                        if (doForceClose) {
	                            if (attempt >= 1) {
	                                mcaLogger_1$5.McaLogger.warn(this.pre + 'Force removing window: ' + winName + ' key: ' + searchKey);
	                                if (win.page) {
	                                    mcaLogger_1$5.McaLogger.info(this.pre + 'Removing window with old engagementId: ' + win.page.engagementId);
	                                }
	                                delta.state = mca$7.McaWindowState.deleted;
	                                winMap.remove(winName);
	                            }
	                            else {
	                                mcaLogger_1$5.McaLogger.warn(this.pre + 'Wait for retry before Force removing window: ' + winName + ' key: ' + searchKey);
	                            }
	                        }
	                    }
	                    else {
	                        this.handles.set(winName, handle);
	                        handle.focus();
	                        window.blur();
	                        if (url === '') {
	                            if (screenPop.displayMode === mca$7.PageDisplayMode.CurrentWindow) {
	                                // In this case we were told to screenPop in the current Window
	                                // such as on the Unknown Caller Page but, we found an existing
	                                // window already opened with the same pageKey. So, we are going to close
	                                // this window
	                                closeThisWindow = true;
	                            }
	                        }
	                    }
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.error(this.pre + "**Check Your Popup Blocker** couldn't open window " + winName + ' at ' + url);
	                    // 10-22-21 No longer removing the entry because Rajesh wants the call to show up via the popup blocker link
	                    // winMap.remove(winName);
	                }
	            }
	            else {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'No window switch required');
	                if (screenPop.displayMode === mca$7.PageDisplayMode.CurrentWindow) {
	                    // Check if redirect pagename is same as current pagename 
	                    if (this.checkIsSameWindowUrl(url)) {
	                        // If this is unknown caller page
	                        if (this.unknownCallerPage) {
	                            this.unknownCallerPage = false;
	                        }
	                    }
	                    else {
	                        // Do a URL Redirect in the current window
	                        doRedirect = true;
	                    }
	                }
	                else {
	                    window.focus();
	                    fireForceReload = true;
	                }
	            }
	            win.page = screenPop; // moved from above
	            delta.windowName = winName;
	            if (doForceClose && attempt < 1) {
	                // Use undoCheckOut to avoid any map manipulations!
	                this.undoCheckOut(winMap);
	                attempt++;
	            }
	            else {
	                this.flushCache(winMap);
	            }
	            if (fireForceReload) {
	                this.fireReload(win);
	            }
	            mcaLogger_1$5.McaLogger.info(this.pre + 'openTab exit');
	            if (closeThisWindow) {
	                window.close();
	            }
	            else if (doForceClose) {
	                yield oj_mca_common_1$7.McaCommon.sleep(1000);
	                result = yield this.openTab(screenPop, attempt);
	            }
	            else if (doRedirect) {
	                this.disableBeforeUnloadHandleing(); // Always disable dirty data warning when redirecting page
	                window.location.href = url;
	            }
	            return result;
	        });
	    }
	    closeTab(screenPop, attempt) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + '=>closeTab');
	            if (attempt !== undefined) {
	                if (attempt > 1) {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'closeTab: Blocking Retry Attempt: ' + attempt);
	                    return;
	                }
	            }
	            else {
	                attempt = 0;
	            }
	            const result = {};
	            result.result = mca$7.Result.success;
	            let searchKey = screenPop.pageKey;
	            const winMap = yield this.checkOutMap();
	            if (!searchKey) {
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'Missing ScreenPop.pageKey, required to avoid dup Tabs.');
	                searchKey = '';
	            }
	            const win = this.findWinByKey(searchKey, winMap);
	            if (win) {
	                result.windowName = win.name;
	                const delta = new mca$7.McaWindowChange(win.name, mca$7.McaWindowState.forceClose, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Firing forceClose for window: ' + win.name);
	                this.flushCache(winMap);
	            }
	            else {
	                this.undoCheckOut(winMap);
	            }
	            return result;
	        });
	    }
	    checkAndSetPrimary() {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            const localMap = this.getMap();
	            let primaryFound = false;
	            if (localMap.size() > 0) {
	                for (const key of localMap.keys()) {
	                    const val = localMap.get(key);
	                    if (val.isPrimary && val.unloadTime === null) {
	                        primaryFound = true;
	                        break;
	                    }
	                }
	            }
	            if (!primaryFound) {
	                if (this.currentWindowName !== window.name) {
	                    yield this.updateMapWithWindowChangedName();
	                }
	                const winMap = yield this.checkOutMap();
	                try {
	                    const name = window.name;
	                    const win = winMap.get(name);
	                    win.isPrimary = true;
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} Setting this as the Primary App Window.`);
	                    this.flushCache(winMap);
	                }
	                catch (err) {
	                    mcaLogger_1$5.McaLogger.error(`${this.pre} Exception in checkAndSetPrimary ${err}`);
	                    this.undoCheckOut(winMap);
	                }
	            }
	        });
	    }
	    /**
	     * Returns true if this is the Primary Application Window.
	     * 02-27-23 - This is now used for launching the Screen Pop
	     * Therefore it is critical this will only happen from a single window otherwise we will get multiple
	     * screen pops.
	     */
	    isPrimaryWindow() {
	        const winMap = this.getMap();
	        // SVC-246651 - 02-27-23 Since switch to initiate Screen Pops only from Primary Window, take extra precaution to ensure Screen Pop
	        let retVal = this.localIsPrimaryWindow(winMap);
	        if (!retVal) {
	            let foundAnotherPrimary = false;
	            const keys = winMap.keys();
	            for (const key of keys) {
	                const win = winMap.get(key);
	                if (win.name === window.name) {
	                    continue;
	                }
	                if (!win.unloadTime && win.isPrimary) {
	                    foundAnotherPrimary = true;
	                    break;
	                }
	            }
	            if (!foundAnotherPrimary) {
	                // This case should never happen but just in case Fall Back to the old logic
	                mcaLogger_1$5.McaLogger.error(`${this.pre} No Primary Window Found!`);
	                retVal = this.isFocused();
	            }
	        }
	        return retVal;
	    }
	    /**
	     * @deprecated - use getCurrentScreenPop
	     */
	    getCurrentPageParams() {
	        let retVal = {};
	        const screenPop = this.getCurrentScreenPop();
	        if (screenPop) {
	            retVal = screenPop.pageParams;
	        }
	        return retVal;
	    }
	    /**
	     * returns true if the specified engagement was ScreenPopped in the current window
	     */
	    isCurrentEngagementWindow(engagementId) {
	        let retVal = false;
	        if (this.currentWindowName !== window.name) {
	            this.updateMapWithWindowChangedName();
	        }
	        const winMap = this.getMap();
	        let win = this.findWinByEngagement(engagementId, winMap);
	        if (win && win.name === window.name) {
	            retVal = true;
	        }
	        // The ScreenPops are stored in the msiPops list for the MSI App Window
	        if (!retVal && this.isMsiApp()) {
	            win = this.getMcaMsiWindow();
	            const engMgr = mca_engagement_manager_1$4.EngagementManager.getInstance();
	            if (win && win.msiPops && win.msiPops.length > 0) {
	                for (let i = 0; i < win.msiPops.length; i++) {
	                    const screenPop = win.msiPops[i];
	                    if (screenPop && screenPop.engagementId === engagementId) {
	                        const engagement = engMgr.getEngagement(engagementId);
	                        if (engagement) {
	                            retVal = true;
	                        }
	                        break;
	                    }
	                }
	            }
	        }
	        return retVal;
	    }
	    /**
	     * Switches focus to the Browser Tab associated with the specified engagement.
	     * Note: this ONLY works when invoked from the actively focused window.
	     * @param engagementId
	     */
	    focusWindowForEngagement(engagementId) {
	        mcaLogger_1$5.McaLogger.info(this.pre + 'focus window for engagementId: ' + engagementId);
	        if (!this.isFocused()) {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring, only initiate focus from Focused Window.');
	            return;
	        }
	        const winMap = this.getMap();
	        const win = this.findWinByEngagement(engagementId, winMap);
	        if (win) {
	            this.focusWindow(win);
	        }
	        else {
	            mcaLogger_1$5.McaLogger.warn(this.pre + 'focusWindow: No Window Found for engagementId: ' + engagementId);
	        }
	    }
	    /**
	     * Returns the Window for the specified engagement.
	     * null is returned if there is no window found for the specified engagement
	     * @param engagementId
	     */
	    getWindowForEngagement(engagementId) {
	        const winMap = this.getMap();
	        const win = this.findWinByEngagement(engagementId, winMap);
	        return win;
	    }
	    getWindowForLatestEngagement(engagementId) {
	        const winMap = this.getMap();
	        const engagement = mca_engagement_manager_1$4.EngagementManager.getInstance().getLatestEngagementByEventId(engagementId);
	        const win = this.findWinByEngagement(engagement.engagementId, winMap);
	        return win;
	    }
	    /**
	     * Sets the appropriate window status based upon the McaEvent
	     * This method writes directly to cache i.e. it does a checkOut/checkIn
	     * @param McaEvent
	     */
	    updateWindowStatus(event) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            if (!event) {
	                return;
	            }
	            const data = event.data;
	            if (this.isCurrentEngagementWindow(data.engagementId)) {
	                const winMap = yield this.checkOutMap();
	                const win = winMap.get(window.name);
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Updating Current Window Status for event: ' + event.method);
	                this.setWindowStatusForEvent(win, event);
	                if (win.restoreIcon) {
	                    this.restoreIcon = win.restoreIcon;
	                    this.setFavicon(win.restoreIcon);
	                }
	                const delta = new mca$7.McaWindowChange(win.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                this.flushCache(winMap);
	            }
	        });
	    }
	    /**
	     * Updates the window status to indicate the associated engagement is complete.
	     * @param engagementId
	     */
	    notifyEngagementComplete(engagementId, channelType) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'notifyEngagementComplete for engagementId: ' + engagementId);
	            if (this.isCurrentEngagementWindow(engagementId)) {
	                if (!channelType) {
	                    channelType = mca$7.ChannelType.phone;
	                }
	                const winMap = yield this.checkOutMap();
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.none);
	                winMap.setDelta(delta);
	                try {
	                    const win = this.findWinByEngagement(engagementId, winMap);
	                    if (win) {
	                        win.attnMessage = '';
	                        win.attnRequired = false;
	                        win.engagementActive = false;
	                        win.wrapUpRequired = false;
	                        delta.type = mca$7.DeltaType.state;
	                        // Set Icon to indicate Engagement is Complete and Window should be closed
	                        let icon = WindowManager.channelImageMap[channelType].complete;
	                        if (!icon) {
	                            icon = WindowManager.orphanTabIcon;
	                        }
	                        const iconPath = this.getImagePath(icon);
	                        this.restoreIcon = iconPath;
	                        this.setFavicon(iconPath);
	                        this.restoreIcon = iconPath;
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$5.McaLogger.error(this.pre + 'notifyEngagementComplete error ' + err);
	                }
	                finally {
	                    this.flushCache(winMap);
	                }
	                mca_engagement_manager_1$4.EngagementManager.getInstance().setEngagementComplete(engagementId);
	            }
	            else {
	                mcaLogger_1$5.McaLogger.warn(this.pre + 'Ignoring, only set EngagementComplete from the engagement window.');
	            }
	        });
	    }
	    /**
	     * Turns on the "Attention Indicator" for the Browser Tab associated with the specified pageKey.
	     * The "Attention Indicator" starts an animation of the Browser Tab that "flashes" the Attention Icon and specified message
	     * in place of the default window favicon and title.
	     * This will be ignored if the Browser Tab for the associated pageKey is already in focus.
	     * The "Attention Indicator" will be automatically turned off once the notified window receives focus.
	     * @param pageKey - equivalent to the ScreenPop.pageKey passed in the openTab method used for the window creation.
	     * @param message - the string to display in the Attention Indicator
	     * @param attnIcon - optional path to a .ico image file to display instead of the default attention icon.
	     * @param winMap - optional McaWindowMap which will be unlocked, it can NOT be used for any further cache writes
	     */
	    notifyWindowForPageKey(pageKey, message, attnIcon, winMap) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'notify window for pageKey: ' + pageKey);
	            if (!this.isFocused()) {
	                mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring, only initiate notifications from Focused Window.');
	                return;
	            }
	            let releaseMap = false;
	            if (!winMap) {
	                winMap = yield this.checkOutMap();
	                releaseMap = true;
	            }
	            const delta = new mca$7.McaWindowChange(null, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.none);
	            try {
	                winMap.setDelta(delta);
	                const win = this.findWinByKey(pageKey, winMap);
	                if (win) {
	                    delta.windowName = win.name;
	                    delta.type = mca$7.DeltaType.state;
	                    win.attnMessage = message;
	                    win.attnRequired = true;
	                    if (attnIcon) {
	                        win.attnIcon = attnIcon;
	                    }
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'notifyWindow: No Window Found for pageKey: ' + pageKey);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(this.pre + 'notifyWindowForPageKey error ' + err);
	            }
	            finally {
	                if (releaseMap) {
	                    this.flushCache(winMap);
	                }
	            }
	        });
	    }
	    /**
	     * Turns on the "Attention Indicator" for the Browser Tab associated with the specified engagementId.
	     * @param engagementId - determines which Browser Tab to start the Attention Indicator on
	     * @param message - the string to display in the Attention Indicator
	     * @param event  - the McaEvent for which the notification is being triggered
	     * @param forceNotify  - typically Notifications are only triggered from the in focus window because CTI Events
	     * are generated from every window but, for new chat messages the event will only come from a single window.
	     * This will force the window notification logic even when the window is not in focus.
	     */
	    notifyWindowForEngagement(engagementId, message, event, forceNotify) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'notify window for engagementId: ' + engagementId);
	            if (!forceNotify) {
	                if (!this.isFocused()) {
	                    if (event) {
	                        // We still need to check if this window's status needs updated ...
	                        this.updateWindowStatus(event);
	                    }
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'Ignoring, only initiate notifications from Focused Window.');
	                    return;
	                }
	            }
	            if (this.currentWindowName !== window.name) {
	                yield this.updateMapWithWindowChangedName();
	            }
	            const winMap = yield this.checkOutMap();
	            const delta = new mca$7.McaWindowChange(null, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.none);
	            winMap.setDelta(delta);
	            let win = null;
	            try {
	                win = this.findWinByEngagement(engagementId, winMap);
	                if (win) {
	                    if (event && (win.name === window.name)) {
	                        this.localUpdateWindowStatus(win, event);
	                    }
	                    delta.windowName = win.name;
	                    delta.type = mca$7.DeltaType.state;
	                    win.attnMessage = message;
	                    if (!forceNotify && win.page && win.page.pageTitle) {
	                        // DEV NOTE: To Remove Active and Wrap Up Browser Tab Titles Uncomment Following Line:
	                        // win.attnMessage = win.page.pageTitle;
	                    }
	                    win.attnRequired = true;
	                }
	                else {
	                    mcaLogger_1$5.McaLogger.warn(this.pre + 'notifyWindow: No Window Found for engagementId: ' + engagementId);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error(this.pre + 'notifyWindowForEngagement error: ' + err);
	            }
	            finally {
	                this.flushCache(winMap);
	                if (win && win.name === window.name) {
	                    mcaLogger_1$5.McaLogger.info(this.pre + 'manually invoking storage processor!!!');
	                    this.processStorageEvent(winMap);
	                }
	            }
	        });
	    }
	    /**
	     * Retrieve the 'Active' Engagement if this window was launched via an MCA ScreenPop
	     * Returns null if no Engagement was associated with this window or
	     * the associated Engagement has already been closed/terminated.
	     * @param engagementId - id used to indicate the engagement to choose for MSI App Window
	     */
	    getActiveEngagement(engagementId) {
	        if (this.currentWindowName !== window.name) {
	            this.updateMapWithWindowChangedName();
	        }
	        let engagement = null;
	        try {
	            const winMap = this.getMap();
	            if (!winMap.has(window.name)) {
	                return engagement;
	            }
	            const win = winMap.get(window.name);
	            if (engagementId) {
	                engagement = this.getActiveEngagementForMsiWin(win, engagementId);
	            }
	            else {
	                engagement = this.getActiveEngagementForWin(win);
	            }
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.error(`${this}Error finding activeEngagement ${err}`);
	        }
	        return engagement;
	    }
	    /**
	     * Returns the ScreenPop instance if this window was loaded as a result of a ScreenPop.
	     * Otherwise, returns null.
	     */
	    getCurrentScreenPop() {
	        if (this.currentWindowName !== window.name) {
	            this.updateMapWithWindowChangedName();
	        }
	        let retVal = null;
	        const winMap = this.getMap();
	        if (!winMap.has(window.name)) {
	            return retVal;
	        }
	        const win = winMap.get(window.name);
	        retVal = this.getScreenPopForWin(win);
	        return retVal;
	    }
	    /**
	     * Cleans up the window cache and closes the current browser window.
	     */
	    closeCurrentWindow() {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            let winMap = this.getMap();
	            let win = winMap.get(window.name);
	            if (!win) {
	                win = winMap.get(this.currentWindowName);
	                if (!win) {
	                    mcaLogger_1$5.McaLogger.info(this.pre + "close: couldn't find current window!");
	                }
	                else {
	                    winMap = yield this.checkOutMap();
	                    const delta = new mca$7.McaWindowChange(this.currentWindowName, mca$7.McaWindowState.deleted, mca$7.DeltaType.state);
	                    winMap.setDelta(delta);
	                    winMap.remove(this.currentWindowName);
	                    this.flushCache(winMap);
	                }
	            }
	            else {
	                winMap = yield this.checkOutMap();
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.deleted, mca$7.DeltaType.state);
	                winMap.setDelta(delta);
	                winMap.remove(window.name);
	                this.flushCache(winMap);
	            }
	            window.close();
	        });
	    }
	    getPageKeyForWindow(windowName) {
	        let pageKey;
	        const winMap = this.getMap();
	        const win = winMap.get(windowName);
	        if (!win) {
	            mcaLogger_1$5.McaLogger.info(this.pre + ' getPageKeyForWindow: couldnt find window: ' + windowName);
	        }
	        else if (win.key) {
	            pageKey = win.key;
	        }
	        else if (win.page && win.page.pageKey) {
	            pageKey = win.page.pageKey;
	        }
	        if (!pageKey) {
	            mcaLogger_1$5.McaLogger.warn(this.pre + 'getPageKeyForWindow: window: ' + windowName + ' has no pageKey!');
	            pageKey = windowName;
	        }
	        return pageKey;
	    }
	    /**
	     * Returns a new pageKey if a window with this pageKey exists and contains an active engagement.
	     * This is used to prevent Screen Popping to a page with an active Engagement because the new Engagement
	     * was overwriting the active Engagement.
	     * @param pageKey
	     * @param event
	     * @returns The event.engagementId will be returned if there is already a window with the pageky
	     * open with an active engagement. Otherwise, null is returned.
	     */
	    getReplacementPageKey(pageKey, event) {
	        let replacementKey = null;
	        if (pageKey && pageKey.includes(mca$7.Constants.PAGE_KEY_TIME_DELIM)) {
	            // We're already using a unique page key
	            return replacementKey;
	        }
	        if (event.data.engagementId) {
	            const winMap = this.getMap();
	            const win = this.findWinByKey(pageKey, winMap);
	            if (win) {
	                const engagement = this.getActiveEngagementForWin(win);
	                if (engagement) {
	                    if (event.data.engagementId !== engagement.engagementId) {
	                        mcaLogger_1$5.McaLogger.warn(`${this.pre} Already an Active Engagement ${engagement.engagementId} for window ${win.name} with key ${win.key}`);
	                        replacementKey = event.data.engagementId;
	                    }
	                }
	            }
	        }
	        return replacementKey;
	    }
	    /**
	     * Checks if the current Unknown_Contact Page is associated with this event.
	     * @param data
	     * @returns true if this page is associated with the event
	     */
	    isCurrentUnknownCallerPage(event) {
	        let retVal = false;
	        const screenPop = this.getCurrentScreenPop();
	        if (screenPop && screenPop.tmpPageKey) {
	            if (screenPop.tmpPageKey === event.data.engagementId) {
	                retVal = true;
	            }
	        }
	        return retVal;
	    }
	    /**
	     * Retrieves the pageKey for the current window.
	     * If this window was not created my the MCA Window Manager then, try to manufacture a key based upon
	     * the data that is supplied.
	     * @param data
	     */
	    getCurrentPageKey() {
	        if (this.currentWindowName !== window.name) {
	            this.updateMapWithWindowChangedName();
	        }
	        return this.getPageKeyForWindow(window.name);
	    }
	    /**
	     * Checks if the current window has focus
	     * @return true if the current window has focus
	     */
	    isWindowFocused() {
	        return this.isFocused();
	    }
	    /**
	     * Enables HTML 5 Web Notifications. These are enabled by default but, may turned off
	     * via the 'SVC_OMNICHANNEL_DESKTOP_NOTIFICATION_ENA' Profile Option
	     * @param true if Web Notifications are enabled
	     */
	    enableWebNotfications(enableWebNotifications) {
	        this.webNotificationsEnabled = enableWebNotifications;
	    }
	    /**
	     * Displays HTML 5 Web Notification
	     */
	    displayWebNotification(detail) {
	        // DEV NOTEs: Web Notifications ARE NOT Supported:
	        //  -  In HTTP Servers - To get around this add the --unsafely-treat-insecure-origin-as-secure flag in Chrome
	        //  -  In Incognito Windows
	        // Guide: https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API/Using_the_Notifications_API
	        //  To Prevent Redundant Web Notifications from getting published we should only publish these
	        //  from the "Primary App Window"
	        if (!this.webNotificationsEnabled) {
	            mcaLogger_1$5.McaLogger.warn(`${this.pre} Web Notifications are disabled via profile option: SVC_OMNICHANNEL_DESKTOP_NOTIFICATION_ENA`);
	            return;
	        }
	        if (this.isFocused()) {
	            // 08-05-20 First Check wasn't Fool proof;
	            if (document.hasFocus()) {
	                mcaLogger_1$5.McaLogger.warn(`${this.pre} Showing Web Notifications even when Primary Window already in Focus!`);
	                // 10-07-20 - Removed focus check altogether, just always show the notification
	                // return; // Don't show Web Notifications if we already have focus; the standard App Notification is visible
	            }
	        }
	        const winMap = this.getMap();
	        let displayNotification = true;
	        if (winMap) {
	            const keys = winMap.keys();
	            for (const key of keys) {
	                const win = winMap.get(key);
	                if (win.hasFocus) ;
	            }
	            if (displayNotification) {
	                const win = this.findPrimaryWin(winMap);
	                if (win && win.name === window.name) ;
	                else {
	                    mcaLogger_1$5.McaLogger.warn(`${this.pre} Only display Web Notifications from the Primary App Window`);
	                    displayNotification = false;
	                }
	            }
	        }
	        if (!displayNotification) {
	            return;
	        }
	        if (detail.initialDisplay === true) {
	            this.playNotificationSound();
	        }
	        else {
	            mcaLogger_1$5.McaLogger.info(`${this.pre} Skipping play Sound on Notification Update`);
	        }
	        try {
	            if (Notification.permission === mca$7.Permission.granted) {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Opening Web Notification`);
	                // Add a Tag to Ensure the Same Notification is reused for updates e.g.,
	                // var n = new Notification(notification.message, {tag: notification.id});
	                const options = {
	                    body: detail.message,
	                    icon: detail.icon,
	                    tag: detail.engagementId
	                };
	                const notification = new Notification(detail.title, options);
	                notification.onclick = () => {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} notification clicked`);
	                    window.focus();
	                };
	                notification.onclose = () => {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} notification closed`);
	                    // Note: close may be fired by user close or system close
	                    if (this.webNotificationsMap) {
	                        this.webNotificationsMap.delete(notification.tag);
	                    }
	                };
	                notification.onerror = () => {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} notification error`);
	                    // Note: close may be fired by user close or system close
	                    if (this.webNotificationsMap) {
	                        this.webNotificationsMap.delete(notification.tag);
	                    }
	                };
	                if (!this.webNotificationsMap) {
	                    this.webNotificationsMap = new Map();
	                }
	                this.webNotificationsMap.set(detail.engagementId, notification);
	            }
	            else {
	                mcaLogger_1$5.McaLogger.warn(`${this.pre} Web Notifications are disabled because of browser/user permissions!`);
	            }
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.error(`${this.pre} Exception in displayWebNotification`, err);
	        }
	    }
	    /**
	     * Closes HTML 5 Web Notification
	     */
	    closeWebNotification(id) {
	        if (this.webNotificationsMap) {
	            const notification = this.webNotificationsMap.get(id);
	            if (notification) {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Closing Web Notification ${id}`);
	                notification.close();
	                this.webNotificationsMap.delete(id);
	            }
	        }
	    }
	    /**
	     * Plays a sound when a new Real-Time Engagement is sent to the Agent.
	     * @param fromButtonClick true if invoked from the play Button Click
	     * @returns void
	     */
	    playNotificationSound(fromButtonClick = false) {
	        try {
	            if (!this.notificationAudio) {
	                this.audioFilePath = this.getDefaultAudioFile();
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Loading Notification Sound File: ${this.audioFilePath}`);
	                this.notificationAudio = new Audio(this.audioFilePath);
	                this.notificationAudio.muted = false;
	                this.notificationAudio.onended = (() => {
	                    mcaLogger_1$5.McaLogger.info(`${this.pre} End Play Notification Sound`);
	                    if (this.replayAudio) {
	                        this.replayAudio = false;
	                        mcaLogger_1$5.McaLogger.info(`${this.pre} Replay Notification Sound`);
	                        this.notificationAudio.play()
	                            .then(() => {
	                        });
	                    }
	                });
	            }
	            const userActive = navigator.userActivation.isActive;
	            const userBeenActive = navigator.userActivation.hasBeenActive;
	            if (!fromButtonClick) {
	                if (!userActive && !userBeenActive) {
	                    const playList = document.getElementsByClassName('oj-mca-presence-play-btn');
	                    if (playList && playList.length > 0) {
	                        const simEvent = new MouseEvent('click');
	                        mcaLogger_1$5.McaLogger.info(`${this.pre} Simulating mouse click to play sound`);
	                        playList[0].dispatchEvent(simEvent);
	                        return;
	                    }
	                }
	            }
	            mcaLogger_1$5.McaLogger.info(`${this.pre} Before Playing Notification Sound readyState ${this.notificationAudio.readyState} userActivation ${userActive} beenActive ${userBeenActive}`);
	            if (!this.isFocused()) {
	                // Replay immediately on end seems to be the only guarantee the complete audio clip plays. 
	                // <TODO> Based upon user feedback uncomment for more pronounced tone.
	                // this.replayAudio = true;  
	            }
	            this.notificationAudio.currentTime = 0;
	            this.notificationAudio.play()
	                .then(() => {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Success Playing Notification Sound readyState ${this.notificationAudio.readyState} userActivation ${userActive} beenActive ${userBeenActive}`);
	            })
	                .catch((err) => {
	                mcaLogger_1$5.McaLogger.warn(`${this.pre} Exception playing notification sound ${this.audioFilePath} ${err}`);
	                mcaLogger_1$5.McaLogger.warn(err);
	            });
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.error(`${this.pre}Exception processing notification sound ${err}`);
	        }
	    }
	    /**
	     * Returns true if this is the MSI App window.
	     */
	    isMsiApp() {
	        return this.isMsiWin;
	    }
	    /**
	     * Returns true if this window has 1 or more active engagements
	     */
	    hasActiveEngagement() {
	        let retVal = false;
	        const winMap = this.getMap();
	        const win = winMap.get(window.name);
	        if (win && win.msiPops) {
	            const engagements = this.getActiveMsiEngagements();
	            if (engagements && engagements.length > 0) {
	                retVal = true;
	            }
	        }
	        else {
	            const engagement = this.getActiveEngagement();
	            if (engagement) {
	                retVal = true;
	            }
	        }
	        return retVal;
	    }
	    /**
	     * Returns a list of Active Engagements for this MSI App Window
	     */
	    getActiveMsiEngagements() {
	        let engagements = null;
	        const win = this.getMcaMsiWindow();
	        try {
	            if (win && win.msiPops) {
	                const screenPops = win.msiPops;
	                if (screenPops && screenPops.length > 0) {
	                    engagements = new Array();
	                    const engMgr = mca_engagement_manager_1$4.EngagementManager.getInstance();
	                    for (let i = 0; i < screenPops.length; i++) {
	                        if (screenPops[i] && screenPops[i].engagementId) {
	                            const engagement = engMgr.getEngagement(screenPops[i].engagementId);
	                            if (engagement) {
	                                if (engagement.isActive()) {
	                                    engagements.push(engagement);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.warn(`${this.pre} Error retrieving MsiEngagements`);
	            mcaLogger_1$5.McaLogger.warn(err);
	        }
	        return engagements;
	    }
	    isUnknownCallerPage() {
	        return this.unknownCallerPage;
	    }
	    /**
	     * *** FOR DEMO USE ONLY ***
	     * To Override the Mercury Configurations. These are stored in the PrimaryWindow.
	     * @param demoConfig
	     */
	    setDemoConfig(demoConfig) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            if (!demoConfig) {
	                return;
	            }
	            if (!this.isPrimaryWindow()) {
	                mcaLogger_1$5.McaLogger.info(`${this.pre} Only set Demo Configs from Primary Window`);
	                return;
	            }
	            const winMap = yield this.checkOutMap();
	            const win = winMap.get(window.name);
	            mcaLogger_1$5.McaLogger.warn(`${this.pre} Storing Demo Configs`);
	            win.demoConfig = demoConfig;
	            this.flushCache(winMap);
	        });
	    }
	    /**
	     * *** FOR DEMO USE ONLY ***
	     * Get Mercury Configuration Overrides for Demo.
	     * @param demoConfig
	     */
	    getDemoConfig() {
	        const winMap = this.getMap();
	        const win = this.findPrimaryWin(winMap);
	        let demoConfig = null;
	        if (win && win.demoConfig) {
	            demoConfig = win.demoConfig;
	        }
	        return demoConfig;
	    }
	    copyMSIPopData(engagementsToRestore) {
	        return __awaiter$6(this, void 0, void 0, function* () {
	            const winMap = this.getMap();
	            let mapCheckOutNeeded = false;
	            if (winMap) {
	                winMap.get(window.name);
	                const keys = winMap.keys();
	                for (const key of keys) {
	                    const win = winMap.get(key);
	                    if (win && win.msiPops && win.msiPops.length > 0 && win.name !== window.name && win.unloadTime) {
	                        mapCheckOutNeeded = true;
	                        break;
	                    }
	                }
	            }
	            if (mapCheckOutNeeded) {
	                const checkedOutWinMap = yield this.checkOutMap();
	                const delta = new mca$7.McaWindowChange(window.name, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	                let doFlush = false;
	                let isFlushed = false;
	                try {
	                    if (checkedOutWinMap) {
	                        const currentWindow = checkedOutWinMap.get(window.name);
	                        const keys = checkedOutWinMap.keys();
	                        for (const key of keys) {
	                            const win = checkedOutWinMap.get(key);
	                            if (win && win.msiPops && win.msiPops.length > 0 && win.name !== window.name && win.unloadTime) {
	                                for (const msiPop of win.msiPops) {
	                                    if (engagementsToRestore.indexOf(msiPop.uuid) >= 0) {
	                                        if (!currentWindow.msiPops || currentWindow.msiPops.length === 0) {
	                                            currentWindow.msiPops = [];
	                                        }
	                                        currentWindow.msiPops.push(msiPop);
	                                    }
	                                }
	                                doFlush = true;
	                                delete win.msiPops;
	                            }
	                        }
	                        if (doFlush) {
	                            checkedOutWinMap.setDelta(delta);
	                            this.flushCache(checkedOutWinMap);
	                            isFlushed = true;
	                        }
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$5.McaLogger.error(err);
	                }
	                finally {
	                    if (!isFlushed) {
	                        this.undoCheckOut(checkedOutWinMap);
	                    }
	                }
	            }
	        });
	    }
	    getDefaultAudioFile() {
	        if (!this.isVbEnabled()) {
	            return '';
	        }
	        else {
	            // Using the ChatOffer Audio from the Rightnow Engagement Panel
	            const defaultAudioFile = 'common/resources/sounds/rnNotification.mp3';
	            let audioFileUrl = commonjsRequire.toUrl('.');
	            if (audioFileUrl.includes('common')) {
	                // Path for Local Testing
	                audioFileUrl = audioFileUrl.replace('common', defaultAudioFile);
	            }
	            else {
	                // Deployed Path 
	                audioFileUrl = commonjsRequire.toUrl('oj-mca') + '/debug/' + defaultAudioFile;
	            }
	            return audioFileUrl;
	        }
	    }
	    getActiveEngagementForWin(win) {
	        let engagement = null;
	        try {
	            const screenPop = this.getScreenPopForWin(win);
	            if (screenPop && screenPop.engagementId) {
	                engagement = mca_engagement_manager_1$4.EngagementManager.getInstance().getEngagement(screenPop.engagementId);
	                if (!engagement) {
	                    engagement = null;
	                }
	                else if (!engagement.isActive()) {
	                    engagement = null;
	                }
	            }
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.error(`${this}Error finding activeEngagement ${err}`);
	        }
	        return engagement;
	    }
	    /**
	     * Returns the ScreenPop instance if the specified window was loaded as a result of a ScreenPop.
	     * Otherwise, returns null.
	     */
	    getScreenPopForWin(win) {
	        let retVal = null;
	        if (!win) {
	            return retVal;
	        }
	        if (!win.page) {
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Window: ' + window.name + ' with key: ' + win.key + ' is not a ScreenPop');
	            return retVal;
	        }
	        retVal = win.page;
	        return retVal;
	    }
	    setWindowName() {
	        let name = window.name;
	        const winMap = this.getMap();
	        if ((name === null || name === void 0 ? void 0 : name.trim()) === '') {
	            name = this.genAutoWinName(winMap);
	            mcaLogger_1$5.McaLogger.info(this.pre + 'Initializing new app window ' + name);
	            window.name = name;
	        }
	    }
	    getMcaMsiWindow() {
	        const mcaWindowMap = this.getMap();
	        let mcaWindow = mcaWindowMap.get(window.name);
	        if ((!mcaWindow || (mcaWindow && !mcaWindow.msiPops)) && sessionStorage.getItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME)) {
	            mcaLogger_1$5.McaLogger.info(`${this.pre} missing MSI screen pop data for ${window.name},
            trying to restore the engagement info from ${sessionStorage.getItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME)}`);
	            mcaWindow = mcaWindowMap.get(sessionStorage.getItem(oj_mca_common_1$7.McaCommon.MCA_PREV_WINDOW_NAME));
	        }
	        return mcaWindow;
	    }
	}
	mcaWindowManager.WindowManager = WindowManager;
	WindowManager.NAME = 'oj-mca-windows';
	WindowManager.MAX = 10;
	WindowManager.CLOSE_TIMEOUT = 60 * 1000 * 1; // 1 minute
	WindowManager.PURGE_TIME = 60 * 1000 * 5; // 5 minute
	WindowManager.INACTIVE_IDLE_TIMEOUT = 60 * 1000 * 15; // 15 minute
	// UX Has Only Provided 1 Icon For All States, Against Advisement!
	WindowManager.channelImageMap = {
	    ORA_SVC_CHAT: { connected: 'ico-oracle-chat-outline-16.png', disconnected: 'ico-oracle-chat-outline-16.png', complete: 'ico-oracle-chat-outline-16.png', newMessage: 'ico-oracle-chat-16.png' },
	    ORA_SVC_PHONE: { connected: 'ico-call-16.png', disconnected: 'ico-call-16.png', complete: 'ico-call-16.png', newMessage: 'ico-call-16.png' },
	    ORA_SVC_VIDEO: { connected: 'ico-oracle-chat-outline-16.png', disconnected: 'ico-oracle-chat-outline-16.png', complete: 'ico-oracle-chat-outline-16.png' }
	};
	WindowManager.orphanTabIcon = 'ico-information-s-16.png';
	// URL Params Checked for manually opened windows
	WindowManager.PARAM_KEYS = {
	    BLOCK_DUPS: 'blockDupWindows',
	    PAGE_KEY: 'pageKey',
	    PAGE_NAME: 'pageName'
	};
	WindowManager.desc = 'Windows';
	WindowManager.isPrimaryWindowOpen = () => {
	    let primaryOpen = false;
	    let winMap = null;
	    try {
	        let cacheMapString = localStorage.getItem(WindowManager.NAME);
	        if (!cacheMapString) {
	            // missing map just init empty
	            cacheMapString = '{}';
	        }
	        winMap = (new mca$7.McaWindowMap()).fromJSON(JSON.parse(cacheMapString));
	    }
	    catch (err) {
	        mcaLogger_1$5.McaLogger.info(err);
	    }
	    if (winMap) {
	        const keys = winMap.keys();
	        for (const key of keys) {
	            const win = winMap.get(key);
	            if (!win.unloadTime && win.isPrimary) {
	                const primaryAlive = WindowManager.isPrimaryWindowAlive();
	                if (primaryAlive) {
	                    primaryOpen = true;
	                }
	                break;
	            }
	        }
	    }
	    return primaryOpen;
	};
	WindowManager.checkWindowOpenAndSetPrimary = () => {
	    var _b;
	    let primaryOpen = false;
	    const localGetMap = () => {
	        try {
	            const cacheMapString = localStorage.getItem(WindowManager.NAME) || '{}';
	            return (new mca$7.McaWindowMap()).fromJSON(JSON.parse(cacheMapString));
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.info('[WindowManager] - checkWindowOpenAndSetPrimary: Error reading Cache');
	            mcaLogger_1$5.McaLogger.warn(err);
	            return null;
	        }
	    };
	    const localGetCacheLock = () => {
	        const lockString = localStorage.getItem(WindowManager.NAME + '-l') || '{}';
	        return mca$7.CacheLock.fromJSON(JSON.parse(lockString));
	    };
	    const localCheckOutMap = () => __awaiter$6(void 0, void 0, void 0, function* () {
	        let cacheMap = null;
	        const startTime = Date.now();
	        while (!cacheMap) {
	            try {
	                cacheMap = localGetMap();
	                // Perform a 2 Phase Lock
	                let lock = localGetCacheLock();
	                // Phase 1 Verify Map is Not Locked
	                if (!lock || !lock.isLocked()) {
	                    lock = new mca$7.CacheLock(true);
	                    cacheMap.setLock(lock);
	                    // Phase 2 Update Cache and Verify the Lock is the Same
	                    localStorage.setItem(WindowManager.NAME + '-l', JSON.stringify(lock));
	                    const dclLock = localGetCacheLock();
	                    if (lock.equals(dclLock)) {
	                        // McaLogger.warn("verified lock!!!");
	                    }
	                    else {
	                        // Leave Current Lock In Place ...
	                        mcaLogger_1$5.McaLogger.warn('[WindowManager] - Cache is already locked, waiting ...');
	                        cacheMap = null;
	                        yield oj_mca_common_1$7.McaCommon.sleep(5);
	                        continue;
	                    }
	                }
	                else {
	                    cacheMap = null;
	                    yield oj_mca_common_1$7.McaCommon.sleep(5);
	                }
	                if (!cacheMap) {
	                    const currTime = Date.now();
	                    if (currTime - startTime > 2000 /*McaCacheManager.MAX_LOCK_WAIT*/) {
	                        mcaLogger_1$5.McaLogger.error('[WindowManager] - Timeout Detetected waiting Cache Lock, stealing the map!');
	                        cacheMap = localGetMap();
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$5.McaLogger.error('[WindowManager] - Error Locking Cache');
	                mcaLogger_1$5.McaLogger.error(err);
	                // ensure we release our temp lock before we exit!!!
	                const undoCacheMap = cacheMap || localGetMap();
	                localUndoCheckOut(undoCacheMap, true);
	                break;
	            }
	        }
	        return cacheMap;
	    });
	    const localUndoCheckOut = (map, forceUnlock) => {
	        try {
	            const lock = map.getLock();
	            const currLock = localGetCacheLock();
	            if (!currLock.isLocked()) {
	                // Map is not locked, ignoring undoCheckOut
	                return;
	            }
	            if (!lock.equals(currLock)) {
	                if (!forceUnlock) {
	                    // McaLogger.warn('undoCheckOut, Ignoring because map locked by another window');
	                    return;
	                }
	            }
	            lock.clear();
	            localStorage.setItem(WindowManager.NAME + '-l', JSON.stringify(lock));
	            map.setLock(null); // ensure consumers are aware this map is no longer locked
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.error('[WindowManager] - Error undoCheckOut!');
	            mcaLogger_1$5.McaLogger.error(err);
	        }
	    };
	    const localFlushCache = (map) => {
	        if (!map) {
	            return;
	        }
	        const lock = map.getLock();
	        if (!lock || !lock.id) {
	            throw new Error('Attempting to flush Cache without a lock!');
	        }
	        else {
	            const tmp = localGetMap();
	            const tmpLock = tmp.getLock();
	            if (!lock.equals(tmpLock)) {
	                mcaLogger_1$5.McaLogger.error('Cache lock was hi-jacked by: ' + tmpLock.id + ' window: ' + tmpLock.winName);
	            }
	        }
	        lock.clear();
	        localStorage.setItem(WindowManager.NAME, JSON.stringify(map));
	        localStorage.setItem(WindowManager.NAME + '-l', JSON.stringify(lock));
	        map.setLock(null); // ensure consumers are aware this map is no longer locked
	    };
	    const winMap = localGetMap();
	    let currentPrimaryWin;
	    let msiWindow;
	    const msiWindowList = [];
	    const windowList = [];
	    if (winMap) {
	        const keys = winMap.keys();
	        for (const key of keys) {
	            const win = winMap.get(key);
	            if (!win.unloadTime) {
	                if (win.isPrimary) {
	                    currentPrimaryWin = win;
	                    primaryOpen = true;
	                    break;
	                }
	                else {
	                    if (win.isMsi) {
	                        if (win.msiPops && ((_b = win.msiPops) === null || _b === void 0 ? void 0 : _b.length) > 0) {
	                            msiWindow = win;
	                            break;
	                        }
	                        msiWindowList.push(win);
	                    }
	                    windowList.push(win);
	                }
	            }
	        }
	    }
	    const primaryAlive = WindowManager.isPrimaryWindowAlive();
	    if ((!primaryOpen || (primaryOpen && !primaryAlive)) && windowList.length > 0) {
	        // Try to set one as primary
	        const setPrimary = () => __awaiter$6(void 0, void 0, void 0, function* () {
	            const localMap = yield localCheckOutMap();
	            let newPrimaryWindowName;
	            if (primaryOpen && !primaryAlive) {
	                const expiredPrimary = localMap.get(currentPrimaryWin.name);
	                expiredPrimary.isPrimary = false;
	                expiredPrimary.unloadTime = Date.now();
	            }
	            if (msiWindow) {
	                newPrimaryWindowName = msiWindow.name;
	            }
	            else if (msiWindowList.length > 0) {
	                newPrimaryWindowName = msiWindowList[0].name;
	            }
	            else if (windowList.length > 0) {
	                newPrimaryWindowName = windowList[0].name;
	            }
	            if (newPrimaryWindowName) {
	                const newPrimaryWindow = localMap.get(newPrimaryWindowName);
	                newPrimaryWindow.isPrimary = true;
	                const delta = new mca$7.McaWindowChange(newPrimaryWindowName, mca$7.McaWindowState.dataChanged, mca$7.DeltaType.state);
	                localMap.setDelta(delta);
	                localFlushCache(localMap);
	            }
	            else {
	                localUndoCheckOut(localMap);
	            }
	        });
	        setPrimary();
	    }
	    return windowList.length > 0;
	};
	WindowManager.isPrimaryWindowAlive = () => {
	    let primaryAlive = true;
	    const primaryWinData = localStorage.getItem(mca$7.Constants.PRIMARY_WINDOW);
	    if (primaryWinData) {
	        try {
	            const winData = JSON.parse(primaryWinData);
	            primaryAlive = (winData === null || winData === void 0 ? void 0 : winData.pingTime) ? Date.now() - winData.pingTime < 10000 : true;
	        }
	        catch (err) {
	            mcaLogger_1$5.McaLogger.warn('[WindowManager] - Error on isPrimaryWindowOpen', err);
	        }
	    }
	    return primaryAlive;
	};

	var __awaiter$5 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaAdfContainer, "__esModule", { value: true });
	mcaAdfContainer.McaAdfContainer = void 0;
	const mca$6 = requireMcaCommonTypes();
	const mca_engagement_manager_1$3 = mcaEngagementManager;
	const mca_rest_helper_1$2 = mcaRestHelper;
	const mca_window_manager_1$3 = mcaWindowManager;
	const oj_mca_common_1$6 = requireOjMcaCommon();
	const logger$2 = require$$0;
	class McaAdfContainer {
	    constructor(properties) {
	        this.stateStorageKey = 'oj-mca-cti';
	        this.pre = '[McaAdfContainer] ';
	        this.interactionCmdCache = new mca_rest_helper_1$2.McaRestHelper(McaAdfContainer.ICMDKEY, mca_rest_helper_1$2.McaRestHelper.NO_REST);
	        this.agentCmdCache = new mca_rest_helper_1$2.McaRestHelper(McaAdfContainer.ACMDKEY, mca_rest_helper_1$2.McaRestHelper.NO_REST);
	        this.agentStateCache = new mca_rest_helper_1$2.McaRestHelper(this.stateStorageKey, mca_rest_helper_1$2.McaRestHelper.NO_REST);
	        this.commandResponseListenerMap = new Map();
	        this.cacheReady = false;
	        this.tbMessagesQueue = [];
	        this.tbWinCloseDetected = false;
	        // Public interface
	        this.getChannels = () => __awaiter$5(this, void 0, void 0, function* () {
	            const retPromise = new Promise((resolve, reject) => {
	                if (!this.supportedChannels) {
	                    // TODO Need to enhance MCA API in future release to Support Other Channels
	                    // TODO For Now Just Assume Phone
	                    const phoneChannel = new mca$6.Channel(mca$6.ChannelType.phone, mca$6.EventSource.toolbar);
	                    this.supportedChannels = [phoneChannel];
	                }
	                resolve(this.supportedChannels);
	            });
	            return retPromise;
	        });
	        this.getAgentStates = () => __awaiter$5(this, void 0, void 0, function* () {
	            const retPromise = new Promise((resolve, reject) => {
	                // TODO Add other channels; For Now Just Assume Phone
	                if (!this.agentStateMap) {
	                    this.agentStateMap = new Map();
	                    const agentState = {
	                        channelType: mca$6.ChannelType.phone,
	                        isAvailable: false,
	                        isLoggedIn: false,
	                        workType: mca$6.Constants.PHONE
	                    };
	                    this.agentStateMap.set(agentState.workType, agentState);
	                }
	                resolve(this.agentStateMap);
	            });
	            return retPromise;
	        });
	        this.invokeCommand = (command) => {
	            logger$2.info(this.pre + '===> invokeCommand: ' + command);
	            if (!command || !command.method) {
	                logger$2.warn(this.pre + 'Ignoring command, missing method');
	                return;
	            }
	            if (command.target && !this.checkTarget(command.target)) {
	                logger$2.info(this.pre + 'Ignoring command for target: ' + command.target);
	                return;
	            }
	            if (command.channelType && !this.checkChannel(command.channelType)) {
	                logger$2.info(this.pre + 'Ignoring command, not supported by this toolbar: ' + command.channelType);
	                return;
	            }
	            if (!this.iCmdDest && command.method === mca$6.McaMethod.onInteractionCmd) {
	                logger$2.warn(this.pre + 'Ignoring Interaction command, toolbar cmd handler not set');
	                return;
	            }
	            else if (!this.aCmdDest && command.method === mca$6.McaMethod.onAgentCmd) {
	                if (command.command === mca$6.AgentCommandName.getInteractionCommands && command.responseCallback) {
	                    // If Engagement Component is loaded prior to Toolbar Initialization send the response once it is ready
	                    logger$2.info(this.pre + 'Waiting for Toolbar onAgentCommand to retrieve the activeInteractionCommands');
	                    this.activeInteractionCommand = command;
	                }
	                else {
	                    logger$2.warn(this.pre + 'Ignoring Agent command, toolbar cmd handler not set');
	                }
	                return;
	            }
	            else if (command.command === mca$6.AgentCommandName.getInteractionCommands && command.responseCallback) {
	                if (this.toolbarCapabilityMap) {
	                    const response = this.toolbarCapabilityMap.get(command.channelType);
	                    if (response) {
	                        command.responseCallback(response);
	                    }
	                    return;
	                }
	                else {
	                    logger$2.warn(this.pre + 'Unexpected state for getActiveInteractionCommands');
	                    return;
	                }
	            }
	            command.toolbarName = this.userConfigurations.toolbarInfo.name;
	            if (command.responseCallback) {
	                this.checkCommandResponseMap();
	                this.commandResponseListenerMap.set(command.commandId, command);
	            }
	            this.sendFrameMessage(command);
	        };
	        this.isToolbarWindowOpen = () => {
	            let retVal = false;
	            try {
	                const tbWinInfoString = localStorage.getItem(mca$6.Constants.TOOLBAR_WINDOW);
	                logger$2.info(`${this.pre} isToolbarWindowOpen - read from local storage toolbar window data: ${tbWinInfoString}`);
	                if (tbWinInfoString) {
	                    const tbWinInfo = JSON.parse(tbWinInfoString);
	                    if (tbWinInfo && tbWinInfo.pingTime) {
	                        const currTime = Date.now();
	                        retVal = (currTime - tbWinInfo.pingTime) < (10 * 1000);
	                        logger$2.info(`${this.pre} isToolbarWindowOpen - is still in ping interval: ${retVal} - difference: ${currTime - tbWinInfo.pingTime}`);
	                        if (!retVal) {
	                            if (!tbWinInfo.closeTime) {
	                                // Toolbar Window wasn't marked as closed but doesn't seem to be active
	                                logger$2.warn(`${this.pre} Assuming Toolbar Window has stopped running`);
	                            }
	                        }
	                    }
	                    if (retVal && tbWinInfo && tbWinInfo.closeTime) {
	                        logger$2.warn(`${this.pre} Seems Toolbar Window was just closed`);
	                        retVal = false;
	                    }
	                }
	            }
	            catch (err) {
	                logger$2.error(`${this.pre} Error retrieving Toolbar Window Info`, err);
	            }
	            return retVal;
	        };
	        this.showToolbar = () => {
	            if (!this.cacheReady) {
	                this.getAgentStateFromCache();
	            }
	            if (!this.isToolbarWindowOpen()) {
	                this.launchToolbarWindow();
	                this.checkQueuedMessages();
	            }
	            else {
	                this.focusToolbarWindow();
	            }
	        };
	        this.sendProviderResponse = (response) => {
	            if (!response) {
	                // must be test mode
	                return;
	            }
	            if (!response.result) {
	                response.result = mca$6.Result.success;
	            }
	            response.origin = window.location.origin;
	            response.toolbarName = this.userConfigurations.toolbarInfo.name;
	            this.sendFrameMessage(response);
	        };
	        this.focusToolbarWindow = () => {
	            logger$2.info(`${this.pre}focusToolbarWindow`);
	            const message = {
	                dest: 'popup-window',
	                payload: {
	                    action: 'focus'
	                }
	            };
	            this.toolbarBroadcastChannel.postMessage(message);
	            window.blur();
	            let handle = window.open('', mca$6.Constants.TOOLBAR_WINDOW);
	            if (handle) {
	                const href = handle.location.href;
	                if (href === 'about:blank') {
	                    logger$2.warn(this.pre + "Couldn't focus " + mca$6.Constants.TOOLBAR_WINDOW);
	                    handle.close();
	                    handle = null;
	                }
	                else {
	                    handle.focus();
	                    window.blur();
	                }
	            }
	            if (!handle) {
	                logger$2.warn(this.pre + 'Unable to focus toolbar window in a different window hierarchy!');
	                // TODO Send Desktop Notification
	            }
	        };
	        /**
	         * This will update the cache and trigger a storage event for the other windows to pick up.
	         * Returns true if the Agent's Logged In/Availability State has changed
	         */
	        this.checkAgentStateUpdate = (event) => {
	            let retVal = false;
	            try {
	                let newData;
	                if (event && event.data) {
	                    if (!this.currentAgentState) {
	                        this.currentAgentState = event;
	                        retVal = true;
	                    }
	                    else {
	                        const oldData = this.currentAgentState.data;
	                        newData = event.data;
	                        if (oldData.isLoggedIn === newData.isLoggedIn && oldData.isAvailable === newData.isAvailable) {
	                            // No change in state
	                        }
	                        else {
	                            retVal = true;
	                            this.currentAgentState = event;
	                        }
	                    }
	                }
	                if (retVal) {
	                    // Update the Local Indexed DB Cache
	                    if (this.cacheReady) {
	                        logger$2.info(`${this.pre} Updating AgentState Cache isAvailable ${event.data.isAvailable}`);
	                        this.agentStateCache.manualCacheData(event).then((result) => {
	                            // Trigger Event Broadcast to All Windows
	                            localStorage.setItem(this.stateStorageKey, event.uuid);
	                        });
	                    }
	                }
	            }
	            catch (err) {
	                logger$2.warn(`${this.pre}Error Updating Agent State`);
	                logger$2.warn(err);
	            }
	            return retVal;
	        };
	        // End public interface
	        this.init = () => {
	            logger$2.info(`${this.pre}Initializing ADF Toolbar Window Connector`);
	            // Init window manager
	            this.winMgr = mca_window_manager_1$3.WindowManager.getInstance();
	            this.engMgr = mca_engagement_manager_1$3.EngagementManager.getInstance();
	            this.engMgr.setResponseTarget(this.handleEngagementResponse, mca$6.EventSource.toolbar);
	            this.engMgr.setEventTarget(this.handleEngagementEvent, mca$6.EventSource.toolbar);
	            window.addEventListener('storage', this.storageListener, false);
	            // this will not be needed for ADF container
	            // window.addEventListener('message', this.receiveMessage, false);
	            // This is used by the Toolbar Window to check if MCA is still Active in this Window
	            // In other words the user hasn't navigated to another web site
	            // We must do this during init to handle window nav/refresh
	            window[mca$6.Constants.TOOLBAR_PARENT_WINDOW] = window.name;
	            // Ensure we always do this to ensure the Cache is initialized
	            this.getCommandTargetsFromCache();
	            this.getAgentStateFromCache();
	            this.toolbarBroadcastChannel = new BroadcastChannel(mca$6.Constants.TOOLBAR_BROADCAST_CHANNEL);
	            this.toolbarBroadcastChannel.onmessage = this.onToolbarBroadcastListener;
	        };
	        /**
	         * Storage Event Listener
	         * 1. This listens for Agent State Updates generated by the Toolbar Window Parent Window.
	         *    This just detects an update.  The actual data is retrieved via getAgentStateFromCache
	         * 2. Listen for ToolbarWindow close events
	         */
	        this.storageListener = (event) => {
	            if (event && event.key) {
	                switch (event.key) {
	                    case this.stateStorageKey:
	                        logger$2.info(`${this.pre}Detected AgentState Update from Storage`);
	                        this.getAgentStateFromCache();
	                        break;
	                    case mca$6.Constants.TOOLBAR_WINDOW:
	                        this.checkToolbarWindowClose(event);
	                        break;
	                }
	            }
	        };
	        this.verifyToolbarWindowClosed = () => {
	            if (this.tbWinCloseDetected) {
	                this.tbWinCloseDetected = false;
	                if (!this.isToolbarWindowOpen()) {
	                    logger$2.info(`${this.pre}Toolbar Window Closed`);
	                    if (this.currentAgentState) {
	                        if (this.currentAgentState.data.isAvailable && this.currentAgentState.data.isLoggedIn) {
	                            // fire agentStateEvent
	                            this.currentAgentState.data.isAvailable = false;
	                            this.currentAgentState.data.isLoggedIn = false;
	                            this.currentAgentState.data.stateCd = 'DISCONNECTED';
	                            this.publishAgentStateEvent(this.currentAgentState);
	                        }
	                    }
	                }
	            }
	        };
	        this.checkToolbarWindowClose = (event) => {
	            if (event.newValue) {
	                try {
	                    const newValue = JSON.parse(event.newValue);
	                    if (newValue.closeTime !== null) {
	                        this.tbWinCloseDetected = true;
	                        logger$2.info(`${this.pre}Detected Possible Toolbar Window Close, waiting for confirmation`);
	                        window.setTimeout(this.verifyToolbarWindowClosed, 5 * 1000);
	                    }
	                }
	                catch (err) { }
	            }
	        };
	        this.getCommandTargetsFromCache = () => {
	            this.getInteractionCommandsFromCache();
	            this.getAgentCommandTargetFromCache();
	        };
	        this.publishAgentStateEvent = (event) => {
	            this.updateAgentState(event);
	            const detail = event.data;
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const customEvent = new CustomEvent(mca$6.McaEventType.agentState, formattedEvent);
	            this.dispatchClientEvent(customEvent);
	        };
	        this.updateAgentState = (event) => {
	            if (!this.agentStateMap) {
	                this.agentStateMap = new Map();
	            }
	            if (event && event.data && event.data.channelType) {
	                event.data.workType = event.data.channel;
	                this.agentStateMap.set(event.data.workType, event.data);
	            }
	            else {
	                logger$2.warn(this.pre + 'Invalid agentStateEvent missing channelType');
	            }
	        };
	        this.dispatchClientEvent = (event) => {
	            if (event && event.type) {
	                try {
	                    let callback;
	                    switch (event.type) {
	                        case mca$6.McaEventType.agentState:
	                            if (this.agentStateEventTarget) {
	                                callback = this.agentStateEventTarget;
	                            }
	                            break;
	                        case mca$6.McaEventType.mcaEvent:
	                            if (this.mcaEventTarget) {
	                                callback = this.mcaEventTarget;
	                            }
	                            break;
	                        case mca$6.McaEventType.notifyOn:
	                        case mca$6.McaEventType.notifyOff:
	                            if (this.notificationEventTarget) {
	                                callback = this.notificationEventTarget;
	                            }
	                            break;
	                        default:
	                            logger$2.warn(`${this.pre} No dispacher defined for eventType: ${event.type}`);
	                            break;
	                    }
	                    if (callback) {
	                        logger$2.info(this.pre + 'Dispatching Event: ' + event.type);
	                        callback(event);
	                    }
	                    else {
	                        logger$2.warn(`${this.pre} no Listener registered for event: ${event.type}`);
	                    }
	                }
	                catch (err) {
	                    logger$2.error(`${this.pre} Exception during event dispatch`, err);
	                }
	            }
	            // no listeners for ADF container
	            // this.composite.dispatchEvent(event);
	        };
	        this.onToolbarBroadcastListener = (event) => {
	            if (event) {
	                logger$2.info(`${this.pre} Toolbar connector received broadcast event: ${JSON.stringify(event)}`);
	            }
	            if (this.winMgr && this.winMgr.isPrimaryWindow()) {
	                if (event && event.data && event.data.dest === 'main-window') {
	                    // it's a broadcastchannel message
	                    if (event.data.payload && typeof event.data.payload === 'string') {
	                        this.handleMessage(event.data.payload, event.origin);
	                    }
	                }
	            }
	        };
	        this.handleMessage = (message, origin) => {
	            logger$2.info(`${this.pre} handleMessage: ${message}`);
	            let mcaEvent;
	            let agentEvent;
	            try {
	                const tmpEvent = JSON.parse(message);
	                if (tmpEvent.method === mca$6.McaMethod.agentStateEvent) {
	                    agentEvent = tmpEvent;
	                }
	                else {
	                    mcaEvent = tmpEvent;
	                }
	            }
	            catch (err) {
	                // logger.info(err);
	                return;
	            }
	            if (agentEvent) {
	                agentEvent.origin = origin;
	                this.processAgentStateEvent(agentEvent);
	            }
	            else {
	                mcaEvent.origin = origin;
	                // add following for SVC-136505
	                if (mcaEvent.data && mcaEvent.data.reason && mcaEvent.data.reason === 'MISSED'
	                    && mcaEvent.data.inData && mcaEvent.data.inData[mca$6.SystemToken.direction] === mca$6.DirectionToken.outbound) {
	                    mcaEvent.data.reason = mca$6.CloseCommReason.canceled;
	                }
	                this.internalProcessReceivedMessage(mcaEvent);
	            }
	        };
	        this.processAgentStateEvent = (event) => {
	            const eventResponse = {};
	            eventResponse.uuid = event.uuid;
	            eventResponse.method = event.method;
	            eventResponse.origin = event.origin;
	            eventResponse.result = mca$6.Result.success;
	            this.sendProviderResponse(eventResponse);
	            this.publishAgentStateEvent(event);
	            this.checkAgentStateUpdate(event);
	        };
	        this.internalProcessReceivedMessage = (mcaEvent) => {
	            const outData = {};
	            let data = {};
	            if (mcaEvent.data) {
	                const keys = Object.keys(mcaEvent.data);
	                if (keys) {
	                    for (let i = 0; i < keys.length; i++) {
	                        const val = mcaEvent.data[keys[i]];
	                        if (typeof val === 'object' && keys[i] === 'inData') {
	                            const iKeys = Object.keys(val);
	                            if (iKeys) {
	                                for (let j = 0; j < iKeys.length; j++) {
	                                    const ival = val[iKeys[j]];
	                                    outData[iKeys[j]] = ival;
	                                }
	                            }
	                            continue;
	                        }
	                        outData[keys[i]] = val;
	                    }
	                }
	                if (!mcaEvent.data.engagementId) {
	                    mcaEvent.data.engagementId = mcaEvent.data.eventId;
	                }
	                data = mcaEvent.data;
	            }
	            const eventString = JSON.stringify(mcaEvent);
	            console.log(this.pre + 'internalProcessReceivedMessage Event Detail is\n' + eventString);
	            // const dataString : string = JSON.stringify(data);
	            // console.log('internalProcessReceivedMessage Event Data is ' + dataString);
	            // **IMPORTANT DEVELOPER NOTES**
	            // Callbacks are maintained in the mcaInteractionV1.js file for returning EACH message response.
	            //    - Except in special circumstances (like the startCommEvent) a message MUST have 1 and only 1
	            //      response.  Therefore, we must EITHER call processEvent to ensure the response is delivered after
	            //      async processing or return a response.    We can NOT return a response here if async processing
	            //      is required.  If we do then the real response will never reach the target toolbar because
	            //      the callback would have already been removed.
	            let processEvent = true;
	            if (mcaEvent.method) {
	                logger$2.info(`${this.pre} internalProcessReceivedMessage Event method is ${mcaEvent.method}`);
	                const eventResponse = {};
	                switch (mcaEvent.method) {
	                    case mca$6.McaMethod.onToolbarMsg:
	                        return;
	                    case mca$6.McaMethod.onInteractionCmd:
	                        if (!this.iCmdDest) {
	                            this.iCmdDest = data;
	                        }
	                        return;
	                    case mca$6.McaMethod.onAgentCmd:
	                        if (!this.aCmdDest) {
	                            // This event should only happen in the Parent Toolbar Window
	                            this.setAgentCommandTarget(data);
	                            this.getToolbarCapabilities(mcaEvent);
	                        }
	                        return;
	                    case mca$6.McaMethod.closeCompanion:
	                    case mca$6.McaMethod.openCompanion:
	                        processEvent = false; // ensure responses are sent, so callbacks are cleaned up!
	                        break;
	                    case mca$6.McaMethod.postToolbar:
	                        mcaEvent.origin = window.location.origin;
	                        processEvent = false; // ensure the response is sent
	                        break;
	                    case mca$6.McaMethod.showToolbar:
	                        processEvent = false;
	                        this.showToolbar();
	                        break;
	                    // TODO 
	                    // case mca.McaMethod.hideToolbar:
	                    //   processEvent = false;
	                    //   this.hideToolbar();
	                    //   break;
	                    case mca$6.McaMethod.isToolbarVisible:
	                        processEvent = false;
	                        outData[mca$6.McaMethod.isToolbarVisible] = this.isToolbarWindowOpen();
	                        break;
	                    case mca$6.McaMethod.newComm:
	                        if (mcaEvent.previewMode !== 'MANUAL') {
	                            this.showToolbar();
	                        }
	                        // sjm 12-3-20 - ALL newCommEvents must have a direction!
	                        if (data && data.inData) {
	                            if (!data.inData[mca$6.SystemToken.direction]) {
	                                logger$2.warn(`${this.pre} Ignoring invalid newCommEvent missing Direction!`);
	                                return;
	                            }
	                        }
	                        break;
	                    case mca$6.McaMethod.startComm:
	                        if (mcaEvent.previewMode !== 'MANUAL') {
	                            this.checkAndSendNotify(mcaEvent, false);
	                        }
	                        break;
	                    case mca$6.McaMethod.closeComm:
	                        if (mcaEvent.previewMode !== 'MANUAL') {
	                            this.checkAndSendNotify(mcaEvent, false);
	                        }
	                        break;
	                    case mca$6.McaMethod.agentCmdResponse:
	                        const aCmdData = mcaEvent;
	                        const cmdResponse = mca$6.CommandResponse.getCommandResponse(aCmdData);
	                        if (cmdResponse && cmdResponse.command === mca$6.AgentCommandName.getActiveEngagements && cmdResponse.outData) {
	                            if (typeof cmdResponse.outData[mca$6.Constants.ACTIVE_COUNT] === 'number') {
	                                if (cmdResponse.outData[mca$6.Constants.ACTIVE_COUNT] < 1) ;
	                            }
	                        }
	                        else if (cmdResponse &&
	                            cmdResponse.command === mca$6.AgentCommandName.getInteractionCommands &&
	                            cmdResponse.outData) {
	                            if (!cmdResponse.channelType) {
	                                logger$2.warn(this.pre + 'Invalid response for command ' + cmdResponse.command + ' missing channelType');
	                            }
	                            else if (!cmdResponse.outData) {
	                                logger$2.warn(this.pre + 'Invalid response for command ' + cmdResponse.command + ' missing outData');
	                            }
	                            else {
	                                const supportedCommands = cmdResponse.outData.supportedCommands;
	                                if (!supportedCommands) {
	                                    logger$2.warn(this.pre + 'Invalid response for command ' + cmdResponse.command + ' missing supportedCommands');
	                                }
	                                else {
	                                    if (this.activeInteractionCommand) {
	                                        try {
	                                            logger$2.info(this.pre + 'Sending getInteractionCommands Response');
	                                            this.activeInteractionCommand.responseCallback(cmdResponse);
	                                            this.activeInteractionCommand = null;
	                                        }
	                                        catch (err) {
	                                            logger$2.error(this.pre + 'Error Sending getInteractionCommands Response', err);
	                                        }
	                                    }
	                                    if (!this.toolbarCapabilityMap) {
	                                        this.toolbarCapabilityMap = new Map();
	                                    }
	                                    this.toolbarCapabilityMap.set(cmdResponse.channelType, cmdResponse);
	                                    if (this.cacheReady) {
	                                        this.interactionCmdCache.manualCacheData(this.toolbarCapabilityMap);
	                                    }
	                                    if (this.commandResponseListenerMap && this.commandResponseListenerMap.size > 0) {
	                                        const origCmd = this.commandResponseListenerMap.get(cmdResponse.commandId);
	                                        if (origCmd) {
	                                            this.commandResponseListenerMap.delete(cmdResponse.commandId);
	                                            try {
	                                                if (origCmd.responseCallback) {
	                                                    origCmd.responseCallback(cmdResponse);
	                                                }
	                                            }
	                                            catch (err) {
	                                                logger$2.info(this.pre + 'Error delivering Command Response ', err);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        processEvent = false;
	                        break;
	                    case mca$6.McaMethod.interactionCmdResponse:
	                        const cmdData = mcaEvent;
	                        const iCmdResp = mca$6.CommandResponse.getCommandResponse(cmdData);
	                        if (iCmdResp && iCmdResp.commandId) {
	                            if (this.commandResponseListenerMap && this.commandResponseListenerMap.size > 0) {
	                                const origCmd = this.commandResponseListenerMap.get(iCmdResp.commandId);
	                                if (origCmd) {
	                                    this.commandResponseListenerMap.delete(iCmdResp.commandId);
	                                    try {
	                                        if (origCmd.responseCallback) {
	                                            origCmd.responseCallback(iCmdResp);
	                                        }
	                                    }
	                                    catch (err) {
	                                        logger$2.info(this.pre + 'Error delivering Command Response ', err);
	                                    }
	                                }
	                            }
	                        }
	                        break;
	                    case mca$6.McaMethod.getConfig:
	                        // This invokes the Server therefore must be processed asynchronously!!!
	                        break;
	                    case mca$6.McaMethod.outboundError:
	                        if (!mcaEvent.data.engagementId) {
	                            // For some reason the API is using a diff attribute for eventId
	                            if (mcaEvent.data.commUuid) {
	                                mcaEvent.data.engagementId = mcaEvent.data.commUuid;
	                            }
	                        }
	                        mcaEvent.method = mca$6.McaMethod.closeComm; // convert this to a closeCommEvent for engagement processing
	                        mcaEvent.data.origMethod = mca$6.McaMethod.outboundError;
	                        if (!mcaEvent.data.inData) {
	                            mcaEvent.data.inData = {};
	                        }
	                        mcaEvent.data.inData[mca$6.SystemToken.direction] = mca$6.DirectionToken.outbound;
	                        // the reference toolbar leaves the call open so force the onhook!
	                        logger$2.info(this.pre + 'Forcing DISCONNECT For OutboundError ...');
	                        const forceHangup = new mca$6.Command(mca$6.InteractionCommandName.disconnect, mcaEvent.data.engagementId, null, null, null, mca$6.EventSource.toolbar);
	                        this.sendAsyncToolbarMessage(forceHangup);
	                        break;
	                    case mca$6.McaMethod.interactionControlsChanged:
	                        break;
	                }
	                eventResponse.outData = outData;
	                eventResponse.uuid = mcaEvent.uuid;
	                if (!eventResponse.method) {
	                    eventResponse.method = mcaEvent.method;
	                }
	                eventResponse.origin = mcaEvent.origin;
	                if (processEvent) {
	                    this.processMcaEvent(mcaEvent, eventResponse);
	                }
	                else {
	                    this.sendProviderResponse(eventResponse);
	                }
	            }
	            else {
	                logger$2.info(this.pre + 'Ignoring event missing method!!!');
	            }
	        };
	        this.setAgentCommandTarget = (data) => {
	            this.getAgentCommandTargetFromCache();
	            if (!this.aCmdDest) {
	                this.aCmdDest = data;
	                if (this.cacheReady) {
	                    this.agentCmdCache.manualCacheData(data);
	                }
	            }
	        };
	        this.getToolbarCapabilities = (mcaEvent) => {
	            const ltbinfo = this.userConfigurations.toolbarInfo;
	            if (ltbinfo) {
	                // Ensure there is no Callback defined for this command
	                const command = new mca$6.Command(mca$6.AgentCommandName.getInteractionCommands, null, mca$6.ChannelType.phone);
	                this.invokeCommandAsync(command);
	            }
	            else {
	                logger$2.warn(this.pre + 'Skipping getActiveInteractionCommands since PHONE Channel not supported');
	            }
	        };
	        this.invokeCommandAsync = (command) => __awaiter$5(this, void 0, void 0, function* () {
	            this.invokeCommand(command);
	            return 'done';
	        });
	        this.sendAsyncToolbarMessage = (message) => __awaiter$5(this, void 0, void 0, function* () {
	            this.sendFrameMessage(message);
	            return 'sent';
	        });
	        this.processMcaEvent = (event, response) => {
	            let deferredEngagement;
	            let setResponse = false;
	            // const eventString: string = JSON.stringify(event);
	            // console.log('processMcaEvent event: ' + eventString);
	            // const responseString: string = JSON.stringify(response);
	            // console.log('processMcaEvent resposne: ' + responseString);
	            switch (event.method) {
	                case mca$6.McaMethod.startComm:
	                    // HACK For Ref Toolbar that only supports UI Updates via startCommEvent Response
	                    this.startCommUuid = event.uuid; // fall thru...
	                // tslint:disable-next-line: no-switch-case-fall-through
	                case mca$6.McaMethod.newComm:
	                case mca$6.McaMethod.upgradeComm:
	                case mca$6.McaMethod.downgradeComm:
	                case mca$6.McaMethod.closeComm:
	                case mca$6.McaMethod.previewComm:
	                    deferredEngagement = this.engMgr.processEvent(event);
	                    break;
	                case mca$6.McaMethod.getCustomerData:
	                    deferredEngagement = this.engMgr.processEvent(event);
	                    break;
	                case mca$6.McaMethod.interactionControlsChanged:
	                    setResponse = true;
	                    break;
	                case mca$6.McaMethod.getConfig:
	                    this.getConfig(response);
	                    break;
	            }
	            if (deferredEngagement) {
	                deferredEngagement.then((engagement) => {
	                    if (!engagement) {
	                        logger$2.info(this.pre + 'Why no engagement returned from processEvent?');
	                    }
	                    else {
	                        logger$2.info(this.pre + 'processEvent Promise returned');
	                        const state = engagement.stateMap[event.method];
	                        if (state === mca$6.EventState.complete) {
	                            // event was processed on the server
	                            logger$2.info(this.pre + 'Event was already processed on the server.');
	                            const newResponse = engagement.responseMap[event.method];
	                            if (!newResponse) {
	                                logger$2.warn(this.pre + 'Event marked complete but no response.');
	                            }
	                            else {
	                                // uuid is unique to this toolbar's instance event
	                                newResponse.uuid = event.uuid;
	                                this.sendProviderResponse(newResponse);
	                            }
	                        }
	                    }
	                });
	                deferredEngagement.catch((err) => {
	                    logger$2.info(this.pre + 'Error detected in processEvent: ', err);
	                });
	                return; // early exit!!!
	            }
	            let newEvent = null;
	            if (setResponse) {
	                newEvent = this.convertMcaEvent(event, response);
	                this.sendProviderResponse(response); // ensure a response is returned for proper callback cleanup
	            }
	            this.dispatchClientEvent(newEvent);
	        };
	        this.getConfig = (response) => {
	            if (this.userConfigurations) {
	                const userConfig = this.userConfigurations;
	                const userDetails = userConfig.userDetails;
	                if (!response.configuration) {
	                    response.configuration = {};
	                }
	                if (userDetails.debugMode) {
	                    response.configuration.debugMode = userDetails.debugMode;
	                }
	                else {
	                    logger$2.warn(this.pre + 'this.properties.userConfigurations.userDetails missing debugMode ');
	                }
	                if (userDetails.faTrustToken) {
	                    response.configuration.faTrustToken = userDetails.faTrustToken;
	                }
	                else {
	                    logger$2.warn(this.pre + 'this.properties.userConfigurations.userDetails missing faTrustToken ');
	                }
	                if (userDetails.agentId) {
	                    response.configuration.agentId = userDetails.agentId;
	                }
	                else {
	                    logger$2.warn(this.pre + 'this.properties.userConfigurations.userDetails missing agentId ');
	                }
	                if (userDetails.agentPartyId) {
	                    response.configuration.agentPartyId = userDetails.agentPartyId;
	                }
	                if (userDetails.features) {
	                    response.configuration.features = userDetails.features;
	                }
	                else {
	                    response.configuration.features =
	                        '["INBOUND_CALL","OUTBOUND_CALL","TRANSFER_CALL","CONFERENCE_CALL","OUTBOUND_CALL_EXTENSIONS"]';
	                }
	                if (userDetails.NLS_LANG) {
	                    response.configuration.NLS_LANG = userDetails.NLS_LANG;
	                }
	                if (userDetails.NLS_LOCALE) {
	                    response.configuration.NLS_LOCALE = userDetails.NLS_LOCALE;
	                }
	                if (userDetails.AGENT_CONFIG_DATA) {
	                    response.configuration.AGENT_CONFIG_DATA = userDetails.AGENT_CONFIG_DATA;
	                }
	            }
	            this.sendProviderResponse(response);
	        };
	        this.convertMcaEvent = (event, response) => {
	            let rv = null;
	            if (!event.data) {
	                logger$2.warn(this.pre + 'convertMcaEvent: missing event.data');
	                return rv;
	            }
	            const eventName = 'mcaEvent';
	            let detail;
	            if (!event.data.engagementId) {
	                event.data.engagementId = event.data.eventId;
	            }
	            // if (event.method && response && response.result === mca.Result.success) {
	            if (event.method && response) {
	                switch (event.method) {
	                    case mca$6.McaMethod.newComm:
	                    case mca$6.McaMethod.startComm:
	                    case mca$6.McaMethod.closeComm:
	                    case mca$6.McaMethod.updateComm:
	                    case mca$6.McaMethod.getScreenPopDataEvent:
	                        detail = { event, response, invokeCommand: this.invokeCommand };
	                        break;
	                    case mca$6.McaMethod.interactionControlsChanged:
	                        detail = { event, response, invokeCommand: this.invokeCommand };
	                        break;
	                }
	            }
	            if (detail) {
	                const formattedEvent = { bubbles: true, cancelable: false, detail };
	                rv = new CustomEvent(eventName, formattedEvent);
	            }
	            return rv;
	        };
	        /**
	         * Since there is no Toolbar in the app window we will retrieve the supported Interaction Commands from cache.
	         * They will be written to the cache by the Parent Toolbar Window.
	         */
	        this.getInteractionCommandsFromCache = () => {
	            try {
	                if (!this.iCmdDest) {
	                    this.interactionCmdCache
	                        .fetch()
	                        .then((interactionCmds) => {
	                        this.cacheReady = true;
	                        if (interactionCmds) {
	                            logger$2.info(`${this.pre} Successfully retrieved Interaction Commands from cache`);
	                            this.iCmdDest = interactionCmds;
	                            this.toolbarCapabilityMap = interactionCmds;
	                            // Check if active interaction command
	                            if (this.activeInteractionCommand) {
	                                try {
	                                    logger$2.info(this.pre + 'Sending getInteractionCommands Response');
	                                    if (this.activeInteractionCommand.channelType && this.toolbarCapabilityMap.get(this.activeInteractionCommand.channelType)) {
	                                        this.activeInteractionCommand.responseCallback(this.toolbarCapabilityMap.get(this.activeInteractionCommand.channelType));
	                                        this.activeInteractionCommand = null;
	                                    }
	                                }
	                                catch (err) {
	                                    logger$2.error(`${this.pre} Error Sending getInteractionCommands Response`, err);
	                                }
	                            }
	                        }
	                    })
	                        .catch((reason) => {
	                        // This is expected the 1st time following a new session creation
	                        logger$2.info(`${this.pre} Unable to retrieve Interaction Commands from cache`);
	                        this.cacheReady = true;
	                        // The event was sent while opening the cache make sure this gets cached
	                        // This happens in the Toolbar Parent Window
	                        if (this.toolbarCapabilityMap) {
	                            this.interactionCmdCache.manualCacheData(this.toolbarCapabilityMap);
	                        }
	                    });
	                }
	            }
	            catch (err) {
	                logger$2.error(`${this.pre} Error retrieving Interaction Command Target from cache`);
	                logger$2.error(err);
	            }
	        };
	        this.getAgentCommandTargetFromCache = () => {
	            try {
	                if (!this.aCmdDest) {
	                    this.agentCmdCache
	                        .fetch()
	                        .then((agentCmdDest) => {
	                        if (agentCmdDest) {
	                            logger$2.info(`${this.pre} Successfully retrieved Agent Command Target from cache`);
	                            this.aCmdDest = agentCmdDest;
	                            // Check if active interaction command
	                            if (this.activeInteractionCommand) {
	                                try {
	                                    logger$2.info(this.pre + 'Sending getInteractionCommands Response');
	                                    if (this.activeInteractionCommand.channelType && this.toolbarCapabilityMap
	                                        && this.toolbarCapabilityMap.get(this.activeInteractionCommand.channelType)) {
	                                        this.activeInteractionCommand.responseCallback(this.toolbarCapabilityMap.get(this.activeInteractionCommand.channelType));
	                                        this.activeInteractionCommand = null;
	                                    }
	                                }
	                                catch (err) {
	                                    logger$2.error(this.pre + 'Error Sending getInteractionCommands Response', err);
	                                }
	                            }
	                        }
	                    })
	                        .catch((reason) => {
	                        // This is expected the 1st time following a new session creation in the Toolbar Parent Window
	                        logger$2.info(`${this.pre} Unable to retrieve Agent Command Target from cache`);
	                        if (this.aCmdDest) {
	                            // Event arrived while waiting for cache to open; ensure this is cached
	                            this.agentCmdCache.manualCacheData(this.aCmdDest);
	                        }
	                    });
	                }
	            }
	            catch (err) {
	                logger$2.error(`${this.pre} Error retrieving Agent Command Target from cache`);
	                logger$2.error(err);
	            }
	        };
	        /**
	         * This initializes the Local Indexed DB Storage and
	         * retrieves the agent state from cache
	         */
	        this.getAgentStateFromCache = () => {
	            try {
	                this.agentStateCache
	                    .fetch()
	                    .then((agentStateEvent) => {
	                    this.cacheReady = true;
	                    if (agentStateEvent) {
	                        logger$2.info(`${this.pre} Successfully retrieved Agent State from cache`);
	                        this.currentAgentState = agentStateEvent;
	                        if (!this.isToolbarWindowOpen()) {
	                            this.currentAgentState.data.isAvailable = false;
	                            this.currentAgentState.data.isLoggedIn = false;
	                            this.currentAgentState.data.stateCd = 'DISCONNECTED';
	                        }
	                        this.publishAgentStateEvent(this.currentAgentState);
	                    }
	                })
	                    .catch((reason) => {
	                    // This is expected the 1st time following a new session creation
	                    logger$2.info(`${this.pre} Unable to retrieve Agent State from cache`);
	                    this.cacheReady = true;
	                    // The event was sent while opening the cache make sure this gets cached
	                    // This happens in the Toolbar Parent Window
	                    if (this.currentAgentState) {
	                        this.agentStateCache.manualCacheData(this.currentAgentState);
	                    }
	                });
	            }
	            catch (err) {
	                logger$2.error(`${this.pre} Error retrieving Agent State from cache`);
	                logger$2.error(err);
	            }
	        };
	        this.checkTarget = (target) => {
	            let retVal = true;
	            if (target && target.trim().length > 0) {
	                if (target !== mca$6.EventSource.toolbar) {
	                    retVal = false;
	                }
	            }
	            return retVal;
	        };
	        this.checkChannel = (channelType) => {
	            let retVal = false;
	            if (this.supportedChannels) {
	                for (const channel of this.supportedChannels) {
	                    if (channelType === channel.channelType) {
	                        retVal = true;
	                        break;
	                    }
	                }
	            }
	            // In case channels haven't been initialized yet
	            if (!retVal) {
	                if (channelType === mca$6.ChannelType.phone) {
	                    retVal = true;
	                }
	            }
	            return retVal;
	        };
	        this.handleEngagementResponse = (response, event) => {
	            JSON.stringify(event);
	            JSON.stringify(response);
	            if (event.previewMode) {
	                response.previewMode = event.previewMode;
	            }
	            const newEvent = this.convertMcaEvent(event, response);
	            if (newEvent) {
	                this.dispatchClientEvent(newEvent);
	            }
	            if (event && event.method) {
	                // skip this step when doing unit test
	                switch (event.method) {
	                    case mca$6.McaMethod.newComm:
	                        let engagement = null;
	                        engagement = this.engMgr.getEngagement(event.data.eventId);
	                        // Don't send this if we already got a start or close
	                        if (engagement && engagement.lastEvent.method === mca$6.McaMethod.newComm) {
	                            this.checkAndSendNotify(event, true, response); // Update Notification with Response Data
	                        }
	                        break;
	                }
	            }
	            this.sendProviderResponse(response);
	        };
	        /**
	         * An Engagement Event was detected in another window.
	         * FYI, This event MAY have already been detected in this window as well.
	         */
	        this.handleEngagementEvent = (event) => {
	            logger$2.info(this.pre + 'handleEngagementEvent: ');
	            switch (event.method) {
	                case mca$6.McaMethod.newComm:
	                    this.showToolbar();
	                    this.checkAndSendNotify(event, true);
	                    break;
	                case mca$6.McaMethod.startComm:
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca$6.McaMethod.closeComm:
	                    const newEvent = this.convertMcaEvent(event, null);
	                    if (newEvent) {
	                        this.dispatchClientEvent(newEvent);
	                    }
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca$6.McaMethod.updateComm:
	                    this.sendToolbarDataUpdate(event);
	                    break;
	                case mca$6.McaMethod.getScreenPopDataEvent:
	                    this.sendToolbarDataUpdate(event);
	                    break;
	            }
	        };
	        /**
	         * Checks if a notification event is necessary and if so sends it.
	         */
	        this.checkAndSendNotify = (event, notifyOn, response) => {
	            if (!event || !event.data.inData || event.data.inData[mca$6.SystemToken.direction] === mca$6.DirectionToken.outbound) {
	                return;
	            }
	            if (notifyOn) {
	                if (!event.actions) {
	                    logger$2.info(this.pre + 'no notify Action set');
	                    return;
	                }
	                else {
	                    let notifyFound = false;
	                    for (const action of event.actions) {
	                        if (action.name === mca$6.ActionName.Notify) {
	                            notifyFound = true;
	                            break;
	                        }
	                    }
	                    if (!notifyFound) {
	                        logger$2.info(this.pre + 'no notify Action set');
	                        return;
	                    }
	                }
	            }
	            const detail = { event, response };
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const eventType = notifyOn ? mca$6.McaEventType.notifyOn : mca$6.McaEventType.notifyOff;
	            const ne = new CustomEvent(eventType, formattedEvent);
	            this.dispatchClientEvent(ne);
	        };
	        /**
	         * Send Data Updates to the Toolbar
	         */
	        this.sendToolbarDataUpdate = (event) => {
	            const outData = {};
	            for (const key in event.data.inData) {
	                if (event.data.inData.hasOwnProperty(key)) {
	                    switch (key) {
	                        case mca$6.Constants.EVENT_MAP_KEY:
	                            // TODO Add other attributes we don't want to cache here
	                            continue; // Don't Cache These!!!
	                    }
	                    outData[key] = event.data.inData[key];
	                }
	            }
	            outData[mca$6.McaKey.updateType] = mca$6.UpdateType.data;
	            const response = {
	                channel: event.data.channel,
	                channelType: event.data.channelType,
	                eventId: event.data.eventId,
	                method: mca$6.McaMethod.onDataUpdate,
	                origin: window.location.origin,
	                outData,
	                toolbarName: event.toolbarName,
	                uuid: event.uuid
	            };
	            this.sendProviderResponse(response);
	            logger$2.warn(this.pre + '<TODO> Remove Ref Toolbar Hack: manufacture startCommEvent Response for UI Update onDataUpdated ');
	            const hackResponse = {
	                channel: event.data.channel,
	                channelType: event.data.channelType,
	                eventId: event.data.eventId,
	                method: mca$6.McaMethod.startComm,
	                origin: window.location.origin,
	                outData,
	                toolbarName: event.toolbarName,
	                uuid: this.startCommUuid
	                // uuid: event.uuid - can't use this because it is likely the uuid for the event fired in the other window
	            };
	            this.sendProviderResponse(hackResponse);
	        };
	        // Ensure there are no mem leaks if command responses are not received
	        this.checkCommandResponseMap = () => {
	            const maxSize = 10;
	            if (this.commandResponseListenerMap.size > maxSize) {
	                logger$2.warn(this.pre + 'cmdResponse Map out of control: ' + this.commandResponseListenerMap.size);
	                const sortedArray = new Array();
	                for (const key of this.commandResponseListenerMap.keys()) {
	                    const value = this.commandResponseListenerMap.get(key);
	                    sortedArray.push(value);
	                }
	                sortedArray.sort(mca$6.Command.compare);
	                const newSize = maxSize / 2;
	                logger$2.info(this.pre + 'Purging ' + (maxSize - newSize) + ' items from cmdResponseMap');
	                for (let i = 0; i < newSize; i++) {
	                    const cmd = sortedArray[i];
	                    const resp = new mca$6.CommandResponse(cmd.command, mca$6.Result.error, cmd.commandId, cmd.eventId, { reason: 'TIMEDOUT' });
	                    try {
	                        cmd.responseCallback(resp);
	                    }
	                    catch (err) {
	                        logger$2.info(err);
	                    }
	                    this.commandResponseListenerMap.delete(cmd.commandId);
	                }
	            }
	        };
	        this.queueMessage = (eventData) => {
	            this.tbMessagesQueue.push(eventData);
	        };
	        this.sendFrameMessage = (eventData) => {
	            if (eventData && eventData.uuid) {
	                if (eventData.uuid === mca$6.Constants.INTERNAL) {
	                    return; // Don't send internal events to the toolbar
	                }
	            }
	            oj_mca_common_1$6.McaCommon.sendToUef(eventData);
	            if (!this.isToolbarWindowOpen()) {
	                this.queueMessage(eventData);
	                return;
	            }
	            try {
	                const payload = JSON.stringify(eventData);
	                logger$2.info(`${this.pre} ===> Toolbar Window\n${payload}`);
	                const message = {
	                    dest: 'toolbar',
	                    payload
	                };
	                this.toolbarBroadcastChannel.postMessage(message);
	            }
	            catch (err) {
	                logger$2.error(`${this.pre} Error sending Toolbar Message`);
	                logger$2.error(err);
	            }
	        };
	        this.checkQueuedMessages = () => {
	            if (this.isToolbarWindowOpen()) {
	                while (this.tbMessagesQueue.length > 0) {
	                    const eventData = this.tbMessagesQueue.shift();
	                    if (eventData) {
	                        const payload = JSON.stringify(eventData);
	                        logger$2.info(`${this.pre} ===> Queued message to Toolbar Window\n${payload}`);
	                        const message = {
	                            dest: 'toolbar',
	                            payload
	                        };
	                        this.toolbarBroadcastChannel.postMessage(message);
	                    }
	                }
	            }
	            else {
	                window.setTimeout(this.checkQueuedMessages, 2 * 1000);
	            }
	        };
	        this.getToolbarWindowUrl = () => {
	            let windowUrl = window.location.origin;
	            // FOR LOCAL TESTING ONLY
	            // windowUrl += '/crmUI/toolbar-window/index.html';
	            // END LOCAL TEST
	            windowUrl += '/fscmUI/redwood/service/ec/admin/mca/toolbar';
	            windowUrl += '?ojSpShellVisible=false';
	            return windowUrl;
	        };
	        this.launchToolbarWindow = () => {
	            const windowConf = {};
	            // TODO Read Configurations from UserConfigurations
	            windowConf.top = '0';
	            windowConf.left = '0';
	            windowConf.height = '' + window.innerHeight;
	            windowConf.width = '370';
	            let options = 'resizable=yes,popup=true,location=no,toolbar=no,status=no,menubar=no';
	            const top = ',top=' + windowConf.top;
	            const left = ',left=' + windowConf.left;
	            const height = ',height=' + window.outerHeight;
	            const width = ',width=' + windowConf.width;
	            options = options + top + left + height + width;
	            const tbWinUrl = this.getToolbarWindowUrl();
	            try {
	                window.open(tbWinUrl, mca$6.Constants.TOOLBAR_WINDOW, options);
	            }
	            catch (err) {
	                logger$2.error(this.pre + 'Error launching Toolbar Window', err);
	            }
	        };
	        this.userConfigurations = properties.userConfigurations;
	        this.mcaEventTarget = properties.onMcaEvent;
	        this.agentStateEventTarget = properties.onMcaAgentStateEvent;
	        this.notificationEventTarget = properties.onNotifyOnEvent;
	        this.init();
	    }
	}
	mcaAdfContainer.McaAdfContainer = McaAdfContainer;
	McaAdfContainer.ICMDKEY = 'interactionCommands';
	McaAdfContainer.ACMDKEY = 'agentCommands';

	var mcaAdfPresence = {};

	var mcaSharedWorker = {};

	var __awaiter$4 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaSharedWorker, "__esModule", { value: true });
	mcaSharedWorker.McaSharedWorker = void 0;
	const ko$4 = knockoutLatestExports;
	const mcaLogger_1$4 = requireMcaLogger();
	const mca$5 = requireMcaCommonTypes();
	class McaSharedWorker {
	    constructor() {
	        this.pre = '[McaSharedWorker] ';
	        this.workerPromise = null;
	        this.isInitialized = false;
	        this.messagesQueue = [];
	        this.isVbEnabled = true;
	        // When we set the agent's presence on Omni it automatically updates the agent's availability
	        // therefore we must wait for this to complete before we check the availability
	        this.initOmniSessionComplete = ko$4.observable(false);
	        this.initialize = (userConfig, sessionId) => {
	            if (!this.isInitialized && this.workerPromise === null) {
	                this.initOmniSessionComplete.subscribe(this.initOmniSessionCompleteHandler);
	                this.workerPromise = new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
	                    if (!localStorage.getItem(mca$5.Constants.MCA_SHARED_WORKER_URL) ||
	                        (localStorage.getItem(mca$5.Constants.MCA_SHARED_WORKER_URL) && !(yield this.isValidFile(localStorage.getItem(mca$5.Constants.MCA_SHARED_WORKER_URL))))) {
	                        let workerFilepath = null;
	                        if (this.isVbEnabled) {
	                            workerFilepath = commonjsRequire.toUrl('./worker.js');
	                            mcaLogger_1$4.McaLogger.info(`${this.pre} MCA worker Url path: ${workerFilepath}`);
	                            let devMode = false;
	                            if (window[mca$5.Constants.VB_CONFIG] && window[mca$5.Constants.VB_CONFIG][mca$5.Constants.LOCAL_MODE] === true) {
	                                devMode = true;
	                            }
	                            if (!devMode) {
	                                if (!workerFilepath.includes('debug/common')) {
	                                    workerFilepath = workerFilepath.replace('common/worker.js', 'debug/common/worker.js');
	                                }
	                            }
	                        }
	                        else {
	                            workerFilepath = '/crmUI/js/worker.js';
	                        }
	                        if (workerFilepath) {
	                            let response = yield fetch(workerFilepath);
	                            if ((response === null || response === void 0 ? void 0 : response.status) === 404) {
	                                // Handle local override
	                                if (workerFilepath.includes('debug/common')) {
	                                    workerFilepath = workerFilepath.replace('debug/common/worker.js', 'common/worker.js');
	                                    response = yield fetch(workerFilepath);
	                                }
	                            }
	                            const blob = yield response.blob();
	                            const urlForMcaSharedWorker = URL.createObjectURL(blob);
	                            localStorage.setItem(mca$5.Constants.MCA_SHARED_WORKER_URL, urlForMcaSharedWorker);
	                        }
	                    }
	                    const blobURL = localStorage.getItem(mca$5.Constants.MCA_SHARED_WORKER_URL);
	                    if (!this.workerInstance) {
	                        // tslint:disable-next-line: no-string-literal
	                        this.workerInstance = new window['SharedWorker'](blobURL, 'MCASharedWorker');
	                    }
	                    if (!this.isInitialized) {
	                        this.initializeWorkerListener();
	                        let demoSeedJwt = null;
	                        try {
	                            demoSeedJwt = localStorage.getItem(mca$5.Constants.DEMO_SEED_JWT);
	                        }
	                        catch (errSeedJwt) { }
	                        let workerOrigin = window.location.origin;
	                        if (window[mca$5.Constants.VB_CONFIG] && window[mca$5.Constants.VB_CONFIG][mca$5.Constants.LOCAL_MODE] === true) {
	                            if (window[mca$5.Constants.VB_CONFIG][mca$5.Constants.LOCAL_MODE_WORKER_SERVER]) {
	                                workerOrigin = window[mca$5.Constants.VB_CONFIG][mca$5.Constants.LOCAL_MODE_WORKER_SERVER];
	                            }
	                        }
	                        let unitTestMode = false;
	                        if (window[mca$5.Constants.VB_CONFIG] && window[mca$5.Constants.VB_CONFIG][mca$5.Constants.UNITTEST_MODE] === true) {
	                            unitTestMode = true;
	                        }
	                        // Initialize rest services
	                        this.workerInstance.port.postMessage({
	                            agentPartyId: userConfig.userDetails.agentPartyId,
	                            debugMode: userConfig.userDetails.debugMode,
	                            demoSeedJwt,
	                            jwtTkn: userConfig.userDetails.faTrustToken,
	                            method: 'InitializeRest',
	                            origin: workerOrigin,
	                            sessionId,
	                            unitTestMode
	                        });
	                        // check any requests queued and process
	                        this.checkQueuedMessages();
	                        this.isInitialized = true;
	                    }
	                    resolve();
	                }));
	            }
	            return this.workerPromise;
	        };
	        this.isWorkerInitialized = () => {
	            return this.isInitialized;
	        };
	        this.updateJwtTkn = (newJwtTkn) => {
	            if (this.isInitialized) {
	                this.workerInstance.port.postMessage({
	                    jwtTkn: newJwtTkn,
	                    method: 'RenewRest'
	                });
	            }
	        };
	        this.sendRequest = (request) => {
	            if (this.workerInstance) {
	                if (this.isInitialized && this.initOmniSessionComplete()) {
	                    this.workerInstance.port.postMessage(request);
	                }
	                else {
	                    // queue until init finishes
	                    this.enqueueMessage(request);
	                }
	            }
	            else {
	                // queue until init finishes
	                this.enqueueMessage(request);
	            }
	        };
	        this.isValidFile = (blobURL) => __awaiter$4(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                let sharedWorker = null;
	                try {
	                    let timeoutRef = null;
	                    // tslint:disable-next-line: no-string-literal
	                    sharedWorker = new window['SharedWorker'](blobURL, 'MCASharedWorker');
	                    sharedWorker.onerror = (event) => {
	                        resolve(false);
	                        if (timeoutRef) {
	                            clearTimeout(timeoutRef);
	                        }
	                    };
	                    timeoutRef = setTimeout(() => {
	                        this.workerInstance = sharedWorker;
	                        resolve(true);
	                    }, 500);
	                }
	                catch (e) {
	                    resolve(false);
	                }
	            });
	        });
	        this.initializeWorkerListener = () => {
	            this.workerInstance.onerror = (eventError) => {
	                mcaLogger_1$4.McaLogger.error(`${this.pre} MCA worker create ERROR!`);
	                if (eventError) {
	                    mcaLogger_1$4.McaLogger.error(JSON.stringify(eventError));
	                }
	            };
	            this.workerInstance.port.onmessage = (eventData) => {
	                var _a, _b, _c;
	                mcaLogger_1$4.McaLogger.info(`${this.pre} MCA received worker response!`);
	                mcaLogger_1$4.McaLogger.log(`${this.pre} MCA received worker response!`, eventData);
	                if ((_a = eventData === null || eventData === void 0 ? void 0 : eventData.data) === null || _a === void 0 ? void 0 : _a.method) {
	                    mcaLogger_1$4.McaLogger.info(`${this.pre} MCA worker response method: ${eventData.data.method}`);
	                    const method = eventData.data.method;
	                    if (((_b = eventData.data) === null || _b === void 0 ? void 0 : _b.status) === 'Error' && ((_c = eventData.data) === null || _c === void 0 ? void 0 : _c.reason)) {
	                        mcaLogger_1$4.McaLogger.error(`${this.pre} Method: ${method} failed ${eventData.data.reason}`);
	                    }
	                    let eventForDispatch = null;
	                    switch (method) {
	                        case 'GetSRAvailability':
	                            const swGetSRAvailEvent = { bubbles: true, cancelable: false, detail: { srAvailability: eventData.data.srAvailability } };
	                            eventForDispatch = new CustomEvent('mcaSWGetSRAvailResp', swGetSRAvailEvent);
	                            break;
	                        case 'SetSRAvailability':
	                            const swSetSRAvailEvent = { bubbles: true, cancelable: false, detail: { srAvailability: eventData.data.srAvailability } };
	                            eventForDispatch = new CustomEvent('mcaSWSetSRAvailResp', swSetSRAvailEvent);
	                            break;
	                        case 'RenewRest':
	                            const swRenewEvent = { bubbles: true, cancelable: false, detail: {} };
	                            eventForDispatch = new CustomEvent('mcaSWRenewTkn', swRenewEvent);
	                            break;
	                        case 'InitOmniSession':
	                            this.initOmniSessionComplete(true);
	                            const initOmniCompleteEvent = { bubbles: true, cancelable: false, detail: { reason: eventData.data.reason, status: eventData.data.status } };
	                            eventForDispatch = new CustomEvent('mcaInitOmniComplete', initOmniCompleteEvent);
	                            break;
	                    }
	                    if (eventForDispatch) {
	                        try {
	                            window.dispatchEvent(eventForDispatch);
	                        }
	                        catch (err) {
	                            mcaLogger_1$4.McaLogger.error(`${this.pre} Dispatch failure for method: ${method} Error: ${err}`);
	                            mcaLogger_1$4.McaLogger.error(err);
	                        }
	                    }
	                    // else nothing to do 
	                }
	            };
	        };
	        this.enqueueMessage = (message) => {
	            if (message.method) {
	                for (let i = 0; i < this.messagesQueue.length; i++) {
	                    const initRequest = this.messagesQueue[i];
	                    if ((initRequest === null || initRequest === void 0 ? void 0 : initRequest.method) === message.method) {
	                        mcaLogger_1$4.McaLogger.info(`${this.pre} Ignoring duplicate message ${message.method}`);
	                        return;
	                    }
	                }
	            }
	            this.messagesQueue.push(message);
	        };
	        this.dequeueMessage = () => {
	            return this.messagesQueue.shift();
	        };
	        this.checkQueuedMessages = () => {
	            if (this.workerInstance) {
	                if (this.initOmniSessionComplete()) {
	                    while (this.messagesQueue.length > 0) {
	                        const request = this.dequeueMessage();
	                        const requestPayload = JSON.stringify(request);
	                        mcaLogger_1$4.McaLogger.info(`${this.pre} ===> Queued request sent to worker: ${requestPayload}`);
	                        this.workerInstance.port.postMessage(request);
	                    }
	                }
	                else {
	                    // Ensure the InitOmniSession is completely processed before all other messages are processed
	                    for (let i = 0; i < this.messagesQueue.length; i++) {
	                        const initRequest = this.messagesQueue[i];
	                        if ((initRequest === null || initRequest === void 0 ? void 0 : initRequest.method) === 'InitOmniSession') {
	                            this.messagesQueue.splice(i, 1);
	                            const initRequestPayload = JSON.stringify(initRequest);
	                            mcaLogger_1$4.McaLogger.info(`${this.pre} ===> Queued *init* request sent to worker: ${initRequestPayload}`);
	                            this.workerInstance.port.postMessage(initRequest);
	                            break;
	                        }
	                    }
	                }
	            }
	        };
	        this.initOmniSessionCompleteHandler = (newValue) => {
	            mcaLogger_1$4.McaLogger.info(`${this.pre} initOmniSession Completed`);
	            this.checkQueuedMessages();
	        };
	        if (window.vb && window.vb.version) {
	            this.isVbEnabled = true;
	        }
	        else {
	            this.isVbEnabled = false;
	        }
	    }
	    static getInstance() {
	        if (!McaSharedWorker.instance) {
	            McaSharedWorker.instance = new McaSharedWorker();
	        }
	        return McaSharedWorker.instance;
	    }
	}
	mcaSharedWorker.McaSharedWorker = McaSharedWorker;

	Object.defineProperty(mcaAdfPresence, "__esModule", { value: true });
	mcaAdfPresence.McaAdfPresence = void 0;
	const ko$3 = knockoutLatestExports;
	const mca$4 = requireMcaCommonTypes();
	const mca_shared_worker_1$1 = mcaSharedWorker;
	const oj_mca_common_1$5 = requireOjMcaCommon();
	const logger$1 = require$$0;
	var OmniMediaGroups;
	(function (OmniMediaGroups) {
	    OmniMediaGroups["chat"] = "ORA_SVC_MEDIA_CHAT";
	    OmniMediaGroups["nrtWork"] = "ORA_SVC_MEDIA_WORK";
	})(OmniMediaGroups || (OmniMediaGroups = {}));
	class McaAdfPresence {
	    constructor(properties) {
	        var _a, _b;
	        this.pre = '[McaAdfPresence] ';
	        this.agentStates = new Map();
	        this.ctiToolbarLoadStatus = ko$3.observable(mca$4.EventState.start);
	        this.mercuryChannelLoadStatus = ko$3.observable(mca$4.EventState.start);
	        this.omniChannelLoadStatus = ko$3.observable(mca$4.EventState.start);
	        this.useMcaSharedWorker = true;
	        this.toggleOmniAvailability = (channel) => {
	            const currentCase = this.agentStates.get(channel);
	            let commandAction = mca$4.AgentCommandName.makeAvailable;
	            const currentChannelType = currentCase.channelType;
	            if (currentCase.isAvailable) {
	                currentCase.isAvailable = false;
	                currentCase.workTypeAvailableIcon = '';
	                commandAction = mca$4.AgentCommandName.makeUnavailable;
	            }
	            else {
	                currentCase.isAvailable = true;
	                currentCase.workTypeAvailableIcon = 'oj-ux-ico-check';
	            }
	            if (channel === mca$4.Constants.CHAT) {
	                if (this.userConfigurations.mercuryInfo.chatEnabled && this.mercuryAdapter) {
	                    if (this.getOmniChannelSelectDisabled(mca$4.Constants.CHAT) && !currentCase.isAvailable) {
	                        // Shouldn't really happen since the Menu Item is disabled
	                        logger$1.warn(`${this.pre} Service Request Selection Disabled, Ignoring channelMercuryAvailableToggle!`);
	                        return;
	                    }
	                    const chatSetAgentStateCallback = (response) => {
	                        if (response.result === mca$4.Result.success) {
	                            logger$1.info(`${this.pre} channelMercuryAvailableToggle toggle availability succesfully for Chat!`);
	                            this.agentStates.set(mca$4.Constants.CHAT, currentCase);
	                            this.dispatchClientEvent(currentCase);
	                            this.broadcastEvent(currentCase);
	                        }
	                        else {
	                            logger$1.error(`${this.pre} channelMercuryAvailableToggle error while toggle availability for Chat!`);
	                            currentCase.workTypeAvailableIcon = '';
	                            currentCase.isAvailable = false;
	                            currentCase.isLoggedIn = false;
	                            this.agentStates.set(mca$4.Constants.CHAT, currentCase);
	                            this.dispatchClientEvent(currentCase);
	                            this.broadcastEvent(currentCase);
	                        }
	                    };
	                    const toggleAvailable = new mca$4.Command(commandAction, null, currentChannelType, null, chatSetAgentStateCallback, mca$4.EventSource.mercury, mca$4.Constants.CHAT);
	                    this.mercuryAdapter.invokeCommand(toggleAvailable);
	                }
	            }
	            else if (channel === mca$4.Constants.SERVICE_REQUEST) {
	                if (this.getOmniChannelSelectDisabled(mca$4.Constants.SERVICE_REQUEST)) {
	                    // Shouldn't really happen since the Menu Item is disabled
	                    logger$1.warn(`${this.pre} Service Request Selection Disabled, Ignoring channelMercuryAvailableToggle!`);
	                    return;
	                }
	                if (this.useMcaSharedWorker) {
	                    this.sharedWorker.sendRequest({
	                        method: 'SetSRAvailability',
	                        newAvailability: currentCase.isAvailable
	                    });
	                }
	            }
	        };
	        this.getSRAvailabilityFromWorkerListener = (event) => {
	            logger$1.info(`${this.pre} ===> getSRAvailabilityFromWorkerListener`);
	            let isAvailable = false;
	            if (event && event.detail && event.detail.srAvailability) {
	                isAvailable = event.detail.srAvailability;
	            }
	            if (!isAvailable && this.getOmniChannelSelectDisabled(mca$4.Constants.SERVICE_REQUEST)) {
	                // Always Force Available if Selection is Disabled 
	                logger$1.info(`${this.pre} Forcing SRAvailability based on SVC_OMNI_DISABLE_WORK_ITEM_AVAILABILITY_SELECTION Profile Option`);
	                isAvailable = true;
	                if (this.useMcaSharedWorker) {
	                    this.sharedWorker.sendRequest({
	                        method: 'SetSRAvailability',
	                        newAvailability: true
	                    });
	                }
	            }
	            const disableSRSelect = this.getOmniChannelSelectDisabled(mca$4.Constants.SERVICE_REQUEST);
	            const srAgentState = {
	                channel: mca$4.ChannelType.none,
	                channelType: mca$4.ChannelType.none,
	                displayName: 'Service Request',
	                isAvailable,
	                isLoggedIn: true,
	                readOnly: disableSRSelect,
	                workType: mca$4.Constants.SERVICE_REQUEST,
	                workTypeAccessAllowed: true
	            };
	            this.agentStates.set(mca$4.Constants.SERVICE_REQUEST, srAgentState);
	            this.dispatchClientEvent(srAgentState);
	            this.omniChannelLoadStatus(mca$4.EventState.complete);
	        };
	        this.setSRAvailabilityFromWorkerListener = (event) => {
	            const currentCase = this.agentStates.get(mca$4.Constants.SERVICE_REQUEST);
	            let isAvailable = currentCase.isAvailable;
	            if (event && event.detail && event.detail.srAvailability) {
	                isAvailable = event.detail.srAvailability;
	            }
	            if (isAvailable === false) {
	                const disableSRSelect = this.getOmniChannelSelectDisabled(mca$4.Constants.SERVICE_REQUEST);
	                if (disableSRSelect === true) {
	                    logger$1.info(`${this.pre} Force SRAvailability, Select Disabled`);
	                    if (this.useMcaSharedWorker) {
	                        this.sharedWorker.sendRequest({
	                            method: 'SetSRAvailability',
	                            newAvailability: true
	                        });
	                    }
	                }
	                currentCase.isAvailable = false;
	                currentCase.workTypeAvailableIcon = '';
	            }
	            else {
	                currentCase.isAvailable = true;
	                currentCase.workTypeAvailableIcon = 'oj-ux-ico-check';
	            }
	            this.agentStates.set(mca$4.Constants.SERVICE_REQUEST, currentCase);
	            this.dispatchClientEvent(currentCase);
	            this.broadcastEvent(currentCase);
	        };
	        this.dispatchClientEvent = (detail) => {
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const customEvent = new CustomEvent(mca$4.McaEventType.agentState, formattedEvent);
	            this.agentStateEventTarget(customEvent);
	        };
	        this.broadcastEvent = (event) => {
	            if (!this.presenceBroadcastChannel || !event) {
	                return;
	            }
	            try {
	                const payload = JSON.stringify(event);
	                logger$1.info(`${this.pre}[Broadcasting] ===> ${payload}`);
	                this.presenceBroadcastChannel.postMessage(event);
	            }
	            catch (err) {
	                logger$1.error(`${this.pre} Error broadcasting AgentState ${err}`);
	                logger$1.error(err);
	            }
	        };
	        this.retrieveChannelsAndStates = () => {
	            this.retrieveMercuryChannelsAndStates();
	            this.retrieveToolbarChannelsAndStates();
	            if (this.userConfigurations.mercuryInfo.srRoutingEnabled || this.userConfigurations.mercuryInfo.chatEnabled) {
	                // Non-Toolbar AgentState changes are broadcast to other windows via the Presence Broadcast Channel
	                try {
	                    this.presenceBroadcastChannel = new BroadcastChannel(mca$4.Constants.PRESENCE_BROADCAST_CHANNEL);
	                    this.presenceBroadcastChannel.onmessage = this.onBroadcastListener;
	                }
	                catch (err) {
	                    logger$1.error(`${this.pre}Error registering ${mca$4.Constants.PRESENCE_BROADCAST_CHANNEL}: ${err}`);
	                    logger$1.error(err);
	                }
	            }
	        };
	        this.onBroadcastListener = (event) => {
	            if (event && event.data && event.data.channel) {
	                logger$1.info(`${this.pre} Received broadcast event: ${JSON.stringify(event.data)}`);
	            }
	            else {
	                return;
	            }
	            let stateName = mca$4.Constants.CHAT;
	            if (event.data.channel === mca$4.ChannelType.none && event.data.workType) {
	                switch (event.data.workType) {
	                    case mca$4.Constants.SERVICE_REQUEST:
	                        stateName = mca$4.Constants.SERVICE_REQUEST;
	                        break;
	                    // TODO Add Other Cases if we add support for additional Omni Channels
	                    default:
	                        // key = event.data.workType; // this may work as well
	                        stateName = mca$4.Constants.SERVICE_REQUEST;
	                }
	            }
	            this.agentStates.set(stateName, event.data);
	            this.dispatchClientEvent(event.data);
	        };
	        this.retrieveToolbarChannelsAndStates = () => {
	            if (this.toolbarAdapter) {
	                this.ctiToolbarLoadStatus(mca$4.EventState.start);
	                const toolbarStates = this.toolbarAdapter.getAgentStates();
	                toolbarStates.then((ctiStates) => {
	                    ctiStates.forEach((value, key) => {
	                        this.agentStates.set(key, value);
	                    });
	                    this.ctiToolbarLoadStatus(mca$4.EventState.complete);
	                }).catch((reason) => {
	                    this.ctiToolbarLoadStatus(mca$4.EventState.fail);
	                    logger$1.error(`${this.pre} Error while retrieving CTI agent states: ${reason}`);
	                });
	                this.ctiToolbarLoadStatus(mca$4.EventState.complete);
	            }
	            else {
	                this.ctiToolbarLoadStatus(mca$4.EventState.complete);
	            }
	        };
	        this.retrieveMercuryChannelsAndStates = () => {
	            var _a;
	            if (this.userConfigurations.mercuryInfo.srRoutingEnabled || this.userConfigurations.mercuryInfo.chatEnabled) {
	                // This is done now in main - 'StartAgentSessionFlag' : true
	                if (this.useMcaSharedWorker) {
	                    this.sharedWorker.sendRequest({
	                        method: 'StartOmniKeepAlive'
	                    });
	                }
	            }
	            if (this.userConfigurations.mercuryInfo.srRoutingEnabled && ((_a = this.userConfigurations.userDetails) === null || _a === void 0 ? void 0 : _a.agentPartyId)) {
	                this.omniChannelLoadStatus(mca$4.EventState.start);
	                // Create and add the agent channel state
	                const agentState = {
	                    channel: mca$4.ChannelType.none,
	                    channelType: mca$4.ChannelType.none,
	                    displayName: 'Service Request',
	                    isAvailable: false,
	                    isLoggedIn: false,
	                    workType: mca$4.Constants.SERVICE_REQUEST,
	                    workTypeAccessAllowed: true
	                };
	                this.agentStates.set(mca$4.Constants.SERVICE_REQUEST, agentState);
	                // Retrieve availability for Non RT Work
	                if (this.useMcaSharedWorker) {
	                    this.sharedWorker.sendRequest({
	                        method: 'GetSRAvailability'
	                    });
	                }
	            }
	            else {
	                this.omniChannelLoadStatus(mca$4.EventState.complete);
	            }
	            if (this.mercuryAdapter) {
	                this.mercuryChannelLoadStatus(mca$4.EventState.start);
	                const mStates = this.mercuryAdapter.getAgentStates();
	                mStates.then((mercuryStates) => {
	                    let forceChannelAvailEvents = null;
	                    mercuryStates.forEach((value, key) => {
	                        value.workTypeAccessAllowed = true;
	                        value.readOnly = this.getOmniChannelSelectDisabled(value.channel);
	                        if (value.readOnly === true && value.isAvailable === false) {
	                            logger$1.warn(`${this.pre} Need to force availability for ${value.channel} based on SVC_OMNI_DISABLE_WORK_ITEM_AVAILABILITY_SELECTION Profile Option`);
	                            if (!forceChannelAvailEvents) {
	                                forceChannelAvailEvents = new Array();
	                            }
	                            forceChannelAvailEvents.push(value.channel);
	                        }
	                        this.agentStates.set(key, value);
	                        this.dispatchClientEvent(value);
	                    });
	                    this.mercuryChannelLoadStatus(mca$4.EventState.complete);
	                    // In case we need to auto-force Availability because of the SVC_OMNI_DISABLE_WORK_ITEM_AVAILABILITY_SELECTION Profile Option 
	                    if (forceChannelAvailEvents && forceChannelAvailEvents.length > 0) {
	                        for (let i = 0; i < forceChannelAvailEvents.length; i++) {
	                            this.toggleOmniAvailability(forceChannelAvailEvents[i]);
	                        }
	                    }
	                }).catch((reason) => {
	                    this.mercuryChannelLoadStatus(mca$4.EventState.fail);
	                    logger$1.error(`${this.pre} Error while retrieving Mercury agent states: ${reason}`);
	                });
	                this.mercuryChannelLoadStatus(mca$4.EventState.complete);
	            }
	            else {
	                this.mercuryChannelLoadStatus(mca$4.EventState.complete);
	            }
	        };
	        this.getOmniChannelSelectDisabled = (workType) => {
	            var _a;
	            let retVal = false;
	            switch ((_a = this.userConfigurations.mercuryInfo) === null || _a === void 0 ? void 0 : _a.profileOmniDisableAvailSelect) {
	                case mca$4.OmniProfileOptionValues.none:
	                    break;
	                case mca$4.OmniProfileOptionValues.all:
	                    retVal = true;
	                    break;
	                case mca$4.OmniProfileOptionValues.nrt:
	                    if (mca$4.Constants.SERVICE_REQUEST === workType) {
	                        retVal = true;
	                    }
	                    break;
	                case mca$4.OmniProfileOptionValues.chat:
	                    if (mca$4.Constants.CHAT === workType) {
	                        retVal = true;
	                    }
	                    break;
	            }
	            logger$1.info(`${this.pre}Disable Select for ${workType} is ${retVal}`);
	            return retVal;
	        };
	        this.userConfigurations = properties.userConfigurations;
	        this.mercuryAdapter = properties.mercuryAdapter;
	        this.toolbarAdapter = properties.toolbarAdapter;
	        this.agentStateEventTarget = properties.onMcaAgentStateEvent;
	        this.sharedWorker = mca_shared_worker_1$1.McaSharedWorker.getInstance();
	        if ((_b = (_a = this.userConfigurations) === null || _a === void 0 ? void 0 : _a.userDetails) === null || _b === void 0 ? void 0 : _b.agentPartyId) {
	            if (!this.sharedWorker.isWorkerInitialized()) {
	                this.sharedWorker.initialize(this.userConfigurations, oj_mca_common_1$5.McaCommon.getSessionId());
	            }
	        }
	        else {
	            this.useMcaSharedWorker = false;
	        }
	        // register listeners for response
	        window.addEventListener('mcaSWGetSRAvailResp', this.getSRAvailabilityFromWorkerListener, false);
	        window.addEventListener('mcaSWSetSRAvailResp', this.setSRAvailabilityFromWorkerListener, false);
	        // init
	        this.retrieveChannelsAndStates();
	    }
	}
	mcaAdfPresence.McaAdfPresence = McaAdfPresence;

	var mcaMercuryCopy = {};

	(function (exports) {
		/*
		 * To change this license header, choose License Headers in Project Properties.
		 * To change this template file, choose Tools | Templates
		 * and open the template in the editor.
		 */
		/**
		 * This file contains a copy of the mercury-client classes.
		 *
		 * Since the correct mercury-client version path is getting dynamically injected
		 * there are no more direct import dependencies allowed on oracle-mercury-client.
		 * These dependendcies should now be made against these classes.
		 * Only exception is the mca-mercury adapter class which is lazy loaded.  In other
		 * words it is not included via any imports.
		 * @see oj-mca/common/loader
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ConnectionStateType = exports.FeedbackActions = exports.FeedbackItems = exports.ChannelStateType = exports.WorkOfferBehaviorType = exports.OfferResponseType = exports.OfferActionType = exports.ActivityType = exports.AsyncResponseType = exports.ChannelDestinationType = exports.AvailabilityType = exports.ErrorReason = exports.MercuryEventType = exports.AssignmentType = exports.MessageType = exports.OfferStatusTypes = exports.ResourceType = exports.ParticipationRoleType = void 0;
		(function (ParticipationRoleType) {
		    /** Unknown role  */
		    ParticipationRoleType["UNKNOWN"] = "UNKNOWN";
		    /** Consumer or initiattor of the Channel */
		    ParticipationRoleType["ENDUSER"] = "END_USER";
		    /** Consumer or initiattor of the Channel */
		    ParticipationRoleType["END_USER"] = "END_USER";
		    /** The leader of the Channel/Conversation */
		    ParticipationRoleType["LEAD"] = "LEAD";
		    /** Someone invited into the Channel */
		    ParticipationRoleType["CONFEREE"] = "CONFEREE";
		    /** Someone who is monitoring the Channel */
		    ParticipationRoleType["MONITOR"] = "MONITOR";
		    ParticipationRoleType["AGENT"] = "AGENT";
		})(exports.ParticipationRoleType || (exports.ParticipationRoleType = {}));
		(function (ResourceType) {
		    ResourceType["HUMAN"] = "HUMAN";
		    ResourceType["BOT"] = "BOT";
		    ResourceType["END_USER"] = "END_USER";
		    ResourceType["AGENT"] = "AGENT";
		})(exports.ResourceType || (exports.ResourceType = {}));
		(function (OfferStatusTypes) {
		    OfferStatusTypes["NONE"] = "NONE";
		    OfferStatusTypes["ACCEPTED"] = "ACCEPTED";
		    OfferStatusTypes["DECLINED"] = "DECLINED";
		    OfferStatusTypes["AVAILABLE"] = "AVAILABLE";
		    OfferStatusTypes["UNAVAILABLE"] = "UNAVAILABLE";
		    OfferStatusTypes["TIMEOUT"] = "TIMEOUT";
		})(exports.OfferStatusTypes || (exports.OfferStatusTypes = {}));
		(function (MessageType) {
		    MessageType["STRUCTURED"] = "STRUCTURED";
		    MessageType["RICHTEXT"] = "RICH_TEXT";
		})(exports.MessageType || (exports.MessageType = {}));
		(function (AssignmentType) {
		    /** This indicates that the assignment is comes with it ownership or 'lead' of the work */
		    AssignmentType["LEAD"] = "LEAD";
		    /**  This indicates that the assignment is a transfer of work from some other resource and comes with it ownership of the work */
		    AssignmentType["TRANSFER"] = "TRANSFER";
		    /**  This indicates that the assignment is a invitation to collaborate on work (Ownership does not come with this) */
		    AssignmentType["CONFERENCE"] = "CONFERENCE";
		    /**  This indicates that the assignment is a invitation to monitor ongoing work (Ownership does not come with this) */
		    AssignmentType["MONITOR"] = "MONITOR";
		})(exports.AssignmentType || (exports.AssignmentType = {}));
		(function (MercuryEventType) {
		    /** The state of an Offer has changed */
		    MercuryEventType["OFFER_STATUS"] = "OFFER_STATUS";
		    /** An Offer has been retracted */
		    MercuryEventType["OFFER_CANCELLATION"] = "OFFER_CANCELLATION";
		    /** A Channel has been assigned to the Session */
		    MercuryEventType["CHANNEL_ADDED"] = "CHANNEL_ADDED";
		    /** A Channel has been removed from the Session */
		    MercuryEventType["CHANNEL_REMOVED"] = "CHANNEL_REMOVED";
		    /** A Work invitation is being offered */
		    MercuryEventType["WORK_OFFER"] = "WORK_OFFER";
		    /** Availability has changed */
		    MercuryEventType["AVAILABILITY_CHANGE"] = "AVAILABILITY_CHANGE";
		    /** A message has arrived on the Channel */
		    MercuryEventType["MESSAGE_ADDED"] = "MESSAGE_ADDED";
		    /** A message has been updated */
		    MercuryEventType["MESSAGE_UPDATED"] = "MESSAGEU_PDATED";
		    /** A message has been removed from the Channel */
		    MercuryEventType["MESSAGE_REMOVED"] = "MESSAGE_REMOVED";
		    /** Activity has occurred on the Channel */
		    MercuryEventType["ACTIVITY_CHANGE"] = "ACTIVITY_CHANGE";
		    /** A Participant  has joined the Channel */
		    MercuryEventType["MEMBER_JOINED"] = "MEMBER_JOINED";
		    /** A Participant  has left the Channel */
		    MercuryEventType["MEMBER_LEFT"] = "MEMBER_LEFT";
		    /** A Participant's details have been updated */
		    MercuryEventType["MEMBER_UPDATED"] = "MEMBER_UPDATED";
		    MercuryEventType["CONTROL_MESSAGE"] = "CONTROL_MESSAGE";
		    /** An upload process has started.  This will be paired with an UPLOADCOMPLETE event */
		    MercuryEventType["UPLOAD_STATUS"] = "UPLOAD_STATUS";
		    /** An upload process has completed. */
		    MercuryEventType["UPLOAD_COMPLETED"] = "UPLOAD_COMPLETED";
		    /** An error has occurred on the connection. */
		    MercuryEventType["CONNECTION_ERROR"] = "CONNECTION_ERROR";
		    /** Connectivity has been temporarily lost. */
		    MercuryEventType["UNSTABLE_CONNECTION"] = "UNSTABLE_CONNECTION";
		    /** Connection has been reestablished. */
		    MercuryEventType["CONNECTION_ESTABLISHED"] = "CONNECTION_ESTABLISHED";
		    /** A change in the participant's role has occurred. */
		    MercuryEventType["ROLE_CHANGE"] = "ROLE_CHANGE";
		    /** A change in the context has occurred. */
		    MercuryEventType["CONTEXT_UPDATE"] = "CONTEXT_UPDATE";
		})(exports.MercuryEventType || (exports.MercuryEventType = {}));
		(function (ErrorReason) {
		    ErrorReason["CONFLICTING_SESSION"] = "CONFLICTING_SESSION";
		    ErrorReason["CONNECTION_ERROR"] = "CONNECTION_ERROR";
		    ErrorReason["UNKNOWN_ERROR"] = "UNKOWN_ERROR";
		    ErrorReason["INCOMPATIBLE_BROWSER"] = "INCOMPATIBLE_BROWSER";
		})(exports.ErrorReason || (exports.ErrorReason = {}));
		(function (AvailabilityType) {
		    /** Present BUT NOT available to receive new work */
		    AvailabilityType["PRESENT"] = "PRESENT";
		    /** Available to receive new work */
		    AvailabilityType["Available"] = "Available";
		    /** Unavailable to receive new work */
		    AvailabilityType["Uavailable"] = "Unavailable";
		    AvailabilityType["AVAILABLE"] = "Available";
		    AvailabilityType["UNAVAILABLE"] = "Unavailable";
		})(exports.AvailabilityType || (exports.AvailabilityType = {}));
		(function (ChannelDestinationType) {
		    /** This is a Resource that can perform actions on the Channel (like an Agent or BOT) */
		    ChannelDestinationType["RESOURCE"] = "RESOURCE";
		    /** This is Queue :-) */
		    ChannelDestinationType["QUEUE"] = "QUEUE";
		})(exports.ChannelDestinationType || (exports.ChannelDestinationType = {}));
		(function (AsyncResponseType) {
		    /** This response is produced when the operation is complete - it can complete immediately */
		    AsyncResponseType["COMPLETE"] = "COMPLETE";
		    /** This response is produced when the operation is in-flight - it needs acceptance */
		    AsyncResponseType["PROCESSING"] = "PROCESSING";
		    /** This response is produced when the resource becomes unavilable */
		    AsyncResponseType["UNAVAILABLE"] = "UNAVAILABLE";
		})(exports.AsyncResponseType || (exports.AsyncResponseType = {}));
		(function (ActivityType) {
		    ActivityType["LISTENING"] = "LISTENING";
		    ActivityType["RESPONDING"] = "RESPONDING";
		})(exports.ActivityType || (exports.ActivityType = {}));
		(function (OfferActionType) {
		    OfferActionType["ACCEPT"] = "ACCEPT";
		    OfferActionType["DECLINE"] = "DECLINE";
		    OfferActionType["NONE"] = "NONE";
		})(exports.OfferActionType || (exports.OfferActionType = {}));
		(function (OfferResponseType) {
		    OfferResponseType["MANUAL"] = "MANUAL";
		    OfferResponseType["AUTO"] = "AUTO";
		    OfferResponseType["FORCED"] = "FORCED";
		})(exports.OfferResponseType || (exports.OfferResponseType = {}));
		(function (WorkOfferBehaviorType) {
		    WorkOfferBehaviorType["Manual"] = "Manual";
		    /** When the offer timeout expires, the offer is considered accepted */
		    WorkOfferBehaviorType["TimedAutoAccept"] = "TimedAutoAccept";
		    /** When the offer timeout expires, the offer is considered rejected */
		    WorkOfferBehaviorType["TimedAutoReject"] = "TimedAutoReject";
		    /** This 'Offer' is really just a notification - the offer has already been accepted */
		    WorkOfferBehaviorType["ForcedAccept"] = "ForcedAccept";
		})(exports.WorkOfferBehaviorType || (exports.WorkOfferBehaviorType = {}));
		(function (ChannelStateType) {
		    /** Queued, awaiting assignment */
		    ChannelStateType["QUEUED"] = "QUEUED";
		    /** Currently active */
		    ChannelStateType["ACTIVE"] = "ACTIVE";
		    /** Concluded but not released */
		    ChannelStateType["CONCLUDED"] = "CONCLUDED";
		    /** Released/ended */
		    ChannelStateType["RELEASED"] = "RELEASED";
		})(exports.ChannelStateType || (exports.ChannelStateType = {}));
		(function (FeedbackItems) {
		    FeedbackItems["SUGGESTION"] = "SUGGESTION";
		    FeedbackItems["SUMMARY"] = "SUMMARY";
		})(exports.FeedbackItems || (exports.FeedbackItems = {}));
		(function (FeedbackActions) {
		    FeedbackActions["ACCEPTED"] = "ACCEPTED";
		    FeedbackActions["MODIFIED"] = "MODIFIED";
		    FeedbackActions["DISMISSED"] = "DISMISSED";
		})(exports.FeedbackActions || (exports.FeedbackActions = {}));
		(function (ConnectionStateType) {
		    /** Un-Contactable */
		    ConnectionStateType["ABSENT"] = "ABSENT";
		    /** Connected and Contactable */
		    ConnectionStateType["ACTIVE"] = "ACTIVE";
		    /** Not connected */
		    ConnectionStateType["DISCONNECTED"] = "DISCONNECTED";
		    /** Unknown state */
		    ConnectionStateType["UNKNOWN"] = "UNKNOWN";
		})(exports.ConnectionStateType || (exports.ConnectionStateType = {}));
		
	} (mcaMercuryCopy));

	var mcaNotificationManager = {};

	var __awaiter$3 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaNotificationManager, "__esModule", { value: true });
	mcaNotificationManager.NotificationManager = void 0;
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	const mcaLogger_1$3 = requireMcaLogger();
	const mca$3 = requireMcaCommonTypes();
	const mca_cache_manager_1 = mcaCacheManager;
	const oj_mca_common_1$4 = requireOjMcaCommon();
	class NotificationManager extends mca_cache_manager_1.CacheManager {
	    constructor() {
	        super(NotificationManager.NAME, new mca$3.NotificationMap(), NotificationManager.desc, NotificationManager.MIN_CACHE_SIZE, NotificationManager.MAX_NOTIFICATIONS, NotificationManager.NOTIFICATION_EXPIRATION);
	        this.pre = '[McaNotificationManager] ';
	        /**
	         * add notification item to Cache for the current session.
	         * @param notification - identifies the notification item to set.
	         *
	         */
	        this.addNotification = (nToBeAdded) => __awaiter$3(this, void 0, void 0, function* () {
	            mcaLogger_1$3.McaLogger.info(this.pre + 'insert new Notification: ');
	            nToBeAdded.windowName = this.localWindowName;
	            const itemToBeAdded = new mca$3.NotificationManagerItem(nToBeAdded);
	            if (!itemToBeAdded) {
	                mcaLogger_1$3.McaLogger.warn(this.pre + 'addNotification: missing notification!');
	                return;
	            }
	            const itemIdToBeAdded = itemToBeAdded.notificationEventId;
	            let map = this.getMap();
	            if (!this.isNotificationAlreadyAdded(map, itemToBeAdded)) {
	                map = yield this.checkOutMap();
	                if (this.isNotificationAlreadyAdded(map, itemToBeAdded)) {
	                    this.undoCheckOut(map);
	                    return;
	                }
	                // were waiting for the checkOut
	                try {
	                    mcaLogger_1$3.McaLogger.info(`${this.pre} storing ${itemIdToBeAdded}:${itemToBeAdded.notificationTitle}, ${itemToBeAdded.notificationCategory}`);
	                    map.put(itemIdToBeAdded, itemToBeAdded);
	                    const delta = new mca$3.NotificationManagerItemChange(itemIdToBeAdded, this.localWindowName, mca$3.DeltaType.data);
	                    map.setDelta(delta);
	                    this.flushCache(map);
	                }
	                catch (err) {
	                    mcaLogger_1$3.McaLogger.warn(this.pre + 'Error addNotification to localStorage: ' + err);
	                }
	                finally {
	                    this.undoCheckOut(map);
	                }
	            }
	            mcaLogger_1$3.McaLogger.info(this.pre + 'end of insert new Notification ');
	        });
	        /**
	         * remove Notification
	         * This must be called to ensure we don't continue to reload the Notification Component in WrapUp Mode
	         * following page refresh.
	         */
	        this.removeNotification = (notificatonItemId) => __awaiter$3(this, void 0, void 0, function* () {
	            mcaLogger_1$3.McaLogger.info(this.pre + 'removeNotification ' + notificatonItemId);
	            const delta = new mca$3.NotificationManagerItemChange(notificatonItemId, this.localWindowName, mca$3.DeltaType.state);
	            const map = yield this.checkOutMap();
	            // Now we are in lock scope ...
	            let writeMap = false;
	            try {
	                const notification = map.get(notificatonItemId);
	                if (!notification) {
	                    mcaLogger_1$3.McaLogger.info(this.pre + 'Notification not found in map for removeNotification: ');
	                }
	                else {
	                    writeMap = true;
	                }
	            }
	            catch (err) {
	                mcaLogger_1$3.McaLogger.error(this.pre + 'removeNotification error ' + err);
	            }
	            if (writeMap) {
	                map.setDelta(delta);
	                map.remove(notificatonItemId);
	                this.flushCache(map);
	            }
	            else {
	                this.undoCheckOut(map);
	            }
	            mcaLogger_1$3.McaLogger.info(this.pre + 'end of remove  Notification ');
	        });
	        /**
	         * Handle events generated from another window.
	         */
	        this.processStorageEvent = (map) => {
	            mcaLogger_1$3.McaLogger.info(this.pre + 'beginning of processStorageEvent ');
	            const delta = (map) ? map.getDelta() : null;
	            if ((!delta && (delta.type !== mca$3.DeltaType.data))) {
	                mcaLogger_1$3.McaLogger.warn(this.pre + 'No NotificationManagerItem found for storageEvent: ' + delta);
	                return;
	            }
	            if (delta.windowName === this.localWindowName) {
	                mcaLogger_1$3.McaLogger.warn(this.pre + 'same window, no need for storageEvent: ' + delta);
	                return;
	            }
	            if (delta.type === mca$3.DeltaType.state) {
	                mcaLogger_1$3.McaLogger.warn(this.pre + 'dispatch event to ui to remove notification ' + delta.notificationItemId + 'for storageEvent');
	                this.dispatchRefreshUiNotifEvent(mca$3.McaEventType.removeNotifOnUi, null, delta.notificationItemId);
	            }
	            else {
	                const notificationItem = (delta && map) ? map.get(delta.notificationItemId) : null;
	                mcaLogger_1$3.McaLogger.warn(this.pre + 'dispatch event to ui to add notification ' + notificationItem.notificationEventId + 'for storageEvent');
	                this.dispatchRefreshUiNotifEvent(mca$3.McaEventType.addNotifOnUi, notificationItem, null);
	            }
	            mcaLogger_1$3.McaLogger.info(this.pre + 'end of processStorageEvent ');
	        };
	        this.unloadListener = () => {
	            if (this.lock) {
	                mcaLogger_1$3.McaLogger.info(this.pre + 'Detected Unload with lock ...' + window.name);
	                const map = this.getMap();
	                this.forceRelease(map);
	            }
	        };
	        this.dispatchRefreshUiNotifEvent = (type, notification, notificationId) => {
	            // dispatch event to oj-mca-notications to refresh ui based on NotificationMap
	            mcaLogger_1$3.McaLogger.log(this.pre + ' dispatchRefreshUiNotifEvent with type : ' + type);
	            let detail;
	            if (type === mca$3.McaEventType.addNotifOnUi) {
	                detail = { item: notification };
	            }
	            else if (type === mca$3.McaEventType.removeNotifOnUi) {
	                detail = { id: notificationId };
	            }
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const eventType = type;
	            const newEvent = new CustomEvent(eventType, formattedEvent);
	            window.dispatchEvent(newEvent);
	        };
	        this.isNotificationAlreadyAdded = (map, itemToBeAdded) => {
	            const itemIdToBeAdded = itemToBeAdded.notificationEventId;
	            const itemInMap = map.get(itemIdToBeAdded);
	            let isAlreadyAdded = false;
	            if (itemInMap) {
	                if (itemInMap.notificationEventId === itemToBeAdded.notificationEventId &&
	                    (itemInMap.notificationTitle === itemToBeAdded.notificationTitle ||
	                        (itemInMap.notificationSubtitle !== undefined && itemToBeAdded.notificationSubtitle === undefined) ||
	                        (!itemInMap.notificationTitle.startsWith('Unknown')))) {
	                    // The specified item is already added. Once contact name is identified, no need to update
	                    isAlreadyAdded = true;
	                }
	            }
	            return isAlreadyAdded;
	        };
	        this.localWindowName = oj_mca_common_1$4.McaCommon.localUuidV4();
	    }
	    static getInstance() {
	        if (!NotificationManager.instance) {
	            NotificationManager.instance = new NotificationManager();
	        }
	        return NotificationManager.instance;
	    }
	    /**
	     * Retrieve the key of currently notifications.
	     */
	    getNotificationKeys() {
	        const map = this.getMap();
	        const keys = map.keys();
	        return keys;
	    }
	    /**
	     * Retrieves the identified notification from the Notification Cache.
	     * @param notificationId - identifies the notification to retrieve. null is returned if no corresponding
	     * notification is found.
	     */
	    getNotification(notificationId) {
	        const map = this.getMap();
	        return map.get(notificationId);
	    }
	}
	mcaNotificationManager.NotificationManager = NotificationManager;
	NotificationManager.NAME = 'oj-mca-notification';
	NotificationManager.MAX_NOTIFICATIONS = 10; // We only maintain up to 10 simultaneous notifications in cache
	NotificationManager.MIN_CACHE_SIZE = 3;
	NotificationManager.NOTIFICATION_EXPIRATION = 1000 * 60 * 60 * 1; // NOTIFICATION Expiration Time - 1 hour
	NotificationManager.desc = 'Notifications';

	var mcaUserEventConfig = {};

	var _a;
	Object.defineProperty(mcaUserEventConfig, "__esModule", { value: true });
	mcaUserEventConfig.McaUserEventConfig = void 0;
	const mca$2 = requireMcaCommonTypes();
	const ToolbarLoadState_1$1 = ToolbarLoadState;
	const oj_mca_common_1$3 = requireOjMcaCommon();
	const mcaLogger_1$2 = requireMcaLogger();
	class McaUserEventConfig {
	    static injectUefProfileOptions(result, uI) {
	        var _b;
	        uI.uefAllowedDomains = result.uefAllowedDomains;
	        uI.uefEnabled = result.advancedMCAClientIntegrationEnabled;
	        if (result.uefAllowedDomains !== '*' && ((_b = result === null || result === void 0 ? void 0 : result.toolbarInfo) === null || _b === void 0 ? void 0 : _b.url)) {
	            const hostUrlObj = new URL(result.toolbarInfo.url);
	            uI.uefAllowedDomains = result.uefAllowedDomains + ` ${hostUrlObj.protocol}${hostUrlObj.hostname}`;
	            result.uefAllowedDomains = uI.uefAllowedDomains;
	        }
	    }
	}
	mcaUserEventConfig.McaUserEventConfig = McaUserEventConfig;
	_a = McaUserEventConfig;
	McaUserEventConfig.pre = '[McaUserEventConfig] ';
	McaUserEventConfig.parseUserEventConfiguration = (result) => {
	    const info = {};
	    let tI = {};
	    let mI = {};
	    let rI = {};
	    let uI = {};
	    if (result && typeof result === 'string') {
	        mcaLogger_1$2.McaLogger.info(_a.pre + 'parseUserEventConfiguration - fetchUserEventConfiguration REST response: ' + result);
	        result = JSON.parse(result);
	    }
	    tI = _a.getToolbarInfo(result);
	    mI = _a.getMercuryInfo(result);
	    rI = _a.getRoutableVONames(result);
	    uI = _a.getUserDetails(result);
	    if (tI && tI.devMode === true && !uI.agentId) {
	        // so we can test in dev mode when rest isn't working
	        const userDetails = {
	            NLS_LANG: 'en',
	            NLS_LOCALE: 'us',
	            agentId: 'MCADEV',
	            agentPartyId: 456,
	            appName: mca$2.AppName.mca,
	            debugMode: 'Y',
	            faTrustToken: 'FAKE',
	            features: null,
	            profileOmniDesktopNotification: true
	        };
	        uI = userDetails;
	    }
	    info.toolbarInfo = tI;
	    info.mercuryInfo = mI;
	    info.routableVOInfo = rI;
	    info.userDetails = uI;
	    return info;
	};
	McaUserEventConfig.getToolbarInfo = (result) => {
	    const myFunc = 'getToolbarInfo: ';
	    const info = {};
	    let toolbarLocation;
	    try {
	        if (result && result.toolbarInfo) {
	            // toolbarInfo
	            if (result.toolbarInfo.name) {
	                info.name = result.toolbarInfo.name;
	            }
	            if (result.toolbarInfo.displayName) {
	                info.displayName = result.toolbarInfo.displayName;
	            }
	            if (result.toolbarInfo.orientation && result.toolbarInfo.url) {
	                info.orientation = result.toolbarInfo.orientation;
	            }
	            if (result.toolbarInfo.activeFlag) {
	                info.activeFlag = result.toolbarInfo.activeFlag;
	            }
	            if (result.toolbarInfo.url) {
	                info.url = result.toolbarInfo.url;
	            }
	            if (result.toolbarInfo.toolbarId) {
	                info.toolbarId = result.toolbarInfo.toolbarId;
	            }
	            if (result.toolbarInfo.profile_SVC_OVERRIDE_PARTNER_TOOLBAR_SELECTION) {
	                info.profile_SVC_OVERRIDE_PARTNER_TOOLBAR_SELECTION = result.toolbarInfo.profile_SVC_OVERRIDE_PARTNER_TOOLBAR_SELECTION;
	            }
	            if (result.toolbarInfo.urlValidDomainName) {
	                info.urlValidDomainName = result.toolbarInfo.urlValidDomainName;
	            }
	            if (result.toolbarInfo.chatSupportedFlag) {
	                info.isChatSupported = oj_mca_common_1$3.McaCommon.getBoolean(result.toolbarInfo.chatSupportedFlag);
	            }
	            if (result.toolbarInfo.phoneSupportedFlag) {
	                info.isPhoneSupported = oj_mca_common_1$3.McaCommon.getBoolean(result.toolbarInfo.phoneSupportedFlag);
	            }
	            if (result.toolbarInfo.nrtWorkSupportedFlag) {
	                info.isNrtWorkSupported = oj_mca_common_1$3.McaCommon.getBoolean(result.toolbarInfo.nrtWorkSupportedFlag);
	            }
	            let tempLoadState = null;
	            if (info.url) {
	                let tbUrl;
	                try {
	                    const urlString = info.url.trim();
	                    tbUrl = new URL(urlString);
	                }
	                catch (err) {
	                    tempLoadState = ToolbarLoadState_1$1.ToolbarLoadState.invalidUrl;
	                    mcaLogger_1$2.McaLogger.warn(_a.pre + myFunc + 'Invalid Toolbar Configuration ,' + info.displayName + ', Invalid URL: ' + info.url, err);
	                }
	                if (tbUrl.origin) {
	                    if (info.orientation !== mca$2.ToolbarLayout.redwood) {
	                        tempLoadState = ToolbarLoadState_1$1.ToolbarLoadState.invalidConfigured;
	                        mcaLogger_1$2.McaLogger.warn(_a.pre + myFunc + 'Invalid Toolbar Configuration ,' + info.displayName + ', VBCS Apps require a Redwood Layout');
	                    }
	                    else if (window.location.protocol === 'https:') {
	                        if (info.url.startsWith('https')) {
	                            mcaLogger_1$2.McaLogger.info(_a.pre + myFunc + 'Using Toolbar Configuration from DB: ' + info.url);
	                            tbUrl = new URL(info.url);
	                            toolbarLocation = info.url;
	                        }
	                        else {
	                            tempLoadState = ToolbarLoadState_1$1.ToolbarLoadState.invalidUrl;
	                            mcaLogger_1$2.McaLogger.warn(_a.pre + myFunc + 'Invalid Toolbar Configuration ,' + info.displayName + ', Wrong Protocol-expected an HTTPS Toolbar');
	                        }
	                    }
	                    else if (window.location.protocol === 'http:') {
	                        // This is the test app case, we accept all variants
	                        // if (info.url.startsWith('http:')) {
	                        mcaLogger_1$2.McaLogger.info(_a.pre + myFunc + 'Using Toolbar Configuration from DB: ' + info.url);
	                        toolbarLocation = info.url;
	                        // } else {
	                        //   tempLoadState = mca.ToolbarLoadState.invalidUrl;
	                        //   McaLogger.warn(this.pre + myFunc + 'Invalid Toolbar Configuration ,' + info.displayName + ', Wrong Protocol, expected an HTTP Toolbar');
	                        // }
	                    }
	                }
	            }
	            else {
	                tempLoadState = info.loadState;
	                mcaLogger_1$2.McaLogger.warn(_a.pre + myFunc + 'Unable to load Toolbar Configuration from DB');
	            }
	            info.url = toolbarLocation;
	            // moved to main handleRestResponse
	            // if (info.orientation === mca.ToolbarLayout.redwood && info.url && info.url.toLowerCase().startsWith('http')) {
	            //   this.toolbarEnabled(true);
	            // }
	        }
	        else if (result && result.failReason) {
	            if (info.loadState) {
	                info.loadState = result.failReason;
	            }
	        }
	        else {
	            mcaLogger_1$2.McaLogger.info(_a.pre + myFunc + 'No Toolbar Configured for current User');
	            info.loadState = ToolbarLoadState_1$1.ToolbarLoadState.notConfigured;
	        }
	    }
	    catch (err) {
	        if (info) {
	            info.loadState = ToolbarLoadState_1$1.ToolbarLoadState.restFailed;
	        }
	    }
	    // moved to main handleRestResponse
	    // if (!toolbarLocation) {
	    //   info = this.getDevToolbarSettings();
	    //   if (info) {
	    //     this.toolbarEnabled(true);
	    //   }
	    // }
	    return info;
	};
	McaUserEventConfig.getMercuryInfo = (result) => {
	    let mI = {};
	    mI = _a.preProcessChatResponse(result);
	    try {
	        if (result && result.mercuryInfo) {
	            mI.mercuryBaseUrl = null;
	            if (result.mercuryInfo.chatEnabled) {
	                mI.chatEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.chatEnabled);
	            }
	            if (result.mercuryInfo.profileOmniBrowserNotification) {
	                mI.omniBrowserNotificationEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.profileOmniBrowserNotification);
	            }
	            if (result.mercuryInfo.profileOmniBrowserNotificationAutoInt) {
	                mI.omniBrowserNotificationAutoInt = result.mercuryInfo.profileOmniBrowserNotificationAutoInt;
	                if (isNaN(mI.omniBrowserNotificationAutoInt)) {
	                    mcaLogger_1$2.McaLogger.warn(`${_a.pre} profileOmniBrowserNotificationAutoInt is not a valid number: ${result.mercuryInfo.profileOmniBrowserNotificationAutoInt} assuming 300 seconds`);
	                    mI.omniBrowserNotificationAutoInt = '300';
	                }
	                mI.profileChatOfferTimeout = mI.omniBrowserNotificationAutoInt; // TODO temp until Bug 34864014 is fixed 
	            }
	            if (result.mercuryInfo.profileChatOfferTimeout) {
	                mI.profileChatOfferTimeout = result.mercuryInfo.profileChatOfferTimeout;
	                if (isNaN(mI.profileChatOfferTimeout)) {
	                    mcaLogger_1$2.McaLogger.warn(`${_a.pre} profileChatOfferTimeout is not a valid number: ${result.mercuryInfo.profileChatOfferTimeout} assuming 30 seconds`);
	                    mI.profileChatOfferTimeout = '30';
	                }
	            }
	            if (result.mercuryInfo.profileOmniDesktopNotification) {
	                mI.omniDesktopNotificationEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.profileOmniDesktopNotification);
	            }
	            if (result.mercuryInfo.profileOmniNotificationMultiAggrThreshold) {
	                mI.omniNotificationMutliAggrThreshold = result.mercuryInfo.profileOmniNotificationMultiAggrThreshold;
	            }
	            if (result.mercuryInfo.lxMercuryIntegrationEnabled) {
	                mI.mercuryLXIntegrationEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.lxMercuryIntegrationEnabled);
	            }
	            if (result.mercuryInfo.lxClientTopoConfig) {
	                try {
	                    mI.mercuryLXTopologyConfig = JSON.parse(result.mercuryInfo.lxClientTopoConfig);
	                }
	                catch (errLXTopo) {
	                    mcaLogger_1$2.McaLogger.warn(`${_a.pre} Error in getMercuryInfo while parsing lxClientTopoConfig - mercuryLXIntegrationEnabled set to FALSE - error: ${errLXTopo}`);
	                    mI.mercuryLXIntegrationEnabled = false;
	                }
	            }
	            if (result.mercuryInfo.chatServerEndPoint) {
	                mI.chatServerEndPoint = result.mercuryInfo.chatServerEndPoint;
	            }
	            if (result.mercuryInfo.chatServerPool) {
	                mI.chatServerPool = result.mercuryInfo.chatServerPool;
	            }
	            if (result.mercuryInfo.chatServerClientToken) {
	                mI.chatServerClientToken = result.mercuryInfo.chatServerClientToken;
	            }
	            if (result.mercuryInfo.chatServerAccountId) {
	                mI.chatServerAccountId = result.mercuryInfo.chatServerAccountId;
	            }
	            if (result.mercuryInfo.chatServerConsoleSessionId) {
	                mI.chatServerConsoleSessionId = result.mercuryInfo.chatServerConsoleSessionId;
	            }
	            if (result.mercuryInfo.chatServerProfileId) {
	                mI.chatServerProfileId = result.mercuryInfo.chatServerProfileId;
	            }
	            mI.srRoutingEnabled = false;
	            if (result.mercuryInfo.srRoutingEnabled) {
	                mI.srRoutingEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.srRoutingEnabled);
	            }
	            if (typeof mI.transferEnabled === 'undefined') {
	                mI.transferEnabled = true;
	                if (result.mercuryInfo.chatTransferEnabled) {
	                    mI.transferEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.chatTransferEnabled);
	                }
	            }
	            if (typeof mI.chatTransferToAgentEnabled === 'undefined') {
	                mI.chatTransferToAgentEnabled = true;
	                if (result.mercuryInfo.chatTransferToAgentEnabled) {
	                    mI.chatTransferToAgentEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.chatTransferToAgentEnabled);
	                }
	            }
	            if (typeof mI.conferenceEnabled === 'undefined') {
	                mI.conferenceEnabled = true;
	                if (result.mercuryInfo.chatConferenceEnabled) {
	                    mI.conferenceEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.chatConferenceEnabled);
	                }
	            }
	            if (typeof mI.chatServerQueues === 'undefined') {
	                if (result.mercuryInfo.chatQueues) {
	                    try {
	                        mI.chatServerQueues = JSON.parse(result.mercuryInfo.chatQueues);
	                    }
	                    catch (queueErr) {
	                        mcaLogger_1$2.McaLogger.error(`${_a.pre} Error while try to parse chat queues - ${queueErr}`);
	                    }
	                }
	            }
	            if (result.mercuryInfo.generativeSummaryForWrapup) {
	                mI.generativeSummaryForWrapupEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.generativeSummaryForWrapup);
	            }
	            if (result.mercuryInfo.generativeSummaryForTransferOrConference) {
	                mI.generativeSummaryForTransferOrConferenceEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.mercuryInfo.generativeSummaryForTransferOrConference);
	            }
	            if (result.mercuryInfo.profileOmniDisableAvailSelect) {
	                mI.profileOmniDisableAvailSelect = result.mercuryInfo.profileOmniDisableAvailSelect;
	                // <TODO> Uncomment following line to test Omni Disable Select Availability
	                // mI.profileOmniDisableAvailSelect = 'ALL'; //NONE, CHAT, NON_REAL_TIME_WORK
	            }
	            else {
	                mI.profileOmniDisableAvailSelect = mca$2.OmniProfileOptionValues.none;
	            }
	            if (result.mercuryInfo.profileOmniReinstateAvail) {
	                mI.profileOmniReinstateAvail = result.mercuryInfo.profileOmniReinstateAvail;
	            }
	            else {
	                mI.profileOmniReinstateAvail = mca$2.OmniProfileOptionValues.none;
	            }
	            if (typeof mI.maxSessions === 'undefined') {
	                if (typeof result.mercuryInfo.maxSessions !== 'undefined') {
	                    mI.maxSessions = result.mercuryInfo.maxSessions;
	                }
	            }
	            if (typeof mI.maxActiveSessions === 'undefined') {
	                if (typeof result.mercuryInfo.maxActiveSessions !== 'undefined') {
	                    mI.maxActiveSessions = result.mercuryInfo.maxActiveSessions;
	                }
	            }
	            if (result.mercuryInfo.autoAssignEnabled) {
	                mI.autoAssignEnabled = (result.mercuryInfo.autoAssignEnabled === 'Y');
	            }
	            if (result.mercuryInfo.forceAssignNotificationTimeout) {
	                const forceAssignNotificationTimeout = result.mercuryInfo.forceAssignNotificationTimeout;
	                if (isNaN(forceAssignNotificationTimeout)) {
	                    mcaLogger_1$2.McaLogger.warn(`${_a.pre} forceAssignNotificationTimeout is not a valid number: ${result.mercuryInfo.forceAssignNotificationTimeout} resetting to 0`);
	                    mI.forceAssignNotificationTimeout = 0;
	                }
	                else {
	                    mI.forceAssignNotificationTimeout = Number(forceAssignNotificationTimeout);
	                }
	            }
	            if (result.mercuryInfo.forceAssignForTransferAndConferenceEnabled) {
	                mI.forceAssignForTransferAndConferenceEnabled = (result.mercuryInfo.forceAssignForTransferAndConferenceEnabled === 'Y');
	            }
	            if (result.mercuryInfo.engageConfig) {
	                mI.engageConfig = result.mercuryInfo.engageConfig;
	            }
	        }
	        else if (result && result.failReason) {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'result.failReason is ' + result.failReason);
	        }
	        else {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'error in getMercuryInfo');
	        }
	    }
	    catch (err) {
	        mcaLogger_1$2.McaLogger.info(_a.pre + 'catch error in getMercuryInfo');
	    }
	    // moved to main handleRestResponse
	    // const info: mca.MercuryInfo = this.getDevMercurySettings();
	    // if (info) {
	    //   // override mercury info for demo / dev purpose
	    //   mI = info;
	    // }
	    return mI;
	};
	/**
	 * Pre-extract Chat Configurations from the debugChatConfig.
	 * @param result
	 * @returns  Semi-Populated mercuryInfo
	 */
	McaUserEventConfig.preProcessChatResponse = (result) => {
	    var _b, _c, _d;
	    const responseInfo = {};
	    if (!result || !result.mercuryInfo || !result.debugChatConfig || !result.debugChatConfig.getChat_11_getChatRetrieveValue) {
	        return responseInfo;
	    }
	    const inputInfo = result.mercuryInfo;
	    try {
	        const debugConfig = JSON.parse(result.debugChatConfig.getChat_11_getChatRetrieveValue);
	        if (debugConfig.errorCode) {
	            throw debugConfig;
	        }
	        const chatConfig = (_b = debugConfig.config) === null || _b === void 0 ? void 0 : _b.chatconfig;
	        if (chatConfig) {
	            if (!inputInfo.chatServerEndPoint) {
	                if (chatConfig.chatUrl) {
	                    responseInfo.chatServerEndPoint = chatConfig.chatUrl;
	                }
	                if (chatConfig.chatPool) {
	                    responseInfo.chatServerPool = chatConfig.chatPool;
	                }
	                if (debugConfig.config && debugConfig.config.loginData) {
	                    if (debugConfig.config.loginData.jwt) {
	                        responseInfo.chatServerClientToken = debugConfig.config.loginData.jwt;
	                    }
	                    if (debugConfig.config.loginData.accountId) {
	                        responseInfo.chatServerAccountId = '' + debugConfig.config.loginData.accountId;
	                    }
	                    if (debugConfig.config.loginData.consoleSessionId) {
	                        responseInfo.chatServerConsoleSessionId = '' + debugConfig.config.loginData.consoleSessionId;
	                    }
	                    if (debugConfig.config.loginData.profileId) {
	                        responseInfo.chatServerProfileId = '' + debugConfig.config.loginData.profileId;
	                    }
	                }
	            }
	            if (chatConfig.queues) {
	                responseInfo.chatServerQueues = chatConfig.queues;
	            }
	            if (typeof chatConfig.transferEnabled !== undefined) {
	                responseInfo.transferEnabled = chatConfig.transferEnabled;
	            }
	            if (typeof chatConfig.conferenceEnabled !== undefined) {
	                responseInfo.conferenceEnabled = chatConfig.conferenceEnabled;
	            }
	            if (typeof chatConfig.transferToAgentEnabled !== undefined) {
	                responseInfo.chatTransferToAgentEnabled = chatConfig.transferToAgentEnabled;
	            }
	            if (typeof ((_c = chatConfig.profile) === null || _c === void 0 ? void 0 : _c.maxSessions) !== undefined) {
	                responseInfo.maxSessions = chatConfig.profile.maxSessions;
	            }
	            if (typeof ((_d = chatConfig.profile) === null || _d === void 0 ? void 0 : _d.maxActiveSessions) !== undefined) {
	                responseInfo.maxActiveSessions = chatConfig.profile.maxActiveSessions;
	            }
	            // TODO Add additional chatConfig properties here
	        }
	    }
	    catch (err) {
	        mcaLogger_1$2.McaLogger.error(`${_a.pre}: Error in preProcessChatResponse ${JSON.stringify(err)}`);
	    }
	    return responseInfo;
	};
	McaUserEventConfig.getRoutableVONames = (result) => {
	    let rI = {};
	    try {
	        if (result && result.routableVONames) {
	            rI = result.routableVONames;
	        }
	        else if (result && result.failReason) {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'result.failReason is ' + result.failReason);
	        }
	        else {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'error in getRoutableVONames');
	        }
	    }
	    catch (err) {
	        mcaLogger_1$2.McaLogger.info(_a.pre + 'catch error in getRoutableVONames');
	    }
	    return rI;
	};
	McaUserEventConfig.getUserDetails = (result) => {
	    var _b;
	    const uI = {};
	    try {
	        if (result) {
	            if (result.debugMode) {
	                uI.debugMode = result.debugMode;
	            }
	            else {
	                mcaLogger_1$2.McaLogger.warn(_a.pre + ' missing debugMode ');
	            }
	            if (result.faTrustToken) {
	                uI.faTrustToken = result.faTrustToken;
	            }
	            else {
	                mcaLogger_1$2.McaLogger.warn(_a.pre + ' missing faTrustToken ');
	            }
	            if (result.agentId) {
	                uI.agentId = result.agentId;
	            }
	            else {
	                mcaLogger_1$2.McaLogger.warn(_a.pre + ' missing agentId: ' + result.agentId);
	            }
	            if (result.agentPartyId) {
	                uI.agentPartyId = result.agentPartyId;
	            }
	            if (result.profileMcaDisableJwt) {
	                uI.profileMcaDisableJwt = oj_mca_common_1$3.McaCommon.getBoolean(result.profileMcaDisableJwt);
	            }
	            if (result.features) {
	                uI.features = result.features;
	            }
	            else {
	                uI.features = '["INBOUND_CALL","OUTBOUND_CALL","TRANSFER_CALL","CONFERENCE_CALL","OUTBOUND_CALL_EXTENSIONS"]';
	            }
	            if (result.NLS_LANG) {
	                uI.NLS_LANG = result.NLS_LANG;
	            }
	            if (result.NLS_LOCALE) {
	                uI.NLS_LOCALE = result.NLS_LOCALE;
	            }
	            if (result.AGENT_CONFIG_DATA) {
	                uI.AGENT_CONFIG_DATA = result.AGENT_CONFIG_DATA;
	            }
	            if (result.profileOmniDesktopNotification) {
	                const webNotificationsEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.profileOmniDesktopNotification);
	                uI.profileOmniDesktopNotification = webNotificationsEnabled;
	            }
	            if (result.msiEnabled) {
	                uI.msiEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.msiEnabled);
	                oj_mca_common_1$3.McaCommon.setMsiEnabled(uI.msiEnabled);
	            }
	            if (result.snippetsEnabled) {
	                uI.snippetsEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.snippetsEnabled);
	            }
	            uI.generativeAIEnabled = oj_mca_common_1$3.McaCommon.getBoolean(result.generativeAIEnabled);
	            uI.defaultBuOrgId = (_b = result.defaultBuOrgId) !== null && _b !== void 0 ? _b : parseInt(sessionStorage.getItem('defaultbu') || '0', 10);
	            _a.injectUefProfileOptions(result, uI);
	            // Temp for MSI POC
	            try {
	                const msiEnabledString = localStorage.getItem(mca$2.Constants.DEMO_ENABLE_MSI);
	                if (msiEnabledString === 'Y') {
	                    uI.msiEnabled = oj_mca_common_1$3.McaCommon.getBoolean(msiEnabledString);
	                    oj_mca_common_1$3.McaCommon.setMsiEnabled(uI.msiEnabled);
	                }
	                else if (msiEnabledString === 'N') {
	                    uI.msiEnabled = oj_mca_common_1$3.McaCommon.getBoolean(msiEnabledString);
	                    oj_mca_common_1$3.McaCommon.setMsiEnabled(uI.msiEnabled);
	                }
	            }
	            catch (errMsi) { }
	        }
	        else if (result && result.failReason) {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'result.failReason is ' + result.failReason);
	        }
	        else {
	            mcaLogger_1$2.McaLogger.info(_a.pre + 'error in getUserDetails');
	        }
	        // moved to main handleRestResponse
	        // if (this.user()) {
	        //   uI.permissions = this.user().permissions;
	        // }
	        // uI.appName = this.appName();
	    }
	    catch (err) {
	        mcaLogger_1$2.McaLogger.error(_a.pre + 'catch error in getUserDetails', err);
	    }
	    return uI;
	};

	var ojMcaMercury = {};

	var __awaiter$2 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(ojMcaMercury, "__esModule", { value: true });
	ojMcaMercury.McaMercuryModel = void 0;
	const ko$2 = knockoutLatestExports;
	const mcaLogger_1$1 = requireMcaLogger();
	const mca$1 = requireMcaCommonTypes();
	const mca_engagement_manager_1$2 = mcaEngagementManager;
	const mca_mercury_copy_1$2 = mcaMercuryCopy;
	const mca_rest_helper_1$1 = mcaRestHelper;
	const mca_window_manager_1$2 = mcaWindowManager;
	const oj_mca_common_1$2 = requireOjMcaCommon();
	const oj$1 = require$$8;
	const mercury$1 = require$$9;
	var OSvCAvailableStates$1;
	(function (OSvCAvailableStates) {
	    OSvCAvailableStates[OSvCAvailableStates["AVAILABLE"] = 21] = "AVAILABLE";
	    OSvCAvailableStates[OSvCAvailableStates["IN_MEETING"] = 23] = "IN_MEETING";
	    OSvCAvailableStates[OSvCAvailableStates["ON_BREAK"] = 24] = "ON_BREAK";
	    OSvCAvailableStates[OSvCAvailableStates["UNAVAILABLE"] = 22] = "UNAVAILABLE";
	})(OSvCAvailableStates$1 || (OSvCAvailableStates$1 = {}));
	class McaMercuryModel {
	    constructor(properties) {
	        this.mercuryVersion = '1.0.0';
	        this.pre = '[McaMercury] ';
	        this.pendingOffersMap = new Map();
	        this.activeChannelsMap = new Map();
	        this.commandQueue = new Array(); // Queue commands until Mercury Session Established
	        this.mercuryOrigin = '';
	        this.mcaBundle = null;
	        this.chatConfigCache = null;
	        this.chatConfigData = ko$2.observable();
	        this.chatConfigQueue = new Array(); // Queue config requests until the configs are retrieved
	        this.allowMcaChatAccess = ko$2.observable(false);
	        this.allowMcaAudioAccess = ko$2.observable(false);
	        this.allowMcaVideoAccess = ko$2.observable(false);
	        this.allowMcaRecordingAccess = ko$2.observable(false);
	        this.propertyChanged = (context) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} propertyChanged ${context.property} :  ${context.value}`);
	            if (!context.property) {
	                return;
	            }
	            switch (context.property) {
	                case 'userConfigurations':
	                    this.setUserConfigurations(context.value);
	                    break;
	                case 'loadStatus':
	                    let loadStatus = context.value;
	                    if (typeof context.value !== 'function') {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} converting invalid property type for loadStatus`);
	                        loadStatus = ko$2.observable(context.value);
	                    }
	                    this.loadStatus = loadStatus;
	                    this.loadStatus.subscribe(this.loadStatusListener);
	                    break; // writeback property sent to consumer
	                default:
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} Unhandled propertyChanged ${context.property} : ${context.value}`);
	                    break;
	            }
	        };
	        this.getBreakReasons = () => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ===> getBreakReasons `);
	            const retPromise = new Promise((resolve, reject) => {
	                // TODO Need to enhance MCA API in future release
	                resolve([]);
	            });
	            return retPromise;
	        };
	        /**
	         * Async Method to retrieve all the Mercury Work Types Configured for the Current User.
	         * Originally these were only Real-Time Communication Channels but, now the mca.Channels has been
	         * expanded to include Non-Real-Time Work Types that may not have a particular Channel association.
	         * This requires a connection to Mercury in order to retrieve the Mercury Work types configured for the current user.
	         * If this invoked before the Mercury connection is established, this will wait until the Mercury connection is established
	         * or fails.
	         * @returns Promise of Array of Mercury Work Types
	         */
	        this.getChannels = () => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ===> getChannels `);
	            const retPromise = new Promise((resolve, reject) => __awaiter$2(this, void 0, void 0, function* () {
	                if (!this.supportedChannels) {
	                    const channels = new Array(0);
	                    let ftt = true;
	                    while (!this.supportedChannels) {
	                        if (this.session) {
	                            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                const channel = new mca$1.Channel(mca$1.ChannelType.chat, // channelType
	                                mca$1.EventSource.mercury, // source
	                                'Chat', // workType - ?? mca.Constants.CHAT
	                                this.getMcaBundleString('chat'), // displayName,
	                                null, // displayNamePlural 
	                                mca$1.Constants.CHAT, // channel
	                                null // networkType
	                                );
	                                channels.push(channel);
	                            }
	                            this.supportedChannels = channels;
	                        }
	                        else if (this.loadStatus() === mca$1.EventState.loaded) {
	                            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                const channel = new mca$1.Channel(mca$1.ChannelType.chat, // channelType
	                                mca$1.EventSource.mercury, // source
	                                'Chat', // workType - ?? mca.Constants.CHAT
	                                this.getMcaBundleString('chat'), // displayName,
	                                null, // displayNamePlural 
	                                mca$1.Constants.CHAT, // channel
	                                null // networkType
	                                );
	                                channels.push(channel);
	                            }
	                            this.supportedChannels = channels;
	                        }
	                        else if (this.loadStatus() === mca$1.EventState.fail) {
	                            mcaLogger_1$1.McaLogger.error(`${this.pre} Mercury Connection Failed: Not Returning Any Mercury Channels`);
	                            break;
	                        }
	                        else {
	                            if (ftt) {
	                                mcaLogger_1$1.McaLogger.info(`${this.pre} Waiting on Mercury Connection to retrieve valid Channels ...`);
	                                ftt = false;
	                            }
	                            yield oj_mca_common_1$2.McaCommon.sleep(250);
	                        }
	                    }
	                    const channelCount = (this.supportedChannels) ? this.supportedChannels.length : 0;
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} Returning ${channelCount} Mercury Channels`);
	                    resolve(this.supportedChannels);
	                }
	                else {
	                    resolve(this.supportedChannels);
	                }
	            }));
	            return retPromise;
	        };
	        /**
	         * Async method to retrieve the Map of Mercury Work Types to Agent's Availability Status from Mercury.
	         * This waits until the Mercury Session has been established or fails since, we don't even know the
	         * Mercury Work Types until the Agent
	         * @returns Promise of Map containing Mercury Work Types to mca.AgentStates - The mca.AgentStates should contain the necessary detail for UI presentation.
	         */
	        this.getAgentStates = () => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ===> getAgentStates`);
	            const retPromise = new Promise((resolve, reject) => __awaiter$2(this, void 0, void 0, function* () {
	                if (this.session) {
	                    // Refresh the latest states from Mercury
	                    this.agentStateMap = this.getAvailableStatesFromMercury();
	                }
	                else {
	                    if (!this.agentStateMap) {
	                        let ftt = true;
	                        while (!this.agentStateMap) {
	                            if (this.session) {
	                                this.agentStateMap = this.getAvailableStatesFromMercury();
	                                break;
	                            }
	                            else if (this.loadStatus() === mca$1.EventState.loaded) {
	                                this.agentStateMap = new Map();
	                                if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                    const agentState = {
	                                        channel: mca$1.Constants.CHAT,
	                                        channelType: mca$1.ChannelType.chat,
	                                        displayName: this.getMcaBundleString('chat'),
	                                        isAvailable: false,
	                                        isLoggedIn: false,
	                                        workType: mca$1.Constants.CHAT
	                                    };
	                                    mcaLogger_1$1.McaLogger.info(`${this.pre} getAgentStates - status: loaded, WorkType: ${mca$1.Constants.CHAT}, isAvailable: false`);
	                                    this.agentStateMap.set(mca$1.Constants.CHAT, agentState);
	                                }
	                            }
	                            else if (this.loadStatus() === mca$1.EventState.fail) {
	                                mcaLogger_1$1.McaLogger.error(`${this.pre} Mercury Connection Failed: Not Returning Any Mercury Channels`);
	                                this.agentStateMap = new Map();
	                                break;
	                            }
	                            else {
	                                if (ftt) {
	                                    mcaLogger_1$1.McaLogger.info(`${this.pre} Waiting on Mercury Connection to retrieve valid Channels ...`);
	                                    ftt = false;
	                                }
	                                yield oj_mca_common_1$2.McaCommon.sleep(250);
	                            }
	                        }
	                    }
	                }
	                const channelCount = (this.agentStateMap) ? this.agentStateMap.size : 0;
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Returning ${channelCount} Mercury Channels`);
	                resolve(this.agentStateMap);
	            }));
	            return retPromise;
	        };
	        /**
	         * Invoke a Command on Mercury.
	         * Command Responses are returned via the {@linkcode mca.Command} responseCallback
	         */
	        this.invokeCommand = (command) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ===> invokeCommand: ${command}`);
	            if (!command || !command.method) {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Ignoring command, missing method`);
	                return;
	            }
	            if (command.target && !this.checkTarget(command.target)) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Ignoring command for target: ${command.target}`);
	                return;
	            }
	            if (command.channelType && !this.checkChannel(command.channelType)) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Ignoring command, not supported by this provider: ${command.channelType}`);
	                return;
	            }
	            const outData = {};
	            const eventId = command.eventId ? command.eventId : null;
	            const commandResp = new mca$1.CommandResponse(command.command, mca$1.Result.success, command.commandId, eventId, outData, command.channelType, null, command.workType);
	            if (this.loadStatus() === mca$1.EventState.fail) {
	                if (command.responseCallback != undefined) {
	                    commandResp.result = mca$1.Result.error;
	                    outData[mca$1.Constants.ERR_MSG] = 'CONNECT_FAILED';
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} loadstatus is failed. Error message show connect failed`);
	                    // command.responseCallback = (a: mca.CommandResponse) => {a = commandResp; };
	                    command.responseCallback(commandResp);
	                }
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Ignoring command, Mercury Connection Failed: ${command}`);
	                return;
	            }
	            else if (this.loadStatus() !== mca$1.EventState.complete) {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Mercury not connected`);
	                this.invokeCommandAsync(command);
	                return;
	            }
	            let responseRequired = false;
	            switch (command.command) {
	                case mca$1.AgentCommandName.makeAvailable:
	                case mca$1.AgentCommandName.makeUnavailable:
	                    this.setAvailability(command);
	                    break;
	                case mca$1.AgentCommandName.getChannelPrefs:
	                    if (this.chatConfigData()) {
	                        outData[mca$1.CommandResponseKeys.channelPrefs] = this.chatConfigData();
	                        responseRequired = true;
	                    }
	                    else {
	                        this.chatConfigQueue.push(command);
	                        return;
	                    }
	                    break;
	                case mca$1.AgentCommandName.getVideoConfig:
	                    if (this.userConfigurations.mercuryInfo.mercuryLXIntegrationEnabled) {
	                        outData[mca$1.CommandResponseKeys.lxVideoConfig] = {
	                            integrationEnabled: true,
	                            topologyConfig: this.userConfigurations.mercuryInfo.mercuryLXTopologyConfig
	                        };
	                        responseRequired = true;
	                    }
	                    else {
	                        outData[mca$1.CommandResponseKeys.lxVideoConfig] = {
	                            integrationEnabled: false,
	                            topologyConfig: {}
	                        };
	                        responseRequired = true;
	                    }
	                    break;
	                case mca$1.InteractionCommandName.accept:
	                    this.acceptOffer(command);
	                    break;
	                case mca$1.InteractionCommandName.autoAccept:
	                    this.acceptOffer(command, mca_mercury_copy_1$2.OfferResponseType.AUTO);
	                    break;
	                case mca$1.InteractionCommandName.forceAccept:
	                    this.acceptOffer(command, mca_mercury_copy_1$2.OfferResponseType.FORCED);
	                    break;
	                case mca$1.InteractionCommandName.reject:
	                    this.rejectOffer(command);
	                    break;
	                case mca$1.InteractionCommandName.chatOfferTimeout:
	                    const offer = this.pendingOffersMap.get(command.eventId);
	                    if (offer != null) {
	                        try {
	                            this.session.timeoutOffer(offer).then(() => {
	                                this.disconnectWithReasonCode(command, mca$1.CloseCommReason.timeout);
	                            }).catch(() => {
	                                this.disconnectWithReasonCode(command, mca$1.CloseCommReason.timeout);
	                            });
	                        }
	                        catch (e) {
	                            mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in timeout offer ${e}`);
	                            this.disconnectWithReasonCode(command, mca$1.CloseCommReason.timeout);
	                        }
	                        this.cleanupOffer(offer.identifier);
	                    }
	                    break;
	                case mca$1.InteractionCommandName.disconnect:
	                    this.concludeEngagement(command);
	                    // this.closeEngagement(command);
	                    break;
	                case mca$1.InteractionCommandName.transferToQueue:
	                    // Nothing to be done here
	                    this.transferedEngagement(command);
	                    break;
	                case mca$1.InteractionCommandName.wrapupComplete:
	                    // 9-16-21 Once again Closing chat since this is no longer done by Chat UI
	                    this.closeEngagement(command);
	                    break;
	                case mca$1.InteractionCommandName.getCommunicationChannel:
	                    const mercuryChannel = this.getChannel(command.eventId);
	                    if (!mercuryChannel) {
	                        commandResp.result = mca$1.Result.error;
	                        outData[mca$1.Constants.ERR_MSG] = 'Channel Not found: ' + command.eventId;
	                        mcaLogger_1$1.McaLogger.error(`${this.pre} Mercury Channel Not Found for command ${command}`);
	                    }
	                    else {
	                        commandResp.realTimeCommChannel = mercuryChannel;
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* Returning Mercury Channel for command: ${command}`);
	                    }
	                    responseRequired = true;
	                    break;
	                default:
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} No Command Handler Defined for Command ${command}`);
	                    break;
	            }
	            if (responseRequired && command.responseCallback !== undefined) {
	                command.responseCallback(commandResp);
	            }
	        };
	        this.getMercurySession = () => {
	            return this.session;
	        };
	        this.sendProviderResponse = (response) => {
	            if (response && response.method && response.eventSource === mca$1.EventSource.mercury) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Send Response for: ${response.method}`);
	                let command = null;
	                let sendToMercury = false;
	                switch (response.method) {
	                    case mca$1.McaMethod.newComm:
	                    case mca$1.McaMethod.startComm:
	                    case mca$1.McaMethod.updateComm:
	                        sendToMercury = true;
	                        break;
	                    case mca$1.McaMethod.onDataUpdate:
	                        if (response.outData && response.outData != null) {
	                            sendToMercury = true;
	                            if (response.outData.updateType === mca$1.UpdateType.wrapUp) {
	                                command = new mca$1.Command(mca$1.InteractionCommandName.wrapupComplete, response.eventId, null, null, null, null, response.workType);
	                            }
	                        }
	                        break;
	                }
	                if (command) {
	                    if (command.command === mca$1.InteractionCommandName.wrapupComplete) {
	                        // Engagement component is no longer calling closeChannel
	                        // So we will once again do so
	                        this.invokeCommand(command);
	                    }
	                    else {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} NO LONGER Triggering ${command} for ${response.method}`);
	                        // Engagement Component Calls omnichannel-chat-container.startWrapup now.
	                        // this.invokeCommand(command);
	                    }
	                }
	                if (sendToMercury) {
	                    this.sendToMercury(response);
	                }
	            }
	        };
	        this.sendToMercury = (response) => {
	            mcaLogger_1$1.McaLogger.log(`${this.pre} Response sent to Mercury`, response);
	            if (!response.outData) {
	                return;
	            }
	            const mercuryChannel = this.getChannel(response.eventId);
	            if (!mercuryChannel) {
	                return;
	            }
	            if (!mercuryChannel.context) {
	                return;
	            }
	            if (!response.method) {
	                return;
	            }
	            switch (response.method) {
	                case mca$1.McaMethod.newComm:
	                case mca$1.McaMethod.startComm: // the channel doesn't exist during newComm response processing
	                case mca$1.McaMethod.updateComm:
	                    break;
	                default:
	                    return;
	            }
	            mcaLogger_1$1.McaLogger.info(`${this.pre} sendToMercury`);
	            try {
	                // Contact Details requires special handling
	                let updateParticipant = false;
	                let osvcChatEnabled = false;
	                const osvcContextItemList = new Array();
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    osvcChatEnabled = true;
	                }
	                if (response.outData[mca$1.SystemToken.firstName]) {
	                    const firstName = mercuryChannel.context.get(mercury$1.ChannelContextNameType.FIRST_NAME);
	                    if (response.outData[mca$1.SystemToken.firstName] !== firstName) {
	                        updateParticipant = true;
	                        const firstNameContext = new mercury$1.ChannelContextItem();
	                        firstNameContext.name = mercury$1.ChannelContextNameType.FIRST_NAME;
	                        firstNameContext.value = response.outData[mca$1.SystemToken.firstName];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(firstNameContext);
	                        }
	                    }
	                }
	                if (response.outData[mca$1.SystemToken.lastName]) {
	                    const lastName = mercuryChannel.context.get(mercury$1.ChannelContextNameType.LAST_NAME);
	                    if (response.outData[mca$1.SystemToken.lastName] !== lastName) {
	                        updateParticipant = true;
	                        const lastNameContext = new mercury$1.ChannelContextItem();
	                        lastNameContext.name = mercury$1.ChannelContextNameType.LAST_NAME;
	                        lastNameContext.value = response.outData[mca$1.SystemToken.lastName];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(lastNameContext);
	                        }
	                    }
	                }
	                if (response.outData[mca$1.SystemToken.contactId]) {
	                    const contactId = mercuryChannel.context.get(mercury$1.ChannelContextNameType.CONTACT_ID);
	                    if (response.outData[mca$1.SystemToken.contactId] !== contactId) {
	                        const contactIdContext = new mercury$1.ChannelContextItem();
	                        contactIdContext.name = mercury$1.ChannelContextNameType.CONTACT_ID;
	                        contactIdContext.value = response.outData[mca$1.SystemToken.contactId];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(contactIdContext);
	                        }
	                    }
	                }
	                if (updateParticipant) {
	                    // Ensure the the Visitor name is displayed correctly on the Chat UI
	                    const participant = this.getVisitor(mercuryChannel);
	                    if (participant) {
	                        if (participant.resource) {
	                            const hr = participant.resource;
	                            if (response.outData[mca$1.SystemToken.firstName]) {
	                                hr.firstName = response.outData[mca$1.SystemToken.firstName];
	                            }
	                            if (response.outData[mca$1.SystemToken.lastName]) {
	                                hr.lastName = response.outData[mca$1.SystemToken.lastName];
	                            }
	                        }
	                        // Removed 11-23-20
	                        // participant.refreshName();
	                    }
	                }
	                // All other MCA Tokens will be added generically as customFields
	                const customFieldsName = 'customFields';
	                let customFields = mercuryChannel.context.get(customFieldsName);
	                if (!customFields) {
	                    customFields = new Array();
	                }
	                const tmpMap = new Map();
	                for (let i = 0; i < customFields.length; i++) {
	                    tmpMap.set(customFields[i].name, customFields[i]);
	                }
	                for (const key of Object.keys(response.outData)) {
	                    if (!response.outData.hasOwnProperty(key)) {
	                        continue;
	                    }
	                    if (tmpMap.has(key)) {
	                        if (tmpMap.get(key) === response.outData[key]) {
	                            continue;
	                        }
	                    }
	                    if (typeof response.outData[key] !== 'string') {
	                        continue;
	                    }
	                    switch (key) {
	                        case mca$1.SystemToken.contactId:
	                        case mca$1.SystemToken.firstName:
	                        case mca$1.SystemToken.lastName:
	                        case mca$1.SystemToken.contactName:
	                        case mca$1.SystemToken.accountId:
	                        case mca$1.SystemToken.interactionId:
	                        case mca$1.SystemToken.leadId:
	                        case mca$1.SystemToken.leadName:
	                        case mca$1.SystemToken.bypassCustomerVerification:
	                            const contextItem = new mercury$1.ChannelContextItem();
	                            contextItem.name = key;
	                            contextItem.value = response.outData[key];
	                            if (!contextItem.value || contextItem.value.trim().length < 1) {
	                                // 03-24-22 SVC-218408 Fix
	                                break;
	                            }
	                            mcaLogger_1$1.McaLogger.info(`${this.pre} Updating mercuryChannel Context ${key}:${response.outData[key]}`);
	                            if (osvcChatEnabled) {
	                                osvcContextItemList.push(contextItem);
	                            }
	                            break;
	                        case mca$1.SystemToken.confInteractionsMapper:
	                            let interactionsMapper;
	                            try {
	                                interactionsMapper = JSON.parse(response.outData[key]);
	                            }
	                            catch (errIM) {
	                                mcaLogger_1$1.McaLogger.warn(`${this.pre} Parsing while updating mercuryChannel Context ${key} failed - will be initialized - err:${errIM}`);
	                            }
	                            const contextInteractionsMapper = new mercury$1.ChannelContextItem();
	                            contextInteractionsMapper.name = key;
	                            if (interactionsMapper) {
	                                let agentFound = false;
	                                for (let i = 0; i < interactionsMapper.length; i++) {
	                                    if (interactionsMapper[i].agentId === this.userConfigurations.userDetails.agentId) {
	                                        agentFound = true;
	                                        break;
	                                    }
	                                }
	                                if (!agentFound) {
	                                    interactionsMapper.push({
	                                        agentId: this.userConfigurations.userDetails.agentId,
	                                        interactionId: response.outData[mca$1.SystemToken.interactionId]
	                                    });
	                                }
	                                else {
	                                    break;
	                                }
	                            }
	                            else {
	                                interactionsMapper = [];
	                                interactionsMapper.push({
	                                    agentId: this.userConfigurations.userDetails.agentId,
	                                    interactionId: response.outData[mca$1.SystemToken.interactionId]
	                                });
	                            }
	                            contextInteractionsMapper.value = JSON.stringify(interactionsMapper);
	                            if (osvcChatEnabled) {
	                                osvcContextItemList.push(contextInteractionsMapper);
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                if (osvcChatEnabled && osvcContextItemList.length > 0) {
	                    mercuryChannel.modifyProperties(osvcContextItemList);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Error sending Mercury Updates ${err}`);
	            }
	        };
	        this.getMcaBundleString = (key) => {
	            let returnString = null;
	            if (this.mcaBundle) {
	                returnString = this.mcaBundle[key];
	            }
	            if (!returnString) {
	                if (this.bundle[key]) {
	                    returnString = this.bundle[key];
	                }
	                else {
	                    mcaLogger_1$1.McaLogger.error(this.pre + 'unable to find mca translation bundle with String key ==> ' + key);
	                    returnString = '*' + key;
	                }
	            }
	            return returnString;
	        };
	        /**
	         * Ensure the Mercury Session is cleaned up when the window is closed
	         */
	        this.unloadListener = (event) => {
	            const mercuryNavigationBehavior = localStorage.getItem('mercuryNavigationBehavior') || 'keepalive';
	            if (this.session) {
	                if (mercuryNavigationBehavior === 'keepalive') {
	                    try {
	                        this.session.setActivityStatus(0);
	                    }
	                    catch (error) {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} Exception invoking Session.setActivityStatus ${error}`);
	                    }
	                }
	                else {
	                    mcaLogger_1$1.McaLogger.info(this.pre + 'Ending Mercury Session');
	                    try {
	                        this.session
	                            .end(true)
	                            .then(() => {
	                            mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* Session.end `);
	                        })
	                            .catch((err) => {
	                            mcaLogger_1$1.McaLogger.warn(`${this.pre} Exception in Session.end ${err}`);
	                        });
	                    }
	                    catch (oerr) {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} Exception invoking Session.end ${oerr}`);
	                    }
	                }
	            }
	        };
	        /**
	         * Retrieve the current Agent's Availability states for all eligible Mercury Channels
	         * @returns empty Map is returned if no Mercury Channels are configured for the current user
	         */
	        this.getAvailableStatesFromMercury = () => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} Retrieving AvailabilityMap from Mercury`);
	            const agentStateMap = new Map();
	            try {
	                const mercuryStateMap = this.session.availability;
	                // const mercuryWorkTypeDefinitionMap: Map<string, any> = this.session.workTypeDefinition;
	                if (mercuryStateMap && mercuryStateMap.size > 0) {
	                    const keys = mercuryStateMap.keys();
	                    for (const key of keys) {
	                        const availState = mercuryStateMap.get(key);
	                        const isAvailable = availState === mercury$1.AvailabilityType.AVAILABLE;
	                        if (this.userConfigurations && this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                            if (key === mca$1.Constants.CHAT) {
	                                const agentState = {
	                                    channel: mca$1.Constants.CHAT,
	                                    channelType: mca$1.ChannelType.chat,
	                                    displayName: this.getMcaBundleString('chat'),
	                                    isAvailable,
	                                    isLoggedIn: true,
	                                    workType: mca$1.Constants.CHAT
	                                };
	                                mcaLogger_1$1.McaLogger.info(`${this.pre} WorkType: ${agentState.workType} isAvailable: ${isAvailable}`);
	                                agentStateMap.set(agentState.workType, agentState);
	                                if (isAvailable && this.session) {
	                                    this.session.requestAssignment().then(() => {
	                                        mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* requestAssignment `);
	                                    }).catch((reason) => {
	                                        mcaLogger_1$1.McaLogger.error(`${this.pre} Error in requestAssignment ${reason}`);
	                                    });
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Error retrieving Mercury session.availability ${err}`);
	            }
	            return agentStateMap;
	        };
	        this.mapMercuryCategoryToChannelType = (category) => {
	            if (category === mca$1.Constants.CHAT) {
	                return mca$1.ChannelType.chat;
	            }
	            else if (category === mca$1.Constants.VIDEO) {
	                return mca$1.ChannelType.video;
	            }
	            else {
	                return mca$1.ChannelType.none;
	            }
	        };
	        /**
	         * ONLY FOR DEV USE TO CLEAR OUTSTANDING AGENT CHATS
	         * ** DEV NOTE ** To Clear Chats Manually Add the following key to your Local Storage
	         * clearChats = y
	         * Then Reload Your Page
	         * Be Sure to Reset the clearChats value to 'n' or delete the key before running any tests
	         */
	        this.devClearAgentChats = () => {
	            const resetAgent = localStorage.getItem(McaMercuryModel.RESET_AGENT);
	            if (!resetAgent) {
	                return;
	            }
	            if (resetAgent === 'y' || resetAgent === 'Y') {
	                try {
	                    const chats = this.session.getChannels();
	                    if (chats && chats.length > 0) {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} *** Found ${chats.length} Chats to Clear ***`);
	                        for (let i = 0; i < chats.length; i++) {
	                            const chat = chats[i];
	                            chat
	                                .conclude()
	                                .then((response) => {
	                                mcaLogger_1$1.McaLogger.info(this.pre + 'Chat Ended' + chat.identifier);
	                                chat
	                                    .close()
	                                    .then((closeResponse) => {
	                                    mcaLogger_1$1.McaLogger.info(this.pre + 'Chat Closed' + chat.identifier);
	                                })
	                                    .catch((reason) => {
	                                    mcaLogger_1$1.McaLogger.error(`${this.pre} Error closing chat ${reason}`);
	                                });
	                            })
	                                .catch((reason) => {
	                                mcaLogger_1$1.McaLogger.error(`${this.pre} Error concluding chat ${reason}`);
	                            });
	                        }
	                    }
	                    else {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} No Chats to clear`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} exception clearing agent's chats ${err}`);
	                }
	            }
	        };
	        /**
	         * Create a new Mercury Session
	         */
	        this.connect = () => {
	            if (this.loadStatus() === mca$1.EventState.process || this.loadStatus() === mca$1.EventState.complete) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Mercury Session already connecting`);
	                return;
	            }
	            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                this.loadStatus(mca$1.EventState.process);
	                if (this.session && this.session.availability.get('Chat') === 'Available') {
	                    this.session
	                        .end(true)
	                        .then(() => {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* Session.end `);
	                        this.session = null;
	                        this.createOsvcSession();
	                    })
	                        .catch((err) => {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} Exception in Session.end ${err}`);
	                        // just reset sesion variable and continue
	                        this.session = null;
	                        this.createOsvcSession();
	                    });
	                }
	                else {
	                    this.createOsvcSession();
	                }
	            }
	            else {
	                // this is failed state, will not attempt reconnection
	                this.loadStatus(mca$1.EventState.fail);
	            }
	        };
	        this.createOsvcSession = () => {
	            var _a;
	            mcaLogger_1$1.McaLogger.info(`${this.pre} start createOsvcSession`);
	            const jwt = this.userConfigurations.mercuryInfo.chatServerClientToken;
	            const config = {
	                accountId: this.userConfigurations.mercuryInfo.chatServerAccountId,
	                delayGetMessages: false,
	                endPoint: this.userConfigurations.mercuryInfo.chatServerEndPoint,
	                pool: this.userConfigurations.mercuryInfo.chatServerPool
	            };
	            if (this.userConfigurations.mercuryInfo.chatServerQueues) {
	                config.queues = this.userConfigurations.mercuryInfo.chatServerQueues;
	            }
	            if (typeof this.userConfigurations.mercuryInfo.maxSessions !== 'undefined') {
	                config.maxSessions = this.userConfigurations.mercuryInfo.maxSessions;
	            }
	            if (typeof this.userConfigurations.mercuryInfo.maxActiveSessions !== 'undefined') {
	                config.maxActiveSessions = this.userConfigurations.mercuryInfo.maxActiveSessions;
	            }
	            const tmpEngagement = this.winMgr.getActiveEngagement();
	            if (tmpEngagement && (tmpEngagement.engagementSource === mca$1.EventSource.mercury)) {
	                if (!tmpEngagement.eventMap.closeCommEvent) {
	                    // SVC-199025 - Tell chat-client to wait for the refreshMessages call before starting to poll
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} Chat Config set delayGetMessages`);
	                    const engWindow = this.winMgr.getWindowForEngagement(tmpEngagement.engagementId);
	                    config.delayGetMessages = (engWindow === null || engWindow === void 0 ? void 0 : engWindow.name) === window.name;
	                }
	            }
	            if (localStorage.getItem(oj_mca_common_1$2.McaCommon.MCA_LOCAL_DEBUG_MODE_KEY) === 'Y') {
	                config.debugEnabled = 'Y';
	            }
	            else {
	                config.debugEnabled = (_a = this.userConfigurations.userDetails) === null || _a === void 0 ? void 0 : _a.debugMode;
	            }
	            try {
	                if (oj_mca_common_1$2.McaCommon.isEngageSDKEnabled()) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Engage SDK should use mca-engage-sdk-connector!`);
	                }
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Opening OSVC Session ${config.endPoint}`);
	                mercury$1.Session.create(jwt, config, true)
	                    .then((session) => {
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* OSVC Session Created with account: ${config.accountId} server\n ${config.endPoint}`);
	                    this.session = session;
	                    this.registerMercuryListeners(); // Make sure to register the listeners 1st before updating our loadStatus
	                    this.initChatConfigs(config);
	                    this.loadStatus(mca$1.EventState.complete);
	                    this.devClearAgentChats();
	                    if (config && config.endPoint) {
	                        try {
	                            const url = new URL(config.endPoint);
	                            const origin = url.origin;
	                            if (origin) {
	                                this.mercuryOrigin = origin;
	                            }
	                        }
	                        catch (err) {
	                            // nothing to do here, if endpoint malformed it probably errored earlier
	                        }
	                    }
	                })
	                    .catch((reason) => {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Error Opening OSVC Session: ${reason}`);
	                    this.session = null;
	                    this.loadStatus(mca$1.EventState.loaded);
	                    this.dispatchWindowEvent(mca$1.McaEventType.connectionLost, { reason });
	                });
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Error Creating OSVC Session ${err}`);
	                this.session = null;
	                this.loadStatus(mca$1.EventState.loaded);
	                this.dispatchWindowEvent(mca$1.McaEventType.connectionLost, { reason: err });
	            }
	        };
	        /**
	         * Disables Mercury in cached fetchUserEventConfiguration to prevent loading this component for the remainder of
	         * this user's session.
	         * This should be called if Mercury returns an errorCondition == 'RESOURCE_NOT_FOUND'
	         * TODO - KEEP THIS ???
	         */
	        this.disableMercury = (reason) => {
	            const endPoint = oj_mca_common_1$2.McaCommon.getApiGroupMultiChannelAdapterEvents() + mca$1.McaEventName.fetchUserEventConfiguration;
	            const request = new mca_rest_helper_1$1.McaRestHelper(endPoint, 'application/vnd.oracle.adf.action+json');
	            mcaLogger_1$1.McaLogger.info(this.pre + 'Invoking McaRestHelper: ' + endPoint);
	            request.fetch().then((result) => {
	                try {
	                    if (result && typeof result === 'string') {
	                        result = JSON.parse(result);
	                        result.mercuryInfo.chatEnabled = 'N';
	                        result.mercuryInfo.errorCd = reason.errorCondition;
	                        result = JSON.stringify(result);
	                        request.manualCacheData(result);
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} Disabled Mercury for Session`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.warn(this.pre + 'Error disabling mercury in cache');
	                    mcaLogger_1$1.McaLogger.warn(err);
	                }
	            })
	                .catch((err) => {
	            });
	        };
	        this.initChatConfigs = (config) => {
	            try {
	                if (this.chatConfigData()) {
	                    return;
	                }
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Retrieving Chat Configurations `);
	                this.chatConfigCache
	                    .fetch()
	                    .then((chatConfig) => {
	                    if (chatConfig) {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} Successfully retrieved Chat Configurations from cache`);
	                        // convert cached object into a Map
	                        const chatConfigMap = new Map();
	                        for (const key of Object.keys(chatConfig)) {
	                            if (chatConfig.hasOwnProperty(key)) {
	                                chatConfigMap.set(key, chatConfig[key]);
	                            }
	                        }
	                        this.chatConfigData(chatConfigMap);
	                    }
	                    else {
	                        this.getChatConfigsFromMercury(config);
	                    }
	                })
	                    .catch((reason) => {
	                    // This is expected the 1st time following a new session creation
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} Unable to retrieve chatConfigs from cache`);
	                    this.getChatConfigsFromMercury(config);
	                });
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception Getting Mercury chatConfigs from cache ${err}`);
	                this.getChatConfigsFromMercury(config);
	            }
	        };
	        this.getChatConfigsFromMercury = (config) => {
	            try {
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} getChatConfigs for OSvC`);
	                    const chatConfig = new Map();
	                    const userPreferences = 'userPreferences';
	                    if (window[userPreferences]) {
	                        for (const key of Object.keys(window[userPreferences])) {
	                            if (typeof window[userPreferences][key] === 'string' && window[userPreferences].hasOwnProperty(key)) {
	                                chatConfig.set(key, window[userPreferences][key]);
	                            }
	                        }
	                    }
	                    this.chatConfigData(chatConfig);
	                    // Store data in cache as an object
	                    const cacheData = {};
	                    for (const key of chatConfig.keys()) {
	                        cacheData[key] = chatConfig.get(key);
	                    }
	                    this.chatConfigCache.manualCacheData(cacheData);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception retrieving chatConfigs ${err}`);
	                this.chatConfigData(new Map());
	            }
	        };
	        /**
	         * Adds the listeners to Mercury Engagement Events for the given Mercury Channel
	         * Note: A Mercury Channel is akin to an MCA Engagement
	         */
	        this.registerListenersForMercuryChannel = (mercuryChannel) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} Registering Listeners for mercuryChannel: ${mercuryChannel}`);
	            try {
	                mercuryChannel.on(mercury$1.MercuryEventType.MESSAGE_ADDED, this.handleMessageEvent);
	                mercuryChannel.on(mercury$1.MercuryEventType.MESSAGE_REMOVED, this.handleMessageEvent);
	                mercuryChannel.on(mercury$1.MercuryEventType.MESSAGE_UPDATED, this.handleMessageEvent);
	                mercuryChannel.on(mercury$1.MercuryEventType.MEMBER_LEFT, this.handleMemberEvent);
	                mercuryChannel.on(mercury$1.MercuryEventType.MEMBER_JOINED, this.handleMemberEvent);
	                mercuryChannel.on(mercury$1.MercuryEventType.MEMBER_UPDATED, this.handleMemberEvent);
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Exception Registering listeners for Mercury Channel: ' + mercuryChannel + ' Error: ' + err);
	            }
	        };
	        this.registerMercuryListeners = () => {
	            this.session.on(mercury$1.MercuryEventType.WORK_OFFER, this.handleWorkOffer);
	            this.session.on(mercury$1.MercuryEventType.CHANNEL_ADDED, this.handleChannelEvent);
	            this.session.on(mercury$1.MercuryEventType.CHANNEL_REMOVED, this.handleChannelEvent);
	            this.session.on(mercury$1.MercuryEventType.CONTROL_MESSAGE, this.handleControlEvent);
	            this.session.on(mercury$1.MercuryEventType.ACTIVITY_CHANGE, this.handleActivityEvent);
	            this.session.on(mercury$1.MercuryEventType.MEMBER_JOINED, this.handleMemberEvent);
	            this.session.on(mercury$1.MercuryEventType.MEMBER_LEFT, this.handleMemberEvent);
	            this.session.on(mercury$1.MercuryEventType.MEMBER_UPDATED, this.handleMemberEvent);
	            // Only registering these for the window where the active engagement resides, otherwise we get redundant events on refresh
	            // this.session.on(mercury.MercuryEventType.MESSAGE_ADDED, this.handleMessageEvent);
	            // this.session.on(mercury.MercuryEventType.MESSAGE_REMOVED, this.handleMessageEvent);
	            // this.session.on(mercury.MercuryEventType.MESSAGE_UPDATED, this.handleMessageEvent);
	            this.session.on(mercury$1.MercuryEventType.CONNECTION_ERROR, this.handleConnectionErrorEvent);
	            this.session.on(mercury$1.MercuryEventType.CONNECTION_ESTABLISHED, this.handleConnectionEstablishedEvent);
	            this.session.on(mercury$1.MercuryEventType.UPLOAD_COMPLETED, this.handleUploadEvent);
	            this.session.on(mercury$1.MercuryEventType.UPLOAD_STATUS, this.handleUploadEvent);
	            this.session.on(mercury$1.MercuryEventType.AVAILABILITY_CHANGE, this.handleAvailableEvent);
	            this.session.on(mercury$1.MercuryEventType.UNSTABLE_CONNECTION, this.handleUnstableConnectionEvent);
	            this.session.on(mercury$1.MercuryEventType.OFFER_CANCELLATION, this.handleChatCancelEvent);
	            try {
	                const channels = this.session.getChannels();
	                if (channels && channels.length > 0) {
	                    for (let i = 0; i < channels.length; i++) {
	                        if (channels[i]) {
	                            const mercuryChannel = channels[i];
	                            const engagementId = mercuryChannel.identifier;
	                            if (this.winMgr.isCurrentEngagementWindow(engagementId)) {
	                                this.registerListenersForMercuryChannel(mercuryChannel);
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Exception retrieving channels ' + err);
	            }
	            try {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} Starting Mercury Session Listener ...`);
	                this.session.startListening();
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Exception startListening ' + err);
	            }
	        };
	        this.initMcaFramework = () => {
	            mcaLogger_1$1.McaLogger.warn(`${this.pre} TODO Add Log Handler`);
	            this.engMgr = mca_engagement_manager_1$2.EngagementManager.getInstance();
	            this.engMgr.setResponseTarget(this.handleEngagementResponse, mca$1.EventSource.mercury);
	            this.engMgr.setEventTarget(this.handleEngagementEvent, mca$1.EventSource.mercury);
	            this.winMgr = mca_window_manager_1$2.WindowManager.getInstance();
	            if (this.mcaBundle) {
	                this.winMgr.setMcaBundle(this.mcaBundle);
	            }
	            window.addEventListener(mca$1.McaEventType.unloadHandling, this.unloadListener);
	        };
	        this.setUserConfigurations = (userConfigurations) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} setUserConfigurations begins`);
	            if (!userConfigurations || !userConfigurations.mercuryInfo) {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} setUserConfigurations failed, missing mercuryInfo`);
	                return;
	            }
	            this.userConfigurations = userConfigurations;
	            if (this.userConfigurations.userDetails) {
	                if (this.userConfigurations.userDetails.permissions) {
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Chat_Access') !== -1 ||
	                        this.userConfigurations.userDetails.permissions.indexOf('SVC_CHAT_FEATURES_PRIV') !== -1) {
	                        this.allowMcaChatAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Audio_Access') !== -1) {
	                        this.allowMcaAudioAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Video_Access') !== -1) {
	                        this.allowMcaVideoAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Recording_Access') !== -1) {
	                        this.allowMcaRecordingAccess(true);
	                    }
	                }
	                // Special handling for Local tests, because some user permission settings
	                //   are not passed in to local test user.
	                if (this.userConfigurations.userDetails.appName === mca$1.AppName.mca) {
	                    this.allowMcaChatAccess(true);
	                    this.allowMcaAudioAccess(true);
	                    this.allowMcaVideoAccess(true);
	                    this.allowMcaRecordingAccess(true);
	                }
	            }
	            const mercuryInfo = userConfigurations.mercuryInfo;
	            if (mercuryInfo != null && mercuryInfo.chatEnabled === true) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} setUserConfigurations - chat is enabled, make validations`);
	                if (!oj_mca_common_1$2.McaCommon.isValidUrl(mercuryInfo.chatServerEndPoint)) {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} chatEnabled is true and chatServerEndPoint URL is invalid`);
	                    this.loadStatus(mca$1.EventState.fail);
	                }
	                else if (!mercuryInfo.chatServerClientToken) {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} chatEnabled is true but missing JWT`);
	                    this.loadStatus(mca$1.EventState.fail);
	                }
	                else if (!mercuryInfo.omniBrowserNotificationEnabled && !mercuryInfo.omniDesktopNotificationEnabled) {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} channels are disabled because chat and notifications are disabled`);
	                    this.loadStatus(mca$1.EventState.fail);
	                }
	                else {
	                    // Since this should only ever read from cache we don't need extensionObject param
	                    this.chatConfigCache = new mca_rest_helper_1$1.McaRestHelper(McaMercuryModel.CHAT_CONFIG_CACHE, mca_rest_helper_1$1.McaRestHelper.NO_REST);
	                    this.connect();
	                }
	            }
	            else {
	                this.loadStatus(mca$1.EventState.fail);
	                mcaLogger_1$1.McaLogger.info(`${this.pre} setUserConfigurations after set this.loadStatus to fail`);
	            }
	            mcaLogger_1$1.McaLogger.info(`${this.pre} setUserConfigurations ends`);
	        };
	        /**
	         * Retrieves the current Agent States from Mercury and broadcasts events.
	         */
	        this.refreshAgentStates = () => {
	            this.getAgentStates()
	                .then((agentStateMap) => {
	                if (agentStateMap && agentStateMap.size > 0) {
	                    const workTypes = agentStateMap.keys();
	                    for (const workType of workTypes) {
	                        const agentState = agentStateMap.get(workType);
	                        const formattedEvent = { bubbles: true, cancelable: false, detail: agentState };
	                        const customEvent = new CustomEvent(mca$1.McaEventType.agentState, formattedEvent);
	                        this.dispatchClientEvent(customEvent);
	                    }
	                }
	                else {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} No Mercury ChannelStates retrieved`);
	                }
	            })
	                .catch((reason) => {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Error retrieving Mercury ChannelStates ` + reason);
	            });
	        };
	        this.getMcaChannelFromMercuryType = (type) => {
	            if (type === 'REALTIME_CHAT') {
	                // session.availability returns workType: 'CHAT' but availability event come with workType 'REALTIME_CHAT'
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Converting OLD Mercury WorkType: REALTIME_CHAT, to new WorkType: CHAT`);
	                type = 'CHAT';
	            }
	            if (type === 'VIDEO') {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Converting channel Type: VIDEO, to WorkType: Video`);
	                type = 'Video';
	            }
	            let retVal;
	            if (this.supportedChannels) {
	                for (const channel of this.supportedChannels) {
	                    if (type === channel.workType) {
	                        retVal = channel;
	                        break;
	                    }
	                }
	            }
	            if (!retVal) {
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} Unknown Mercury WorkType: ${type}, Using Raw WorkType for Display`);
	                retVal = {
	                    channelType: mca$1.ChannelType.none,
	                    displayName: type,
	                    source: mca$1.EventSource.mercury,
	                    workType: type
	                };
	            }
	            return retVal;
	        };
	        /**
	         * An Engagement Event was detected in another window.
	         * FYI, This event MAY have already been detected in this window as well.
	         */
	        this.handleEngagementEvent = (event) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'handleEngagementEvent ' + event);
	            switch (event.method) {
	                case mca$1.McaMethod.newComm:
	                    this.checkAndSendNotify(event, true);
	                    break;
	                case mca$1.McaMethod.startComm:
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca$1.McaMethod.closeComm:
	                    const newEvent = this.convertMcaEvent(event, null);
	                    if (newEvent) {
	                        this.dispatchClientEvent(newEvent);
	                    }
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca$1.McaMethod.updateComm:
	                    this.sendMercuryDataUpdate(event);
	                    break;
	            }
	        };
	        this.sendMercuryDataUpdate = (event) => {
	            const response = {};
	            if (!event.data.inData) {
	                return;
	            }
	            response.uuid = event.uuid;
	            response.result = mca$1.Result.success;
	            response.method = event.method;
	            response.channelType = event.data.channelType;
	            response.origin = event.origin;
	            response.eventId = event.data.eventId;
	            response.engagementId = event.data.engagementId;
	            response.outData = event.data.inData;
	            this.sendToMercury(response);
	        };
	        this.handleEngagementResponse = (response, event) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} handleEngagementResponse ${response}`);
	            if (event.previewMode) {
	                response.previewMode = event.previewMode;
	            }
	            response.workType = event.data.workType;
	            this.sendProviderResponse(response);
	            const newEvent = this.convertMcaEvent(event, response);
	            if (newEvent) {
	                this.dispatchClientEvent(newEvent);
	            }
	            if (event && event.method) {
	                switch (event.method) {
	                    case mca$1.McaMethod.newComm:
	                        const engagement = this.engMgr.getEngagement(event.data.eventId);
	                        // Don't send this if we already got a start or close
	                        if (engagement && engagement.lastEvent.method === mca$1.McaMethod.newComm) {
	                            this.checkAndSendNotify(event, true, response); // Update Notification with Response Data
	                        }
	                        break;
	                    case mca$1.McaMethod.closeComm:
	                        // Ensure the Chat is Cleaned Up in the No-Wrap-Up Case
	                        if (response && response.actions) {
	                            for (let i = 0; i < response.actions.length; i++) {
	                                if (response.actions[i].name === mca$1.ActionName.EndCommunication && event.data.reason !== mca$1.CloseCommReason.transferred) {
	                                    const command = new mca$1.Command(mca$1.InteractionCommandName.wrapupComplete, event.data.eventId, null, null, null, null, response.workType);
	                                    // 1-11-22 Once again Closing chat since this is no longer done by Chat UI
	                                    // Engagement Component does not call omnichannel-chat-container.closeChannel anymore.
	                                    // So, this is now required for Chat.
	                                    this.invokeCommand(command);
	                                    break;
	                                }
	                            }
	                        }
	                        const win = this.winMgr.getWindowForLatestEngagement(event.data.eventId);
	                        if (!win || win.unloadTime > 0) {
	                            if ([mca$1.CloseCommReason.transferred, mca$1.CloseCommReason.reject, mca$1.CloseCommReason.timeout, mca$1.CloseCommReason.abandoned].indexOf(event.data.reason) === -1) {
	                                // Try to Clean Up the Chat in case the Window is Closed
	                                const command = new mca$1.Command(mca$1.InteractionCommandName.wrapupComplete, event.data.eventId, null, null, null, null, response.workType);
	                                mcaLogger_1$1.McaLogger.warn(`${this.pre} Evidently the ${event.data.channel} window was closed, Forcing ${command} for ${response.method}`);
	                                this.invokeCommand(command);
	                            }
	                        }
	                        break;
	                }
	            }
	        };
	        /**
	         * Checks if a notification event is necessary and if so sends it.
	         */
	        this.checkAndSendNotify = (event, notifyOn, response) => {
	            if (!event) {
	                return;
	            }
	            if (event.previewMode && event.previewMode === 'MANUAL') {
	                return;
	            }
	            if (event.data == undefined || !event.data.inData) {
	                return;
	            }
	            if (event.data.inData[mca$1.SystemToken.direction] === mca$1.DirectionToken.outbound) {
	                return;
	            }
	            if (notifyOn) {
	                if (!event.actions) {
	                    mcaLogger_1$1.McaLogger.info(this.pre + 'no notify Action set');
	                    return;
	                }
	                else {
	                    let notifyFound = false;
	                    for (const action of event.actions) {
	                        if (action.name === mca$1.ActionName.Notify) {
	                            notifyFound = true;
	                            break;
	                        }
	                    }
	                    if (!notifyFound) {
	                        mcaLogger_1$1.McaLogger.info(this.pre + 'no notify Action set');
	                        return;
	                    }
	                }
	            }
	            const detail = { event, response };
	            const formattedEvent = {
	                bubbles: true,
	                cancelable: false,
	                detail
	            };
	            const eventType = notifyOn ? mca$1.McaEventType.notifyOn : mca$1.McaEventType.notifyOff;
	            const ne = new CustomEvent(eventType, formattedEvent);
	            this.dispatchClientEvent(ne);
	        };
	        /**
	         * Format events for client publication
	         * @return the event to be published, null is returned if no event publication is required.
	         */
	        this.convertMcaEvent = (event, response) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'convertMcaEvent: ' + event.method);
	            let rv = null;
	            if (!event.data) {
	                mcaLogger_1$1.McaLogger.warn(this.pre + 'convertMcaEvent: missing event.data');
	                return rv;
	            }
	            const eventName = 'mcaEvent';
	            let detail;
	            if (!event.data.engagementId) {
	                event.data.engagementId = event.data.eventId;
	            }
	            if (event.method && response) {
	                switch (event.method) {
	                    case mca$1.McaMethod.newComm:
	                    case mca$1.McaMethod.startComm:
	                    case mca$1.McaMethod.closeComm:
	                    case mca$1.McaMethod.updateComm:
	                    case mca$1.McaMethod.transferedToQueue:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                    case mca$1.McaMethod.agentStateEvent:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                    case mca$1.McaMethod.interactionControlsChanged:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                }
	            }
	            if (detail) {
	                const formattedEvent = {
	                    bubbles: true,
	                    cancelable: false,
	                    detail
	                };
	                rv = new CustomEvent(eventName, formattedEvent);
	            }
	            return rv;
	        };
	        this.dispatchClientEvent = (event) => {
	            if (event && event.type) {
	                try {
	                    let callback;
	                    switch (event.type) {
	                        case mca$1.McaEventType.agentState:
	                            if (this.agentStateEventListener) {
	                                callback = this.agentStateEventListener;
	                            }
	                            break;
	                        case mca$1.McaEventType.mcaEvent:
	                            if (this.mcaEventTarget) {
	                                callback = this.mcaEventTarget;
	                            }
	                            break;
	                        case mca$1.McaEventType.notifyOn:
	                        case mca$1.McaEventType.notifyOff:
	                            if (this.notificationEventTarget) {
	                                callback = this.notificationEventTarget;
	                            }
	                            break;
	                        default:
	                            mcaLogger_1$1.McaLogger.warn(`${this.pre} No dispacher defined for eventType: ${event.type}`);
	                            break;
	                    }
	                    if (callback) {
	                        mcaLogger_1$1.McaLogger.info(this.pre + 'Dispatching Event: ' + event.type);
	                        callback(event);
	                    }
	                    else {
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} no Listener registered for event: ${event.type}`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Exception during event dispatch`, err);
	                }
	            }
	        };
	        /**
	         * MCA --> Mercury Command Converters
	         */
	        this.setAvailability = (command) => {
	            try {
	                const availabilityMap = new Map();
	                if (!command.workType) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Mercury setAvailability Command missing workType!`);
	                    return;
	                }
	                const workType = command.workType;
	                const mercuryState = command.command === mca$1.AgentCommandName.makeAvailable
	                    ? mercury$1.AvailabilityType.AVAILABLE : mercury$1.AvailabilityType.UNAVAILABLE;
	                const osvcState = command.command === mca$1.AgentCommandName.makeAvailable
	                    ? OSvCAvailableStates$1.AVAILABLE : OSvCAvailableStates$1.UNAVAILABLE;
	                availabilityMap.set(workType, mercuryState);
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    if (this.session) {
	                        this.session.setActivityStatus(osvcState)
	                            .then(() => {
	                            mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* set availability OSvC chat: ${osvcState}`);
	                            if (command.responseCallback) {
	                                const resp = new mca$1.CommandResponse(command.command, mca$1.Result.success, command.commandId, null, {}, command.channelType, null, workType);
	                                try {
	                                    command.responseCallback(resp);
	                                }
	                                catch (iErr) { }
	                            }
	                        })
	                            .catch((reason) => {
	                            mcaLogger_1$1.McaLogger.error(`${this.pre} Error setting availability for OSvC chat: ${reason}`);
	                            this.loadStatus(mca$1.EventState.loaded);
	                            this.dispatchWindowEvent(mca$1.McaEventType.connectionLost, { reason });
	                            if (command.responseCallback) {
	                                const resp = new mca$1.CommandResponse(command.command, mca$1.Result.error, command.commandId, null, { reason }, command.channelType, null, workType);
	                                try {
	                                    command.responseCallback(resp);
	                                }
	                                catch (iErr) { }
	                            }
	                        });
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in setAvailability`, err);
	                this.loadStatus(mca$1.EventState.loaded);
	                this.dispatchWindowEvent(mca$1.McaEventType.connectionLost, { reason: err });
	                if (command.responseCallback) {
	                    const resp = new mca$1.CommandResponse(command.command, mca$1.Result.success, command.commandId, null, {}, command.channelType, null, command.workType);
	                    try {
	                        command.responseCallback(resp);
	                    }
	                    catch (iErr) { }
	                }
	            }
	        };
	        this.checkTarget = (target) => {
	            let retVal = true;
	            if (target && target.trim().length > 0) {
	                if (target !== mca$1.EventSource.mercury) {
	                    retVal = false;
	                }
	            }
	            return retVal;
	        };
	        this.checkChannel = (channelType) => {
	            let retVal = false;
	            if (this.supportedChannels) {
	                for (const channel of this.supportedChannels) {
	                    if (channelType === channel.channelType) {
	                        retVal = true;
	                        break;
	                    }
	                }
	            }
	            // In case channels haven't been initialized yet
	            if (!retVal) {
	                if (channelType === mca$1.ChannelType.chat) {
	                    retVal = true;
	                }
	            }
	            return retVal;
	        };
	        this.getCommEvent = (method, engagementId, details, workType) => {
	            let channelType;
	            let channel;
	            if (workType) {
	                const channelObj = this.getMcaChannelFromMercuryType(workType);
	                channelType = channelObj.channelType;
	                channel = channelObj.channel;
	            }
	            else {
	                channelType = mca$1.ChannelType.chat;
	                channel = mca$1.Constants.CHAT;
	            }
	            const appClass = mca$1.Constants.DEFAULT_APP_CLASS;
	            const data = {
	                appClassification: appClass,
	                channel,
	                channelType,
	                engagementId,
	                eventId: engagementId,
	                inData: {}
	            };
	            const mcaEvent = {
	                data,
	                eventSource: mca$1.EventSource.mercury,
	                mcaOrigEventSource: mca$1.EventSource.mercury,
	                method,
	                origin: this.mercuryOrigin,
	                toolbarName: mca$1.EventSource.mercury,
	                uuid: data.eventId,
	                version: this.mercuryVersion
	            };
	            data.inData[mca$1.SystemToken.direction] = mca$1.DirectionToken.inbound;
	            switch (method) {
	                case mca$1.McaMethod.startComm:
	                    break;
	                case mca$1.McaMethod.closeComm:
	                    if (details) {
	                        if (details === mca$1.CloseCommReason.canceled) {
	                            data.reason = mca$1.CloseCommReason.abandoned;
	                        }
	                        else if (details === mca$1.CloseCommReason.timeout ||
	                            details === mca$1.CloseCommReason.missed ||
	                            details === mca$1.CloseCommReason.reject ||
	                            details === mca$1.CloseCommReason.end ||
	                            details === mca$1.CloseCommReason.transferred ||
	                            details === mca$1.CloseCommReason.wrapup) {
	                            data.reason = details;
	                        }
	                    }
	                    else {
	                        data.reason = mca$1.CloseCommReason.wrapup;
	                    }
	                    break;
	            }
	            return mcaEvent;
	        };
	        this.internalProcessReceivedMessage = (mcaEvent) => {
	            if (mcaEvent.method) {
	                const eventResponse = {};
	                switch (mcaEvent.method) {
	                    case mca$1.McaMethod.newComm:
	                        this.checkAndSendNotify(mcaEvent, true);
	                        break;
	                    case mca$1.McaMethod.startComm:
	                        this.checkAndSendNotify(mcaEvent, false);
	                        break;
	                    case mca$1.McaMethod.closeComm:
	                        try {
	                            this.activeChannelsMap.delete(mcaEvent.data.eventId);
	                        }
	                        catch (err) {
	                            mcaLogger_1$1.McaLogger.error(`Failed to delete channel from channel map: [${err}]`);
	                        }
	                        this.checkAndSendNotify(mcaEvent, false);
	                        break;
	                    case mca$1.McaMethod.agentStateEvent:
	                        break;
	                    case mca$1.McaMethod.interactionControlsChanged:
	                        break;
	                }
	                this.processMcaEvent(mcaEvent, eventResponse);
	            }
	            else {
	                mcaLogger_1$1.McaLogger.info(this.pre + 'Ignoring event missing method!!!');
	            }
	        };
	        this.processMcaEvent = (event, response) => {
	            let deferredEngagement;
	            let setResponse = false;
	            switch (event.method) {
	                case mca$1.McaMethod.startComm:
	                case mca$1.McaMethod.newComm:
	                case mca$1.McaMethod.upgradeComm:
	                case mca$1.McaMethod.downgradeComm:
	                case mca$1.McaMethod.closeComm:
	                case mca$1.McaMethod.previewComm:
	                case mca$1.McaMethod.transferedToQueue:
	                    deferredEngagement = this.engMgr.processEvent(event);
	                    break;
	                case mca$1.McaMethod.agentStateEvent:
	                    if (response) {
	                        response.result = mca$1.Result.success;
	                        setResponse = true;
	                    }
	                    break;
	                case mca$1.McaMethod.interactionControlsChanged:
	                    setResponse = true;
	                    break;
	            }
	            if (deferredEngagement) {
	                deferredEngagement.then((engagement) => {
	                    if (!engagement) {
	                        mcaLogger_1$1.McaLogger.info(this.pre + 'Why no engagement returned from processEvent?');
	                    }
	                    else {
	                        mcaLogger_1$1.McaLogger.log(this.pre + 'processEvent Promise returned');
	                        const state = engagement.stateMap[event.method];
	                        if (state === mca$1.EventState.complete) {
	                            // event was processed on the server
	                            mcaLogger_1$1.McaLogger.log(this.pre + 'Event was already processed on the server.');
	                            const newResponse = engagement.responseMap[event.method];
	                            if (!newResponse) {
	                                mcaLogger_1$1.McaLogger.warn(this.pre + 'Event marked complete but no response.');
	                            }
	                            else {
	                                // uuid is unique to this toolbar's instance event
	                                newResponse.uuid = event.uuid;
	                                newResponse.workType = event.data.workType;
	                                this.sendProviderResponse(newResponse);
	                            }
	                        }
	                    }
	                });
	                deferredEngagement.catch((err) => {
	                    mcaLogger_1$1.McaLogger.warn(this.pre + 'Error detected in processEvent: ' + err);
	                });
	                return; // early exit!!!
	            }
	            let newEvent = null;
	            if (setResponse) {
	                newEvent = this.convertMcaEvent(event, response);
	                this.sendProviderResponse(response);
	                this.dispatchClientEvent(newEvent);
	            }
	        };
	        /**
	         * Wait for the Session Creation to complete or fail then invoke any outstanding commands
	         */
	        this.loadStatusListener = (newValue) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} loadStatus updated====>: ${newValue}`);
	            if (newValue === mca$1.EventState.complete || newValue === mca$1.EventState.fail) {
	                mcaLogger_1$1.McaLogger.info(`${this.pre} loadStatus updated: ${newValue}`);
	                if (this.commandQueue.length > 0) {
	                    mcaLogger_1$1.McaLogger.info(`${this.pre}  Processing ${this.commandQueue.length} Queued Commmands `);
	                    for (let i = 0; i < this.commandQueue.length; i++) {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre}  Processing Queued Commmand ${this.commandQueue[i]}`);
	                        this.invokeCommand(this.commandQueue[i]);
	                    }
	                    this.commandQueue = new Array(); // just reset the queue
	                }
	            }
	        };
	        /**
	         * Wait for the chatConfigs retrieval to complete or fail then send the results to any outstanding requestors
	         */
	        this.chatConfigListener = (newValue) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} chatConfigs updated====>: ${newValue}`);
	            if (this.chatConfigQueue.length > 0) {
	                for (let i = 0; i < this.chatConfigQueue.length; i++) {
	                    mcaLogger_1$1.McaLogger.info(`${this.pre}  Processing Queued chatConfig Commmand ${this.chatConfigQueue[i]}`);
	                    this.invokeCommand(this.chatConfigQueue[i]);
	                }
	                this.chatConfigQueue = new Array(); // just reset the queue
	            }
	        };
	        /**
	         * Asynchronous Command processing required when commands are initiated prior to the Mercury Session Creation
	         */
	        this.invokeCommandAsync = (command) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} invokeCommandAsync ${command}`);
	            try {
	                if (!this.session) {
	                    const dbgStatus = this.loadStatus();
	                    if (dbgStatus !== mca$1.EventState.complete && dbgStatus !== mca$1.EventState.fail) {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} queueing command ${command}`);
	                        this.commandQueue.push(command);
	                        return;
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception invokeCommandAsync: ${err}`);
	            }
	            this.invokeCommand(command);
	        });
	        this.getChannel = (id) => {
	            let channel = this.activeChannelsMap.get(id);
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ##### getChannel get from activeChannelsMap ${channel}`);
	            try {
	                if (!channel) {
	                    if (this.session) {
	                        const channels = this.session.getChannels();
	                        if (channels) {
	                            for (let i = 0; i < channels.length; i++) {
	                                if (channels[i] && channels[i].identifier === id) {
	                                    channel = channels[i];
	                                    mcaLogger_1$1.McaLogger.info(`${this.pre} ##### getChannel get from session ${channel}`);
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Exception retrieving channels', err);
	            }
	            return channel;
	        };
	        /**
	         * Retrieves the site visitor that initiated the Chat.
	         * @return mercury.Particant
	         */
	        this.getVisitor = (mercuryChannel) => {
	            let participant = null;
	            for (let i = 0; i < mercuryChannel.members.length; i++) {
	                const tmpParticipant = mercuryChannel.members[i];
	                if (tmpParticipant.role === mercury$1.ParticipationRoleType.END_USER) {
	                    participant = mercuryChannel.members[i];
	                    break;
	                }
	            }
	            return participant;
	        };
	        ///////////////////////////////
	        // Mercury Command Processors
	        ///////////////////////////////
	        this.acceptOffer = (command, offerResponseType = mca_mercury_copy_1$2.OfferResponseType.MANUAL) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'acceptOffer ', command, offerResponseType);
	            let event = this.getCommEvent(mca$1.McaMethod.closeComm, command.eventId, null, command.workType);
	            if (event.data.reason) {
	                event.data.reason = mca$1.CloseCommReason.reject;
	            }
	            const offer = this.pendingOffersMap.get(command.eventId);
	            // sjmD <TODO> Doesn't seem that All Offers are sent to All Windows???
	            if (!offer) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Could not find offer to accept for command ' + command);
	                // Ensure the notification gets closed
	                mcaLogger_1$1.McaLogger.warn(this.pre + 'Assuming close is in order');
	                this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    this.session.acceptOffer(offer, offerResponseType)
	                        .then((channel) => {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* acceptOffer ${channel}`);
	                        event = this.getCommEvent(mca$1.McaMethod.startComm, command.eventId, null, command.workType);
	                        // const channelStr: string = JSON.stringify(channel);
	                        // McaLogger.info(`${this.pre} Channel String is ` + channelStr);
	                        this.activeChannelsMap.set(offer.identifier, channel);
	                        this.internalProcessReceivedMessage(event);
	                        // sjm - 12-01-20 Don't see any reason to register Channel Listeners in the Accept Window
	                        // this.registerListenersForMercuryChannel(channel);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} Error in acceptOffer ${reason}`);
	                        mcaLogger_1$1.McaLogger.info(this.pre + 'Assuming close is in order');
	                        // Assume the Visitor Left the Chat
	                        event.data.reason = mca$1.CloseCommReason.abandoned;
	                        event.data.errorMsg = 'chatCanceled';
	                        this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in acceptOffer ${err}`);
	                    mcaLogger_1$1.McaLogger.warn(this.pre + 'Assuming close is in order');
	                    this.internalProcessReceivedMessage(event);
	                }
	                this.cleanupOffer(offer.identifier);
	            }
	        });
	        this.rejectOffer = (command) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'rejectOffer ' + command);
	            const event = this.getCommEvent(mca$1.McaMethod.closeComm, command.eventId, null, command.workType);
	            if (event.data.reason) {
	                event.data.reason = mca$1.CloseCommReason.reject;
	            }
	            const offer = this.pendingOffersMap.get(command.eventId);
	            if (!offer) {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Could not find offer to reject for command ' + command);
	                // Ensure the notification gets closed
	                mcaLogger_1$1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    this.session
	                        .rejectOffer(offer)
	                        .then(() => {
	                        mcaLogger_1$1.McaLogger.info(this.pre + '*Success* rejectOffer ');
	                        // At this point we don't have a channel so no need to delete
	                        // it from the map
	                        // this.activeChannelsMap.delete(channel.identifier);
	                        this.internalProcessReceivedMessage(event);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1$1.McaLogger.error(`${this.pre} Error in rejectOffer ${reason}`);
	                        mcaLogger_1$1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                        this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in rejectOffer ${err}`);
	                    mcaLogger_1$1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                    this.internalProcessReceivedMessage(event);
	                }
	                this.cleanupOffer(offer.identifier);
	            }
	        });
	        this.disconnectWithReasonCode = (command, reason) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'chatOfferTimeout ' + command);
	            const event = this.getCommEvent(mca$1.McaMethod.closeComm, command.eventId, reason, command.workType);
	            if (event.data.reason) {
	                event.data.reason = reason;
	            }
	            this.internalProcessReceivedMessage(event);
	        });
	        /**
	         * This does something on the Mercury Channel like a disconnect.
	         * This *MUST* be called to trigger closeCommEvent processing.
	         */
	        this.concludeEngagement = (command) => __awaiter$2(this, void 0, void 0, function* () {
	            var _a;
	            mcaLogger_1$1.McaLogger.info(this.pre + 'concludeEngagement ' + command);
	            let reason = null;
	            if ((_a = command === null || command === void 0 ? void 0 : command.inData) === null || _a === void 0 ? void 0 : _a.reason) {
	                reason = command.inData.reason;
	            }
	            const event = this.getCommEvent(mca$1.McaMethod.closeComm, command.eventId, reason, command.workType);
	            this.internalProcessReceivedMessage(event);
	        });
	        /**
	         * ToDo: transfer is done
	         */
	        this.transferedEngagement = (command) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'transferedEngagement ' + command);
	            const event = this.getCommEvent(mca$1.McaMethod.transferedToQueue, command.eventId, null, command.workType);
	            event.data.reason = mca$1.CloseCommReason.transferred;
	            this.internalProcessReceivedMessage(event);
	        });
	        /* 09-01-20: Original method, now seems Chat UI is invoking Channel.conclude so removed redundant call
	        private concludeEngagement = async (command: mca.Command): Promise<void> => {
	          McaLogger.info(this.pre + 'concludeEngagement ' + command);
	          const event: mca.McaEvent = this.getCommEvent(mca.McaMethod.closeComm, command.eventId);
	          const channel: mercury.Channel = this.getChannel(command.eventId);
	          if (!channel) {
	            McaLogger.error(this.pre + "Couldn't get Mercury Channel for comand: " + command);
	            McaLogger.warn(this.pre + 'Processing close anyway..');
	            this.internalProcessReceivedMessage(event);
	          } else {
	            try {
	              McaLogger.info(this.pre + 'Invoking Channel.conclude for ' + command);
	              channel
	                .conclude()
	                .then((response: any) => {
	                  McaLogger.info(`${this.pre} *Success* Channel.conclude ${response}`);
	                  this.internalProcessReceivedMessage(event);
	                })
	                .catch((reason: any) => {
	                  McaLogger.error(`${this.pre} Error Channel.conclude ${reason}`);
	                  McaLogger.warn(this.pre + 'Processing close anyway..');
	                  this.internalProcessReceivedMessage(event);
	                });
	            } catch (err) {
	              McaLogger.error(`${this.pre} Exception in Channel.conclude ${err}`);
	              McaLogger.warn(this.pre + 'Processing close anyway..');
	              this.internalProcessReceivedMessage(event);
	            }
	          }
	        }; */
	        /**
	         * This ensures the Mercury Channel is closed.
	         * This *MUST* be called for *EVERY* Chat after the Engagement has been Ended
	         * This *MUST* be called once wrap-up is complete.
	         */
	        this.closeEngagement = (command) => __awaiter$2(this, void 0, void 0, function* () {
	            mcaLogger_1$1.McaLogger.info(this.pre + 'closeEngagement ' + command);
	            this.getCommEvent(mca$1.McaMethod.closeComm, command.eventId, null, command.workType);
	            const channel = this.getChannel(command.eventId);
	            if (!channel) {
	                mcaLogger_1$1.McaLogger.error(this.pre + "Couldn't get Mercury Channel for comand: " + command);
	                // McaLogger.warn(this.pre + 'Processing close anyway..');
	                // this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    mcaLogger_1$1.McaLogger.info(this.pre + 'Invoking Channel.close for ' + command);
	                    // TODO should have some way to check if this needs invoked for example: if (channel.isConnected)
	                    channel.close()
	                        .then((response) => {
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} *Success* Channel.close ${response}`);
	                        // McaLogger.warn(this.pre + 'Processing close anyway..');
	                        // this.internalProcessReceivedMessage(event);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1$1.McaLogger.error(`${this.pre} Error Channel.close ${reason}`);
	                        // McaLogger.warn(this.pre + 'Processing close anyway..');
	                        // this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in Channel.close ${err}`);
	                    // McaLogger.warn(this.pre + 'Processing close anyway..');
	                    // this.internalProcessReceivedMessage(event);
	                }
	            }
	        });
	        /**
	         * Converts the incoming mercuryData attributes into mcaData Tokens.
	         * The well-known Mercury Attributes are Mapped Here.
	         * All other Mercury Attributes are just added to the mcaData list and may be mapped
	         * to MCA Tokens on the Server using the MCA Token Alt Name Value.
	         * @returns the outgoing mcaData object
	         */
	        this.convertMercuryData = (mercuryData, mcaData, assignmentType, method) => {
	            // Map -> Mercury Name : MCA Token
	            // const mercuryDataStr: string = JSON.stringify(mercuryData);
	            // console.log('Convert MercuryData String ' + mercuryDataStr);
	            // const mcaDataStr: string = JSON.stringify(mcaData);
	            // console.log('Convert mcaData String ' + mcaDataStr);
	            try {
	                const conversionMap = {
	                    [mercury$1.ChannelContextNameType.QUESTION]: mca$1.SystemToken.interactionDescription,
	                    [mercury$1.ChannelContextNameType.QUEUE_NAME]: mca$1.SystemToken.queueName,
	                    [mercury$1.ChannelContextNameType.OFFER_TIMEOUT]: mca$1.SystemToken.offerTimeout,
	                    [mercury$1.ChannelContextNameType.CONTACT_ID]: mca$1.SystemToken.contactId,
	                    ['appClassification']: mca$1.SystemToken.appClassification,
	                    ['applicationClassification']: mca$1.SystemToken.appClassification,
	                    ['appClass']: mca$1.SystemToken.appClassification,
	                    ['stripeCode']: mca$1.SystemToken.stripeCd
	                };
	                if (!mercuryData || mercuryData.size < 1) {
	                    mcaLogger_1$1.McaLogger.warn(`${this.pre} No Mercury Data Found!`);
	                    return;
	                }
	                let checkCustomFields = false;
	                let customFields;
	                const mercuryItems = mercuryData.keys();
	                for (const mercuryKey of mercuryItems) {
	                    const mercuryVal = mercuryData.get(mercuryKey);
	                    if (mercuryVal === null) {
	                        continue;
	                    }
	                    switch (mercuryKey) {
	                        case 'customFields':
	                            if (mercuryVal && mercuryVal.length > 0) {
	                                checkCustomFields = true;
	                                customFields = mercuryVal;
	                            }
	                            continue;
	                        case 'fusionEngagementId':
	                        case 'queueNames':
	                            // TODO Add Any Other Items that we want to filter out
	                            continue;
	                        case 'queueId':
	                            let queueFound = false;
	                            if (!mcaData[mca$1.SystemToken.queueName]) {
	                                if (this.userConfigurations.mercuryInfo.chatServerQueues) {
	                                    for (let iq = 0; iq < this.userConfigurations.mercuryInfo.chatServerQueues.length; iq++) {
	                                        const queueDesc = this.userConfigurations.mercuryInfo.chatServerQueues[iq];
	                                        const queueDescId = '' + queueDesc.id;
	                                        const queueDescName = queueDesc.name;
	                                        if (queueDescId === mercuryVal) {
	                                            mcaData[mca$1.SystemToken.queueName] = queueDescName;
	                                            queueFound = true;
	                                            break;
	                                        }
	                                    }
	                                }
	                            }
	                            if (queueFound) {
	                                continue;
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                    const convertToken = conversionMap[mercuryKey];
	                    if (convertToken) {
	                        if (convertToken === mca$1.SystemToken.contactId && (mercuryVal === '' || mercuryVal === '-1')) {
	                            mcaLogger_1$1.McaLogger.warn(`${this.pre} Found wrong contactId Value: ${mercuryKey}:${mercuryVal} - skipping conversion `);
	                            continue;
	                        }
	                        mcaData[convertToken] = mercuryVal;
	                        mcaLogger_1$1.McaLogger.log(`${this.pre} Found Mapped Mercury Value: ${mercuryKey}:${mercuryVal} -> ${convertToken} `);
	                        continue; // DEV Note: Comment this line to include the raw Mercury token as well
	                    }
	                    mcaData[mercuryKey] = mercuryVal;
	                }
	                let contextName;
	                let contextType;
	                let woName;
	                let woId;
	                let objectTypeCd;
	                let objectId;
	                let extCustJsonString;
	                if (checkCustomFields) {
	                    let confInteractionsMapperFound = false;
	                    for (let j = 0; j < customFields.length; j++) {
	                        const customField = customFields[j];
	                        if (customField && customField.name) {
	                            const convertToken = conversionMap[customField.name];
	                            if (convertToken) {
	                                mcaLogger_1$1.McaLogger.info(`${this.pre} Found Mapped Mercury Custom Value: ${customField.name}:${customField.value} -> ${convertToken} `);
	                                mcaData[convertToken] = customField.value;
	                                continue; // DEV Note: Comment this line to include the raw token as well
	                            }
	                            // McaLogger.info(this.pre + 'customField.name is ' + customField.name);
	                            // McaLogger.info(this.pre + 'customField.value is ' + customField.value);
	                            switch (customField.name) {
	                                case 'ContextObjectName':
	                                case 'incidentName':
	                                    contextName = customField.value;
	                                    break;
	                                case 'ContextObjectType':
	                                case 'incidentType':
	                                    contextType = customField.value;
	                                    break;
	                                case 'WoName':
	                                    woName = customField.value;
	                                    break;
	                                case 'WorkId':
	                                    woId = customField.value;
	                                    break;
	                                case 'ObjectTypeCd':
	                                    objectTypeCd = customField.value;
	                                    break;
	                                case 'ObjectId':
	                                    objectId = customField.value;
	                                    break;
	                                case 'extendedCustomFieldsJsonStr':
	                                    extCustJsonString = customField.value;
	                                    continue; // don't add the raw json string to the mcaData
	                                case 'INTERACTION_ID':
	                                    if (method === mca$1.McaMethod.newComm) {
	                                        if (assignmentType === 'CONFERENCE' || assignmentType === 'TRANSFER') {
	                                            // If the newCommEvent and conference offer then this is the parent interaction Id
	                                            mcaData[mca$1.SystemToken.parentInteractionId] = customField.value;
	                                            const intRefIdField = customFields.find((item) => item.name === mca$1.SystemToken.chatId);
	                                            if (intRefIdField) {
	                                                const intRefId = intRefIdField.value;
	                                                const intRefTypeId = mca$1.ChannelType.chatIntRef;
	                                                mcaData[mca$1.SystemToken.objectId] = intRefId;
	                                                mcaData[mca$1.SystemToken.objectType] = intRefTypeId;
	                                            }
	                                            mcaLogger_1$1.McaLogger.info(`${this.pre} converting interactionId to parentInteractionId for conference newComm`);
	                                            continue;
	                                        }
	                                        else {
	                                            // If the newCommEvent then this is the interaction Id to set for processEvent
	                                            mcaData[mca$1.SystemToken.interactionId] = customField.value;
	                                            continue;
	                                        }
	                                    }
	                                    break;
	                                case 'SVCMCA_INTERACTION_MAPPER':
	                                    confInteractionsMapperFound = true;
	                                    break;
	                                case 'queueNames':
	                                case 'QUEUE_NAMES':
	                                    // TODO Add Any Other Custom Items that we want to filter out
	                                    continue;
	                                case 'SVCMCA_INTERACTION_ID':
	                                    if (method === mca$1.McaMethod.newComm) {
	                                        // If the newCommEvent has an interaction id, assume this is the parentInteractionId
	                                        mcaData[mca$1.SystemToken.parentInteractionId] = customField.value;
	                                        mcaLogger_1$1.McaLogger.info(`${this.pre} converting interactionId to parentInteractionId for newComm`);
	                                        continue;
	                                    }
	                                    break;
	                                default:
	                                    break;
	                            }
	                            mcaData[customField.name] = customField.value;
	                        }
	                    }
	                    if (method === mca$1.McaMethod.newComm && assignmentType === 'CONFERENCE') {
	                        if (!confInteractionsMapperFound) {
	                            mcaData[mca$1.SystemToken.confInteractionsMapper] = JSON.stringify([]);
	                        }
	                    }
	                }
	                mcaLogger_1$1.McaLogger.info(this.pre + 'Context Name is ' + contextType);
	                mcaLogger_1$1.McaLogger.info(this.pre + 'objectTypeCd is ' + objectTypeCd);
	                mcaLogger_1$1.McaLogger.info(this.pre + 'objectId is ' + objectId);
	                if (contextName && contextType) {
	                    switch (contextType) {
	                        case 'SVC_SERVICE_REQUESTS':
	                            mcaData[mca$1.SystemToken.srNum] = contextName;
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_HRHD':
	                            mcaData[mca$1.SystemToken.srNumHrHd] = contextName;
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_ISR':
	                            mcaData[mca$1.SystemToken.isrNum] = contextName;
	                            break;
	                        case 'MKL_LEADS':
	                            mcaData[mca$1.SystemToken.leadNum] = contextName;
	                            break;
	                        // TODO Add Special Handling for other ContextObjectTypes
	                        default:
	                            break;
	                    }
	                }
	                else if (objectTypeCd && objectId) {
	                    // For NON-RT offers we don't see the contextName but, we do see the objectTypeCd/Id
	                    mcaData[mca$1.SystemToken.objectType] = objectTypeCd;
	                    mcaData[mca$1.SystemToken.objectId] = objectId;
	                    switch (objectTypeCd) {
	                        case 'SVC_SERVICE_REQUESTS':
	                            mcaData[mca$1.SystemToken.srId] = objectId;
	                            if (woName) {
	                                mcaData[mca$1.SystemToken.srNum] = woName;
	                            }
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_HRHD':
	                            mcaData[mca$1.SystemToken.srIdHrHd] = objectId;
	                            if (woName) {
	                                mcaData[mca$1.SystemToken.srNumHrHd] = woName;
	                            }
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_ISR':
	                            mcaData[mca$1.SystemToken.isrId] = objectId;
	                            if (woName) {
	                                mcaData[mca$1.SystemToken.isrNum] = woName;
	                            }
	                            break;
	                        case 'MKL_LEADS':
	                            mcaData[mca$1.SystemToken.leadId] = objectId;
	                            if (woName) {
	                                mcaData[mca$1.SystemToken.leadNum] = woName;
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                // Not sure if this is normal but, the custom fields added in chat simulator get added as a JSON String via the special
	                // custom field named: extendedCustomFieldsJsonStr. Assumes the underlying JSON only contains simple Key/Value string pairs.
	                if (extCustJsonString && extCustJsonString.trim().length > 1) {
	                    try {
	                        const extendedCustomFields = JSON.parse(extCustJsonString);
	                        for (const key of Object.keys(extendedCustomFields)) {
	                            const convertToken = conversionMap[key];
	                            const value = extendedCustomFields[key];
	                            if (convertToken) {
	                                mcaLogger_1$1.McaLogger.info(`${this.pre} Extended Custom Fields: Found Mapped Mercury Custom Value: ${key}:${value} -> ${convertToken}`);
	                                mcaData[convertToken] = value;
	                            }
	                            else {
	                                mcaData[key] = value;
	                            }
	                        }
	                    }
	                    catch (ierr) {
	                        mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in convertMercuryData, processing extendedCustomFields JSON String ${extCustJsonString} error: ${ierr}`);
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception in convertMercuryData: ${err}`);
	            }
	            return mcaData;
	        };
	        ///////////////////////////
	        // Mercury Event Handlers
	        ///////////////////////////
	        this.handleWorkOffer = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleWorkOffer: ');
	            try {
	                const dbgDetails = JSON.stringify(details);
	                mcaLogger_1$1.McaLogger.info(dbgDetails);
	            }
	            catch (err) { }
	            if (details && details instanceof mercury$1.MercuryOffer) {
	                try {
	                    let offer = details;
	                    if (offer.type && offer.type === mca$1.Constants.CHAT) {
	                        if (this.allowMcaChatAccess() === false && offer.workTypeCode && offer.workTypeCode !== 'Video') {
	                            mcaLogger_1$1.McaLogger.warn(this.pre + 'Skip Chat Offer, Chat Access is not allowed');
	                            return;
	                        }
	                        if (this.allowMcaVideoAccess() === false && offer.workTypeCode && offer.workTypeCode === 'Video') {
	                            mcaLogger_1$1.McaLogger.warn(this.pre + 'Skip Video Offer, Video Access is not allowed');
	                            return;
	                        }
	                    }
	                    if (offer.type && offer.type === mca$1.Constants.CHAT && offer.workTypeCode === 'Video') {
	                        // convert the offer from type CHAT to type Video
	                        const origOffer = offer;
	                        offer = new mercury$1.MercuryOffer(origOffer.identifier, origOffer.externalIdString, mca$1.Constants.VIDEO, origOffer.workTypeCode, origOffer.fusionChannelId, origOffer.conversationId, origOffer.created.getTime());
	                        offer.assignmentType = origOffer.assignmentType;
	                        offer.behavior = origOffer.behavior;
	                        offer.context = origOffer.context;
	                        offer.from = origOffer.from;
	                        offer.timeout = origOffer.timeout;
	                    }
	                    const commEvent = this.getCommEvent(mca$1.McaMethod.newComm, offer.identifier, null, offer.workTypeCode);
	                    this.pendingOffersMap.set(offer.identifier, offer);
	                    localStorage.setItem('pendingOffersMap', JSON.stringify(Array.from(this.pendingOffersMap.entries()), (key, value) => {
	                        if (key === 'context') {
	                            return JSON.stringify(Array.from(value.entries()));
	                        }
	                        return value;
	                    }));
	                    const contact = offer.from;
	                    const resource = contact.resource;
	                    const data = commEvent.data;
	                    if (resource) {
	                        data.inData[mca$1.SystemToken.email] = resource.emailAddress;
	                        if (!resource.name || resource.name.trim() === '') {
	                            data.inData[mca$1.SystemToken.contactName] = resource.firstName + ' ' + resource.lastName;
	                        }
	                        else {
	                            data.inData[mca$1.SystemToken.contactName] = resource.name;
	                        }
	                    }
	                    else {
	                        mcaLogger_1$1.McaLogger.error(this.pre + 'offer is missing resource');
	                    }
	                    if (!data.inData[mca$1.SystemToken.contactName] || data.inData[mca$1.SystemToken.contactName].trim() === '') {
	                        mcaLogger_1$1.McaLogger.warn(this.pre + 'Offer is missing contact name');
	                    }
	                    if (offer.type && offer.type === mca$1.Constants.VIDEO && offer.externalIdString) {
	                        data.inData.externalIdString = offer.externalIdString;
	                    }
	                    if (offer.fusionChannelId) {
	                        data.inData.fusionChannelId = offer.fusionChannelId;
	                    }
	                    data.workType = offer.workTypeCode;
	                    data.inData[mca$1.SystemToken.assignmentType] = offer.assignmentType;
	                    const contactId = resource.identifier; // TODO Check is this is the same as PartyId...
	                    const context = offer.context;
	                    let realTimeFlag = 'Y';
	                    if (context) {
	                        if (context.get('fusionEngagementId')) {
	                            data.engagementId = context.get('fusionEngagementId');
	                        }
	                        this.convertMercuryData(context, data.inData, offer.assignmentType, mca$1.McaMethod.newComm);
	                        if (data.inData.channelType === mca$1.ChannelType.none) {
	                            data.channel = 'NONE';
	                            data.channelType = mca$1.ChannelType.none;
	                        }
	                        if (data.inData.RealtimeFlag) {
	                            realTimeFlag = data.inData.RealtimeFlag;
	                        }
	                        if (data.inData[mca$1.SystemToken.appClassification]) {
	                            data.appClassification = data.inData[mca$1.SystemToken.appClassification];
	                        }
	                        if (data.inData[mca$1.SystemToken.stripeCd]) {
	                            switch (data.inData[mca$1.SystemToken.stripeCd]) {
	                                case 'ORA_SVC_HRHD':
	                                case 'ORA_SVC_ISR':
	                                    if (data.appClassification !== 'ORA_HRHD') {
	                                        mcaLogger_1$1.McaLogger.warn(this.pre + 'Forcing appClassification to ORA_HRHD for stripeCode: ' + data.inData[mca$1.SystemToken.stripeCd]);
	                                        data.appClassification = 'ORA_HRHD';
	                                    }
	                                    break;
	                                default:
	                                    break;
	                            }
	                        }
	                    }
	                    if (offer.behavior === mercury$1.WorkOfferBehaviorType.ForcedAccept || data.channelType === mca$1.ChannelType.none || realTimeFlag === 'N') {
	                        // We EXPECT the behavior to be ForcedAccept for NON-RT Work Assignements
	                        // But, since this is currently undefined we'll also assume if the channelType is NONE then we are dealing with NON-RT
	                        // Also, noticed a new flag in the customFields, RealtimeFlag, So, what the heck we'll check this also.
	                        mcaLogger_1$1.McaLogger.warn(`${this.pre} Assuming a Non-RT Assignment for notification purposes only; behavior: ${offer.behavior} channelType: ${data.channelType} realTimeFlag ${realTimeFlag}`);
	                        const actions = [{ name: mca$1.ActionName.Notify }];
	                        commEvent.actions = actions;
	                        data.notificationType = mca$1.NotificationType.nonRealtime;
	                        data.notificationCategory = offer.type;
	                        // This is a HACK becuase, the workOffer type is coming as chat ...
	                        if (!offer.type || offer.type === mca$1.Constants.CHAT) {
	                            if (data.inData[mca$1.SystemToken.objectType]) {
	                                data.notificationCategory = data.inData[mca$1.SystemToken.objectType];
	                                mcaLogger_1$1.McaLogger.warn(`${this.pre} Invalid workOffer.type ${offer.type} for NON-RealTime Assignment using objectType: ${data.notificationCategory}`);
	                            }
	                        }
	                        if (data.inData[mca$1.SystemToken.interactionDescription]) {
	                            data.notificationSubtitle = data.inData[mca$1.SystemToken.interactionDescription];
	                        }
	                        let workTypeOrig = data.inData[mca$1.SystemToken.woType];
	                        // Convert OMNI Legacy request name to routableVOName  
	                        if (workTypeOrig === mca$1.Constants.SERVICE_REQUEST) {
	                            workTypeOrig = mca$1.Constants.OMNI_SERVICE_REQUEST;
	                        }
	                        else if (workTypeOrig === mca$1.Constants.SERVICE_REQUEST_HRHD) {
	                            workTypeOrig = mca$1.Constants.OMNI_SVC_REQ_HRHD;
	                        }
	                        else if (workTypeOrig === mca$1.Constants.SERVICE_REQUEST_ISR) {
	                            workTypeOrig = mca$1.Constants.OMNI_SVC_REQ_ISR;
	                        }
	                        // assign workType first, in case we can find matching translation.
	                        let workTypeLabel = null;
	                        let workTypeLabelPlural = null;
	                        let workTypeViewable = 'N'; // Only set viewable to 'Y' when it's defined in work type
	                        const workName = data.inData[mca$1.SystemToken.woName]; // e.g. SR0000074379
	                        if (this.supportedChannels) {
	                            for (const channel of this.supportedChannels) {
	                                if (offer.workTypeCode === channel.workType) {
	                                    workTypeLabel = channel.displayName;
	                                    workTypeLabelPlural = channel.displayNamePlural;
	                                    break;
	                                }
	                            }
	                        }
	                        // Retrieve translated routable VO Name
	                        if (this.userConfigurations.routableVOInfo) {
	                            const routableVONames = this.userConfigurations.routableVOInfo;
	                            if (routableVONames && routableVONames[workTypeOrig]) {
	                                // We use routable table only if missing work type definition
	                                if (!workTypeLabel) {
	                                    workTypeLabel = routableVONames[workTypeOrig].LABEL;
	                                }
	                                if (!workTypeLabelPlural) {
	                                    workTypeLabelPlural = routableVONames[workTypeOrig].LABEL_PLURAL;
	                                }
	                                if (routableVONames[workTypeOrig].VIEWABLE) {
	                                    workTypeViewable = routableVONames[workTypeOrig].VIEWABLE;
	                                }
	                            }
	                        }
	                        // We use the woType only if both work type definitions and routable names are missing
	                        if (!workTypeLabel) {
	                            workTypeLabel = data.inData[mca$1.SystemToken.woType]; // e.g. Service Request
	                        }
	                        if (!workTypeLabelPlural) {
	                            workTypeLabelPlural = data.inData[mca$1.SystemToken.woType]; // e.g. Service Request
	                        }
	                        const stringTokens = {
	                            WORK_TYPE: workTypeLabel
	                        };
	                        const stringTokensPlural = {
	                            WORK_TYPE: workTypeLabelPlural
	                        };
	                        const title = oj$1.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokens);
	                        // const title: string = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokens) + ': ' + workName;
	                        const titlePlural = oj$1.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokensPlural);
	                        // const titlePlural: string = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokensPlural) + ': ' + workName;
	                        data.notificationIconTitle = workTypeLabel;
	                        data.notificationTitle = title;
	                        data.notificationTitlePlural = titlePlural;
	                        data.notificationViewable = workTypeViewable;
	                        this.checkAndSendNotify(commEvent, true);
	                    }
	                    else {
	                        this.internalProcessReceivedMessage(commEvent);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1$1.McaLogger.error(`${this.pre} Exeption processing WorkOffer: ${err}`);
	                }
	            }
	            else {
	                mcaLogger_1$1.McaLogger.error(this.pre + 'Invalid WORK_OFFER details', details);
	            }
	        };
	        this.handleChannelEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleChannelEvent: ' + eventName, details);
	        };
	        this.handleControlEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleControlEvent: ' + eventName, details);
	        };
	        this.handleActivityEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleActivityEvent: ' + eventName, details);
	        };
	        this.handleAvailableEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleAvailableEvent: ' + eventName);
	            try {
	                if (!details) {
	                    mcaLogger_1$1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing details`);
	                    return;
	                }
	                const mercuryStateMap = details.availability;
	                if (mercuryStateMap && mercuryStateMap.size > 0) {
	                    const keys = mercuryStateMap.keys();
	                    for (const key of keys) {
	                        const availState = mercuryStateMap.get(key);
	                        const isAvailable = availState === mercury$1.AvailabilityType.AVAILABLE;
	                        const availItem = this.getMcaChannelFromMercuryType(key);
	                        const agentState = {
	                            channelType: availItem.channelType,
	                            displayName: availItem.displayName,
	                            isAvailable,
	                            isLoggedIn: true,
	                            workType: key
	                        };
	                        mcaLogger_1$1.McaLogger.info(`${this.pre} ChannelType: ${availItem.channelType} isAvailable: ${isAvailable}`);
	                        const formattedEvent = { bubbles: true, cancelable: false, detail: agentState };
	                        const customEvent = new CustomEvent(mca$1.McaEventType.agentState, formattedEvent);
	                        this.dispatchClientEvent(customEvent);
	                        this.agentStateMap.set(key, agentState);
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception processing ${eventName} Error: ${err}`);
	            }
	        };
	        this.getChatActiveMemberCount = (channel) => {
	            let count = 0;
	            if (channel.members && channel.members.length > 0) {
	                for (let i = 0; i < channel.members.length; i++) {
	                    const member = channel.members[i];
	                    if (!member.isConnected) {
	                        continue;
	                    }
	                    count++;
	                }
	            }
	            return count;
	        };
	        this.getChatActiveEndUserCount = (channel) => {
	            let count = 0;
	            if (channel.members && channel.members.length > 0) {
	                for (let i = 0; i < channel.members.length; i++) {
	                    const member = channel.members[i];
	                    if (!member.isConnected) {
	                        continue;
	                    }
	                    if (member.role !== mercury$1.ParticipationRoleType.END_USER) {
	                        continue;
	                    }
	                    count++;
	                }
	            }
	            return count;
	        };
	        this.handleMemberEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleMemberEvent: ' + eventName);
	            try {
	                if (!details) {
	                    mcaLogger_1$1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing details`);
	                    return;
	                }
	                const engagementId = details.channelIdentifier;
	                if (!engagementId) {
	                    mcaLogger_1$1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing engagementId`);
	                    return;
	                }
	                const mercuryChannel = this.getChannel(engagementId);
	                if (!mercuryChannel) {
	                    mcaLogger_1$1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing mercuryChannel`);
	                    return;
	                }
	                let member = details.participant;
	                if (!member) {
	                    member = details.member; // member is set to a different attribute base on the event???
	                    if (!member) {
	                        mcaLogger_1$1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing participant`);
	                        return;
	                    }
	                }
	                let command = null;
	                const activeEndUserCount = this.getChatActiveEndUserCount(mercuryChannel);
	                const activeMembers = this.getChatActiveMemberCount(mercuryChannel);
	                switch (eventName) {
	                    case mercury$1.MercuryEventType.MEMBER_LEFT:
	                        if (activeEndUserCount < 1 || activeMembers < 1 || details.reason === 'AGENT_CONCLUDED') {
	                            // reason AGENT_CONCLUDED checking is a hack to solve CONFEREE not being notified of chat closed
	                            command = new mca$1.Command(mca$1.InteractionCommandName.disconnect, engagementId, null, null, null, mca$1.EventSource.mercury, mercuryChannel.workTypeCode);
	                        }
	                        else {
	                            mcaLogger_1$1.McaLogger.info(`${this.pre} Ignoring event ${eventName}, there are still multiple participants`);
	                        }
	                        break;
	                    default:
	                        mcaLogger_1$1.McaLogger.info(this.pre + 'Ignoring unhandled event: ' + eventName);
	                        break;
	                }
	                if (command) {
	                    mcaLogger_1$1.McaLogger.info(`${this.pre} Triggering disconnect for ${eventName} reason ${details.reason}`);
	                    this.invokeCommand(command);
	                }
	            }
	            catch (err) {
	                mcaLogger_1$1.McaLogger.error(`${this.pre} Exception processing ${eventName} Error: ${err}`);
	            }
	        };
	        this.handleMessageEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleMessageEvent: ' + eventName);
	            const engagementId = details.channelIdentifier;
	            const messageBody = details.body;
	            switch (eventName) {
	                case mercury$1.MercuryEventType.MESSAGE_ADDED:
	                    if (details.sender) {
	                        if (details.sender.role !== mercury$1.ResourceType.END_USER) {
	                            mcaLogger_1$1.McaLogger.info(this.pre + 'Ignoring event not generated by the END_USER  ' + eventName);
	                            break;
	                        }
	                    }
	                    // Initiate browser tab notification
	                    const event = this.getCommEvent(mca$1.McaMethod.newMessage, engagementId);
	                    let attnMessage = messageBody;
	                    if (messageBody && messageBody.length > 31) {
	                        attnMessage = messageBody.substr(0, 30);
	                    }
	                    else if (!messageBody || messageBody.trim().length < 1) {
	                        attnMessage = '...';
	                    }
	                    this.winMgr.notifyWindowForEngagement(engagementId, attnMessage, event, true);
	                    break;
	                default:
	                    mcaLogger_1$1.McaLogger.info(this.pre + 'Ignoring event: ' + eventName);
	            }
	        };
	        this.dispatchWindowEvent = (eventType, details) => {
	            const detail = details;
	            const formattedEvent = {
	                bubbles: true,
	                cancelable: false,
	                detail
	            };
	            const ne = new CustomEvent(eventType, formattedEvent);
	            window.dispatchEvent(ne);
	        };
	        this.handleConnectionErrorEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.error(`${this.pre} ==> handleConnectionErrorEvent: ${eventName} - details: ${details ? details.error : ''}`);
	            this.session = null;
	            this.loadStatus(mca$1.EventState.loaded);
	            this.dispatchWindowEvent(mca$1.McaEventType.connectionLost, details);
	        };
	        this.handleConnectionEstablishedEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(`${this.pre} ==> handleConnectionEstablishedEvent: ${eventName} - details: ${details}`);
	            this.loadStatus(mca$1.EventState.complete);
	            this.dispatchWindowEvent(mca$1.McaEventType.connectionEstablished, details);
	        };
	        this.handleUnstableConnectionEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.error(this.pre + '==> handleUnstableConnectionEvent: ' + eventName, details);
	            this.dispatchWindowEvent(mca$1.McaEventType.unstableConnection, details);
	        };
	        this.handleChatCancelEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleChatCancelEvent: ' + eventName, details);
	            const commEvent = this.getCommEvent(mca$1.McaMethod.closeComm, details.channelIdentifier, mca$1.CloseCommReason.canceled);
	            this.internalProcessReceivedMessage(commEvent);
	            this.dispatchWindowEvent(mca$1.McaEventType.removeNotifOnUi, details);
	            const offer = this.pendingOffersMap.get(commEvent.data.eventId);
	            this.cleanupOffer(offer.identifier);
	        };
	        this.handleUploadEvent = (eventName, details) => {
	            mcaLogger_1$1.McaLogger.info(this.pre + '==> handleUploadEvent: ' + eventName, details);
	        };
	        this.bundle = Object.assign({}, oj_mca_common_1$2.McaCommon.mcaCoreStrings);
	        this.properties = properties;
	        if (properties.mcaBundle) {
	            this.mcaBundle = properties.mcaBundle;
	        }
	        this.initMcaFramework();
	        mcaLogger_1$1.McaLogger.info(`${this.pre} properties.loadStatus is ` + properties.loadStatus);
	        if (properties.loadStatus) {
	            if (typeof properties.loadStatus !== 'function') {
	                properties.loadStatus = ko$2.observable(mca$1.EventState.wait);
	                mcaLogger_1$1.McaLogger.warn(`${this.pre} converting invalid property type for loadStatus `);
	            }
	            this.loadStatus = properties.loadStatus;
	        }
	        if (!this.loadStatus) {
	            mcaLogger_1$1.McaLogger.warn(`${this.pre} Missing loadStatus property!`);
	            this.loadStatus = ko$2.observable(mca$1.EventState.wait);
	        }
	        this.loadStatus.subscribe(this.loadStatusListener);
	        this.chatConfigData.subscribe(this.chatConfigListener);
	        if (properties.onMcaEvent) {
	            this.mcaEventTarget = properties.onMcaEvent;
	        }
	        if (properties.onNotifyOnEvent) {
	            this.notificationEventTarget = properties.onNotifyOnEvent;
	        }
	        if (properties.onMcaAgentStateEvent) {
	            this.agentStateEventListener = properties.onMcaAgentStateEvent;
	        }
	        if (properties.userConfigurations) {
	            this.setUserConfigurations(properties.userConfigurations);
	        }
	        // try {
	        //   const config: any = JSON.parse(componentConfig);
	        //   const version: string = config.version;
	        //   McaLogger.info(`${this.pre} <ctor> Complete, version: ${version}`);
	        // } catch (err) {
	        //   McaLogger.error(`${this.pre} <ctor> Complete, version: UNKNOWN :[${err}]`);
	        // }
	        const pendingOffers = JSON.parse(localStorage.getItem('pendingOffersMap'), (key, value) => {
	            if (key === 'context') {
	                return new Map(JSON.parse(value));
	            }
	            if (key === 'created') {
	                return new Date(value);
	            }
	            return value;
	        });
	        if (pendingOffers) {
	            pendingOffers.forEach((pendingOffer) => {
	                const mercuryOffer = pendingOffer[1];
	                this.pendingOffersMap.set(mercuryOffer.identifier, mercuryOffer);
	            });
	        }
	    }
	    getInProgressChats() {
	        return (this.session ? this.session.getChannels() : []);
	    }
	    cleanupOffer(identifier) {
	        this.pendingOffersMap.delete(identifier);
	        localStorage.setItem('pendingOffersMap', JSON.stringify(Array.from(this.pendingOffersMap.entries()), (key, value) => {
	            if (key === 'context') {
	                return JSON.stringify(Array.from(value.entries()));
	            }
	            return value;
	        }));
	    }
	}
	ojMcaMercury.McaMercuryModel = McaMercuryModel;
	// STATIC KEYS USED FOR DEV DEMOS
	McaMercuryModel.RESET_AGENT = 'clearChats';
	McaMercuryModel.CHAT_CONFIG_CACHE = 'mercuryChatConfig';

	var mcaEngageSdkConnector = {};

	var __awaiter$1 = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaEngageSdkConnector, "__esModule", { value: true });
	mcaEngageSdkConnector.McaEngageSdkModel = void 0;
	/**
	 * DEV NOTE: This file is for isolating changes required for Engage SDK Integration without any impact to the current
	 * oj-mca-mercury.ts implementation.
	 * This is a copy of the oj-mca-mercury.ts that loads engage-mercury-adapter instead of the oracle-mercury-client.
	 * All changes required for the Engage SDK should be made to this file!
	 * Any bug fixes made to the oj-mca-mercury.ts would likely also need made here!
	 */
	const mercury = require$$0$1;
	const ko$1 = knockoutLatestExports;
	const mcaLogger_1 = requireMcaLogger();
	// import { McaEngagementCommon } from 'oj-mca/common/McaEngagementCommon'; // Commented out for now until we uptake all type changes
	const mca_common_types_1 = requireMcaCommonTypes();
	const mca_engagement_manager_1$1 = mcaEngagementManager;
	const mca_mercury_copy_1$1 = mcaMercuryCopy;
	const mca_rest_helper_1 = mcaRestHelper;
	const mca_window_manager_1$1 = mcaWindowManager;
	const oj_mca_common_1$1 = requireOjMcaCommon();
	const oj = require$$8;
	var OSvCAvailableStates;
	(function (OSvCAvailableStates) {
	    OSvCAvailableStates[OSvCAvailableStates["AVAILABLE"] = 21] = "AVAILABLE";
	    OSvCAvailableStates[OSvCAvailableStates["IN_MEETING"] = 23] = "IN_MEETING";
	    OSvCAvailableStates[OSvCAvailableStates["ON_BREAK"] = 24] = "ON_BREAK";
	    OSvCAvailableStates[OSvCAvailableStates["UNAVAILABLE"] = 22] = "UNAVAILABLE";
	})(OSvCAvailableStates || (OSvCAvailableStates = {}));
	class McaEngageSdkModel {
	    constructor(properties) {
	        this.mercuryVersion = '1.0.0';
	        this.pre = '[McaEngageConnector] ';
	        this.pendingOffersMap = new Map();
	        this.activeChannelsMap = new Map();
	        this.commandQueue = new Array(); // Queue commands until Mercury Session Established
	        this.mercuryOrigin = '';
	        this.mcaBundle = null;
	        this.chatConfigCache = null;
	        this.chatConfigData = ko$1.observable();
	        this.chatConfigQueue = new Array(); // Queue config requests until the configs are retrieved
	        this.allowMcaChatAccess = ko$1.observable(false);
	        this.allowMcaAudioAccess = ko$1.observable(false);
	        this.allowMcaVideoAccess = ko$1.observable(false);
	        this.allowMcaRecordingAccess = ko$1.observable(false);
	        this.propertyChanged = (context) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} propertyChanged ${context.property} :  ${context.value}`);
	            if (!context.property) {
	                return;
	            }
	            switch (context.property) {
	                case 'userConfigurations':
	                    this.setUserConfigurations(context.value);
	                    break;
	                case 'loadStatus':
	                    let loadStatus = context.value;
	                    if (typeof context.value !== 'function') {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} converting invalid property type for loadStatus`);
	                        loadStatus = ko$1.observable(context.value);
	                    }
	                    this.loadStatus = loadStatus;
	                    this.loadStatus.subscribe(this.loadStatusListener);
	                    break; // writeback property sent to consumer
	                default:
	                    mcaLogger_1.McaLogger.warn(`${this.pre} Unhandled propertyChanged ${context.property} : ${context.value}`);
	                    break;
	            }
	        };
	        this.getBreakReasons = () => {
	            mcaLogger_1.McaLogger.info(`${this.pre} ===> getBreakReasons `);
	            const retPromise = new Promise((resolve, reject) => {
	                // TODO Need to enhance MCA API in future release
	                resolve([]);
	            });
	            return retPromise;
	        };
	        /**
	         * Async Method to retrieve all the Mercury Work Types Configured for the Current User.
	         * Originally these were only Real-Time Communication Channels but, now the Channels has been
	         * expanded to include Non-Real-Time Work Types that may not have a particular Channel association.
	         * This requires a connection to Mercury in order to retrieve the Mercury Work types configured for the current user.
	         * If this invoked before the Mercury connection is established, this will wait until the Mercury connection is established
	         * or fails.
	         * @returns Promise of Array of Mercury Work Types
	         */
	        this.getChannels = () => {
	            mcaLogger_1.McaLogger.info(`${this.pre} ===> getChannels `);
	            const retPromise = new Promise((resolve, reject) => __awaiter$1(this, void 0, void 0, function* () {
	                if (!this.supportedChannels) {
	                    const channels = new Array(0);
	                    let ftt = true;
	                    while (!this.supportedChannels) {
	                        if (this.session) {
	                            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                const channel = new mca_common_types_1.Channel(mca_common_types_1.ChannelType.chat, // channelType
	                                mca_common_types_1.EventSource.mercury, // source
	                                'Chat', // workType - ?? Constants.CHAT
	                                this.getMcaBundleString('chat'), // displayName,
	                                null, // displayNamePlural
	                                mca_common_types_1.Constants.CHAT, // channel
	                                null // networkType
	                                );
	                                channels.push(channel);
	                            }
	                            this.supportedChannels = channels;
	                        }
	                        else if (this.loadStatus() === mca_common_types_1.EventState.loaded) {
	                            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                const channel = new mca_common_types_1.Channel(mca_common_types_1.ChannelType.chat, // channelType
	                                mca_common_types_1.EventSource.mercury, // source
	                                'Chat', // workType - ?? Constants.CHAT
	                                this.getMcaBundleString('chat'), // displayName,
	                                null, // displayNamePlural
	                                mca_common_types_1.Constants.CHAT, // channel
	                                null // networkType
	                                );
	                                channels.push(channel);
	                            }
	                            this.supportedChannels = channels;
	                        }
	                        else if (this.loadStatus() === mca_common_types_1.EventState.fail) {
	                            mcaLogger_1.McaLogger.error(`${this.pre} Mercury Connection Failed: Not Returning Any Mercury Channels`);
	                            break;
	                        }
	                        else {
	                            if (ftt) {
	                                mcaLogger_1.McaLogger.info(`${this.pre} Waiting on Mercury Connection to retrieve valid Channels ...`);
	                                ftt = false;
	                            }
	                            yield oj_mca_common_1$1.McaCommon.sleep(250);
	                        }
	                    }
	                    const channelCount = (this.supportedChannels) ? this.supportedChannels.length : 0;
	                    mcaLogger_1.McaLogger.info(`${this.pre} Returning ${channelCount} Mercury Channels`);
	                    resolve(this.supportedChannels);
	                }
	                else {
	                    resolve(this.supportedChannels);
	                }
	            }));
	            return retPromise;
	        };
	        /**
	         * Async method to retrieve the Map of Mercury Work Types to Agent's Availability Status from Mercury.
	         * This waits until the Mercury Session has been established or fails since, we don't even know the
	         * Mercury Work Types until the Agent
	         * @returns Promise of Map containing Mercury Work Types to AgentStates - The AgentStates should contain the necessary detail for UI presentation.
	         */
	        this.getAgentStates = () => {
	            mcaLogger_1.McaLogger.info(`${this.pre} ===> getAgentStates`);
	            const retPromise = new Promise((resolve, reject) => __awaiter$1(this, void 0, void 0, function* () {
	                if (this.session) {
	                    // Refresh the latest states from Mercury
	                    this.agentStateMap = this.getAvailableStatesFromMercury();
	                }
	                else {
	                    if (!this.agentStateMap) {
	                        let ftt = true;
	                        while (!this.agentStateMap) {
	                            if (this.session) {
	                                this.agentStateMap = this.getAvailableStatesFromMercury();
	                                break;
	                            }
	                            else if (this.loadStatus() === mca_common_types_1.EventState.loaded) {
	                                this.agentStateMap = new Map();
	                                if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                                    const agentState = {
	                                        channel: mca_common_types_1.Constants.CHAT,
	                                        channelType: mca_common_types_1.ChannelType.chat,
	                                        displayName: this.getMcaBundleString('chat'),
	                                        isAvailable: false,
	                                        isLoggedIn: false,
	                                        workType: mca_common_types_1.Constants.CHAT
	                                    };
	                                    mcaLogger_1.McaLogger.info(`${this.pre} getAgentStates - status: loaded, WorkType: ${mca_common_types_1.Constants.CHAT}, isAvailable: false`);
	                                    this.agentStateMap.set(mca_common_types_1.Constants.CHAT, agentState);
	                                }
	                            }
	                            else if (this.loadStatus() === mca_common_types_1.EventState.fail) {
	                                mcaLogger_1.McaLogger.error(`${this.pre} Mercury Connection Failed: Not Returning Any Mercury Channels`);
	                                this.agentStateMap = new Map();
	                                break;
	                            }
	                            else {
	                                if (ftt) {
	                                    mcaLogger_1.McaLogger.info(`${this.pre} Waiting on Mercury Connection to retrieve valid Channels ...`);
	                                    ftt = false;
	                                }
	                                yield oj_mca_common_1$1.McaCommon.sleep(250);
	                            }
	                        }
	                    }
	                }
	                const channelCount = (this.agentStateMap) ? this.agentStateMap.size : 0;
	                mcaLogger_1.McaLogger.info(`${this.pre} Returning ${channelCount} Mercury Channels`);
	                resolve(this.agentStateMap);
	            }));
	            return retPromise;
	        };
	        /**
	         * Invoke a Command on Mercury.
	         * Command Responses are returned via the {@linkcode Command} responseCallback
	         */
	        this.invokeCommand = (command) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} ===> invokeCommand: ${command}`);
	            if (!command || !command.method) {
	                mcaLogger_1.McaLogger.warn(`${this.pre} Ignoring command, missing method`);
	                return;
	            }
	            if (command.target && !this.checkTarget(command.target)) {
	                mcaLogger_1.McaLogger.info(`${this.pre} Ignoring command for target: ${command.target}`);
	                return;
	            }
	            if (command.channelType && !this.checkChannel(command.channelType)) {
	                mcaLogger_1.McaLogger.info(`${this.pre} Ignoring command, not supported by this provider: ${command.channelType}`);
	                return;
	            }
	            const outData = {};
	            const eventId = command.eventId ? command.eventId : null;
	            const commandResp = new mca_common_types_1.CommandResponse(command.command, mca_common_types_1.Result.success, command.commandId, eventId, outData, command.channelType, null, command.workType);
	            if (this.loadStatus() === mca_common_types_1.EventState.fail) {
	                if (command.responseCallback !== undefined) {
	                    commandResp.result = mca_common_types_1.Result.error;
	                    outData[mca_common_types_1.Constants.ERR_MSG] = 'CONNECT_FAILED';
	                    mcaLogger_1.McaLogger.info(`${this.pre} loadstatus is failed. Error message show connect failed`);
	                    // command.responseCallback = (a: mca.CommandResponse) => {a = commandResp; };
	                    command.responseCallback(commandResp);
	                }
	                mcaLogger_1.McaLogger.info(`${this.pre} Ignoring command, Mercury Connection Failed: ${command}`);
	                return;
	            }
	            else if (this.loadStatus() !== mca_common_types_1.EventState.complete) {
	                mcaLogger_1.McaLogger.warn(`${this.pre} Mercury not connected`);
	                this.invokeCommandAsync(command);
	                return;
	            }
	            let responseRequired = false;
	            switch (command.command) {
	                case mca_common_types_1.AgentCommandName.makeAvailable:
	                case mca_common_types_1.AgentCommandName.makeUnavailable:
	                    this.setAvailability(command);
	                    break;
	                case mca_common_types_1.AgentCommandName.getChannelPrefs:
	                    if (this.chatConfigData()) {
	                        outData[mca_common_types_1.CommandResponseKeys.channelPrefs] = this.chatConfigData();
	                        responseRequired = true;
	                    }
	                    else {
	                        this.chatConfigQueue.push(command);
	                        return;
	                    }
	                    break;
	                case mca_common_types_1.AgentCommandName.getVideoConfig:
	                    if (this.userConfigurations.mercuryInfo.mercuryLXIntegrationEnabled) {
	                        outData[mca_common_types_1.CommandResponseKeys.lxVideoConfig] = {
	                            integrationEnabled: true,
	                            topologyConfig: this.userConfigurations.mercuryInfo.mercuryLXTopologyConfig
	                        };
	                        responseRequired = true;
	                    }
	                    else {
	                        outData[mca_common_types_1.CommandResponseKeys.lxVideoConfig] = {
	                            integrationEnabled: false,
	                            topologyConfig: {}
	                        };
	                        responseRequired = true;
	                    }
	                    break;
	                case mca_common_types_1.InteractionCommandName.accept:
	                    this.acceptOffer(command);
	                    break;
	                case mca_common_types_1.InteractionCommandName.autoAccept:
	                    this.acceptOffer(command, mca_mercury_copy_1$1.OfferResponseType.AUTO);
	                    break;
	                case mca_common_types_1.InteractionCommandName.forceAccept:
	                    this.acceptOffer(command, mca_mercury_copy_1$1.OfferResponseType.FORCED);
	                    break;
	                case mca_common_types_1.InteractionCommandName.reject:
	                    this.rejectOffer(command);
	                    break;
	                case mca_common_types_1.InteractionCommandName.chatOfferTimeout:
	                    const offer = this.pendingOffersMap.get(command.eventId);
	                    if (offer != null) {
	                        try {
	                            this.session.timeoutOffer(offer).then(() => {
	                                this.disconnectWithReasonCode(command, mca_common_types_1.CloseCommReason.timeout);
	                            }).catch(() => {
	                                this.disconnectWithReasonCode(command, mca_common_types_1.CloseCommReason.timeout);
	                            });
	                        }
	                        catch (e) {
	                            mcaLogger_1.McaLogger.error(`${this.pre} Exception in timeout offer ${e}`);
	                            this.disconnectWithReasonCode(command, mca_common_types_1.CloseCommReason.timeout);
	                        }
	                        this.cleanupOffer(offer.identifier);
	                    }
	                    break;
	                case mca_common_types_1.InteractionCommandName.disconnect:
	                    this.concludeEngagement(command);
	                    // this.closeEngagement(command);
	                    break;
	                case mca_common_types_1.InteractionCommandName.transferToQueue:
	                    // Nothing to be done here
	                    this.transferedEngagement(command);
	                    break;
	                case mca_common_types_1.InteractionCommandName.wrapupComplete:
	                    // 9-16-21 Once again Closing chat since this is no longer done by Chat UI
	                    this.closeEngagement(command);
	                    break;
	                case mca_common_types_1.InteractionCommandName.getCommunicationChannel:
	                    const mercuryChannel = this.getChannel(command.eventId);
	                    if (!mercuryChannel) {
	                        commandResp.result = mca_common_types_1.Result.error;
	                        outData[mca_common_types_1.Constants.ERR_MSG] = 'Channel Not found: ' + command.eventId;
	                        mcaLogger_1.McaLogger.error(`${this.pre} Mercury Channel Not Found for command ${command}`);
	                    }
	                    else {
	                        commandResp.realTimeCommChannel = mercuryChannel;
	                        mcaLogger_1.McaLogger.info(`${this.pre} *Success* Returning Mercury Channel for command: ${command}`);
	                    }
	                    responseRequired = true;
	                    break;
	                default:
	                    mcaLogger_1.McaLogger.warn(`${this.pre} No Command Handler Defined for Command ${command}`);
	                    break;
	            }
	            if (responseRequired && command.responseCallback !== undefined) {
	                command.responseCallback(commandResp);
	            }
	        };
	        this.getMercurySession = () => {
	            return this.session;
	        };
	        this.sendProviderResponse = (response) => {
	            if (response && response.method && response.eventSource === mca_common_types_1.EventSource.mercury) {
	                mcaLogger_1.McaLogger.info(`${this.pre} Send Response for: ${response.method}`);
	                let command = null;
	                let sendToMercury = false;
	                switch (response.method) {
	                    case mca_common_types_1.McaMethod.newComm:
	                    case mca_common_types_1.McaMethod.startComm:
	                    case mca_common_types_1.McaMethod.updateComm:
	                        sendToMercury = true;
	                        break;
	                    case mca_common_types_1.McaMethod.onDataUpdate:
	                        if (response.outData && response.outData != null) {
	                            sendToMercury = true;
	                            if (response.outData.updateType === mca_common_types_1.UpdateType.wrapUp) {
	                                command = new mca_common_types_1.Command(mca_common_types_1.InteractionCommandName.wrapupComplete, response.eventId, null, null, null, null, response.workType);
	                            }
	                        }
	                        break;
	                }
	                if (command) {
	                    if (command.command === mca_common_types_1.InteractionCommandName.wrapupComplete) {
	                        // Engagement component is no longer calling closeChannel
	                        // So we will once again do so
	                        this.invokeCommand(command);
	                    }
	                    else {
	                        mcaLogger_1.McaLogger.info(`${this.pre} NO LONGER Triggering ${command} for ${response.method}`);
	                        // Engagement Component Calls omnichannel-chat-container.startWrapup now.
	                        // this.invokeCommand(command);
	                    }
	                }
	                if (sendToMercury) {
	                    this.sendToMercury(response);
	                }
	            }
	        };
	        this.sendToMercury = (response) => {
	            mcaLogger_1.McaLogger.log(`${this.pre} Response sent to Mercury`, response);
	            if (!response.outData) {
	                return;
	            }
	            const mercuryChannel = this.getChannel(response.eventId);
	            if (!mercuryChannel) {
	                return;
	            }
	            if (!mercuryChannel.context) {
	                return;
	            }
	            if (!response.method) {
	                return;
	            }
	            switch (response.method) {
	                case mca_common_types_1.McaMethod.newComm:
	                case mca_common_types_1.McaMethod.startComm: // the channel doesn't exist during newComm response processing
	                case mca_common_types_1.McaMethod.updateComm:
	                    break;
	                default:
	                    return;
	            }
	            mcaLogger_1.McaLogger.info(`${this.pre} sendToMercury`);
	            try {
	                // Contact Details requires special handling
	                let updateParticipant = false;
	                let osvcChatEnabled = false;
	                const osvcContextItemList = new Array();
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    osvcChatEnabled = true;
	                }
	                if (response.outData[mca_common_types_1.SystemToken.firstName]) {
	                    const firstName = mercuryChannel.context.get("firstName" /* mercury.ChannelContextNameType.FIRST_NAME */);
	                    if (response.outData[mca_common_types_1.SystemToken.firstName] !== firstName) {
	                        updateParticipant = true;
	                        const firstNameContext = new mercury.ChannelContextItem();
	                        firstNameContext.name = "firstName" /* mercury.ChannelContextNameType.FIRST_NAME */;
	                        firstNameContext.value = response.outData[mca_common_types_1.SystemToken.firstName];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(firstNameContext);
	                        }
	                    }
	                }
	                if (response.outData[mca_common_types_1.SystemToken.lastName]) {
	                    const lastName = mercuryChannel.context.get("lastName" /* mercury.ChannelContextNameType.LAST_NAME */);
	                    if (response.outData[mca_common_types_1.SystemToken.lastName] !== lastName) {
	                        updateParticipant = true;
	                        const lastNameContext = new mercury.ChannelContextItem();
	                        lastNameContext.name = "lastName" /* mercury.ChannelContextNameType.LAST_NAME */;
	                        lastNameContext.value = response.outData[mca_common_types_1.SystemToken.lastName];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(lastNameContext);
	                        }
	                    }
	                }
	                if (response.outData[mca_common_types_1.SystemToken.contactId]) {
	                    const contactId = mercuryChannel.context.get("contactId" /* mercury.ChannelContextNameType.CONTACT_ID */);
	                    if (response.outData[mca_common_types_1.SystemToken.contactId] !== contactId) {
	                        const contactIdContext = new mercury.ChannelContextItem();
	                        contactIdContext.name = "contactId" /* mercury.ChannelContextNameType.CONTACT_ID */;
	                        contactIdContext.value = response.outData[mca_common_types_1.SystemToken.contactId];
	                        if (osvcChatEnabled) {
	                            osvcContextItemList.push(contactIdContext);
	                        }
	                    }
	                }
	                if (updateParticipant) {
	                    // Ensure the the Visitor name is displayed correctly on the Chat UI
	                    const participant = this.getVisitor(mercuryChannel);
	                    if (participant) {
	                        if (participant.resource) {
	                            const hr = participant.resource;
	                            if (response.outData[mca_common_types_1.SystemToken.firstName]) {
	                                hr.firstName = response.outData[mca_common_types_1.SystemToken.firstName];
	                            }
	                            if (response.outData[mca_common_types_1.SystemToken.lastName]) {
	                                hr.lastName = response.outData[mca_common_types_1.SystemToken.lastName];
	                            }
	                        }
	                        // Removed 11-23-20
	                        // participant.refreshName();
	                    }
	                }
	                // All other MCA Tokens will be added generically as customFields
	                const customFieldsName = 'customFields';
	                let customFields = mercuryChannel.context.get(customFieldsName);
	                if (!customFields) {
	                    customFields = new Array();
	                }
	                const tmpMap = new Map();
	                for (let i = 0; i < customFields.length; i++) {
	                    tmpMap.set(customFields[i].name, customFields[i]);
	                }
	                for (const key of Object.keys(response.outData)) {
	                    if (!response.outData.hasOwnProperty(key)) {
	                        continue;
	                    }
	                    if (tmpMap.has(key)) {
	                        if (tmpMap.get(key) === response.outData[key]) {
	                            continue;
	                        }
	                    }
	                    if (typeof response.outData[key] !== 'string') {
	                        continue;
	                    }
	                    switch (key) {
	                        case mca_common_types_1.SystemToken.contactId:
	                        case mca_common_types_1.SystemToken.firstName:
	                        case mca_common_types_1.SystemToken.lastName:
	                        case mca_common_types_1.SystemToken.contactName:
	                        case mca_common_types_1.SystemToken.accountId:
	                        case mca_common_types_1.SystemToken.interactionId:
	                        case mca_common_types_1.SystemToken.leadId:
	                        case mca_common_types_1.SystemToken.leadName:
	                        case mca_common_types_1.SystemToken.bypassCustomerVerification:
	                            const contextItem = new mercury.ChannelContextItem();
	                            contextItem.name = key;
	                            contextItem.value = response.outData[key];
	                            if (!contextItem.value || contextItem.value.trim().length < 1) {
	                                // 03-24-22 SVC-218408 Fix
	                                break;
	                            }
	                            mcaLogger_1.McaLogger.info(`${this.pre} Updating mercuryChannel Context ${key}:${response.outData[key]}`);
	                            if (osvcChatEnabled) {
	                                osvcContextItemList.push(contextItem);
	                            }
	                            break;
	                        case mca_common_types_1.SystemToken.confInteractionsMapper:
	                            let interactionsMapper;
	                            try {
	                                interactionsMapper = JSON.parse(response.outData[key]);
	                            }
	                            catch (errIM) {
	                                mcaLogger_1.McaLogger.warn(`${this.pre} Parsing while updating mercuryChannel Context ${key} failed - will be initialized - err:${errIM}`);
	                            }
	                            const contextInteractionsMapper = new mercury.ChannelContextItem();
	                            contextInteractionsMapper.name = key;
	                            if (interactionsMapper) {
	                                let agentFound = false;
	                                for (let i = 0; i < interactionsMapper.length; i++) {
	                                    if (interactionsMapper[i].agentId === this.userConfigurations.userDetails.agentId) {
	                                        agentFound = true;
	                                        break;
	                                    }
	                                }
	                                if (!agentFound) {
	                                    interactionsMapper.push({
	                                        agentId: this.userConfigurations.userDetails.agentId,
	                                        interactionId: response.outData[mca_common_types_1.SystemToken.interactionId]
	                                    });
	                                }
	                                else {
	                                    break;
	                                }
	                            }
	                            else {
	                                interactionsMapper = [];
	                                interactionsMapper.push({
	                                    agentId: this.userConfigurations.userDetails.agentId,
	                                    interactionId: response.outData[mca_common_types_1.SystemToken.interactionId]
	                                });
	                            }
	                            contextInteractionsMapper.value = JSON.stringify(interactionsMapper);
	                            if (osvcChatEnabled) {
	                                osvcContextItemList.push(contextInteractionsMapper);
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                if (osvcChatEnabled && osvcContextItemList.length > 0) {
	                    mercuryChannel.modifyProperties(osvcContextItemList);
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.warn(`${this.pre} Error sending Mercury Updates ${err}`);
	            }
	        };
	        this.getMcaBundleString = (key) => {
	            // Commented out for now until we uptake all type changes
	            // return McaEngagementCommon.getMcaBundleString(key, this.bundle, this.mcaBundle, this.pre);
	            let returnString = null;
	            if (this.mcaBundle) {
	                returnString = this.mcaBundle[key];
	            }
	            if (!returnString) {
	                if (this.bundle[key]) {
	                    returnString = this.bundle[key];
	                }
	                else {
	                    mcaLogger_1.McaLogger.error(this.pre + 'unable to find mca translation bundle with String key ==> ' + key);
	                    returnString = '*' + key;
	                }
	            }
	            return returnString;
	        };
	        /**
	         * Ensure the Mercury Session is cleaned up when the window is closed
	         */
	        this.unloadListener = (event) => {
	            const mercuryNavigationBehavior = localStorage.getItem('mercuryNavigationBehavior') || 'keepalive';
	            if (this.session) {
	                if (mercuryNavigationBehavior === 'keepalive') {
	                    try {
	                        this.session.setActivityStatus(0);
	                    }
	                    catch (error) {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} Exception invoking Session.setActivityStatus ${error}`);
	                    }
	                }
	                else {
	                    mcaLogger_1.McaLogger.info(this.pre + 'Ending Mercury Session');
	                    try {
	                        this.session
	                            .end(true)
	                            .then(() => {
	                            mcaLogger_1.McaLogger.info(`${this.pre} *Success* Session.end `);
	                        })
	                            .catch((err) => {
	                            mcaLogger_1.McaLogger.warn(`${this.pre} Exception in Session.end ${err}`);
	                        });
	                    }
	                    catch (oerr) {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} Exception invoking Session.end ${oerr}`);
	                    }
	                }
	            }
	        };
	        /**
	         * Retrieve the current Agent's Availability states for all eligible Mercury Channels
	         * @returns empty Map is returned if no Mercury Channels are configured for the current user
	         */
	        this.getAvailableStatesFromMercury = () => {
	            mcaLogger_1.McaLogger.info(`${this.pre} Retrieving AvailabilityMap from Mercury`);
	            const agentStateMap = new Map();
	            try {
	                const mercuryStateMap = this.session.availability;
	                // const mercuryWorkTypeDefinitionMap: Map<string, any> = this.session.workTypeDefinition;
	                if (mercuryStateMap && mercuryStateMap.size > 0) {
	                    const keys = mercuryStateMap.keys();
	                    for (const key of keys) {
	                        const availState = mercuryStateMap.get(key);
	                        const isAvailable = availState === mercury.AvailabilityType.AVAILABLE;
	                        if (this.userConfigurations && this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                            if (key === mca_common_types_1.Constants.CHAT) {
	                                const agentState = {
	                                    channel: mca_common_types_1.Constants.CHAT,
	                                    channelType: mca_common_types_1.ChannelType.chat,
	                                    displayName: this.getMcaBundleString('chat'),
	                                    isAvailable,
	                                    isLoggedIn: true,
	                                    workType: mca_common_types_1.Constants.CHAT
	                                };
	                                mcaLogger_1.McaLogger.info(`${this.pre} WorkType: ${agentState.workType} isAvailable: ${isAvailable}`);
	                                agentStateMap.set(agentState.workType, agentState);
	                                if (isAvailable && this.session) {
	                                    this.session.requestAssignment().then(() => {
	                                        mcaLogger_1.McaLogger.info(`${this.pre} *Success* requestAssignment `);
	                                    }).catch((reason) => {
	                                        mcaLogger_1.McaLogger.error(`${this.pre} Error in requestAssignment ${reason}`);
	                                    });
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Error retrieving Mercury session.availability ${err}`);
	            }
	            return agentStateMap;
	        };
	        this.mapMercuryCategoryToChannelType = (category) => {
	            if (category === mca_common_types_1.Constants.CHAT) {
	                return mca_common_types_1.ChannelType.chat;
	            }
	            else if (category === mca_common_types_1.Constants.VIDEO) {
	                return mca_common_types_1.ChannelType.video;
	            }
	            else {
	                return mca_common_types_1.ChannelType.none;
	            }
	        };
	        /**
	         * ONLY FOR DEV USE TO CLEAR OUTSTANDING AGENT CHATS
	         * ** DEV NOTE ** To Clear Chats Manually Add the following key to your Local Storage
	         * clearChats = y
	         * Then Reload Your Page
	         * Be Sure to Reset the clearChats value to 'n' or delete the key before running any tests
	         */
	        this.devClearAgentChats = () => {
	            const resetAgent = localStorage.getItem(McaEngageSdkModel.RESET_AGENT);
	            if (!resetAgent) {
	                return;
	            }
	            if (resetAgent === 'y' || resetAgent === 'Y') {
	                try {
	                    const chats = this.session.getChannels();
	                    if (chats && chats.length > 0) {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} *** Found ${chats.length} Chats to Clear ***`);
	                        for (let i = 0; i < chats.length; i++) {
	                            const chat = chats[i];
	                            chat
	                                .conclude()
	                                .then((response) => {
	                                mcaLogger_1.McaLogger.info(this.pre + 'Chat Ended' + chat.identifier);
	                                chat
	                                    .close()
	                                    .then((closeResponse) => {
	                                    mcaLogger_1.McaLogger.info(this.pre + 'Chat Closed' + chat.identifier);
	                                })
	                                    .catch((reason) => {
	                                    mcaLogger_1.McaLogger.error(`${this.pre} Error closing chat ${reason}`);
	                                });
	                            })
	                                .catch((reason) => {
	                                mcaLogger_1.McaLogger.error(`${this.pre} Error concluding chat ${reason}`);
	                            });
	                        }
	                    }
	                    else {
	                        mcaLogger_1.McaLogger.info(`${this.pre} No Chats to clear`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} exception clearing agent's chats ${err}`);
	                }
	            }
	        };
	        /**
	         * Create a new Mercury Session
	         */
	        this.connect = () => {
	            if (this.loadStatus() === mca_common_types_1.EventState.process || this.loadStatus() === mca_common_types_1.EventState.complete) {
	                mcaLogger_1.McaLogger.info(`${this.pre} Mercury Session already connecting`);
	                return;
	            }
	            if (this.userConfigurations.mercuryInfo.chatEnabled) {
	                this.loadStatus(mca_common_types_1.EventState.process);
	                if (this.session && this.session.availability.get('Chat') === 'Available') {
	                    this.session
	                        .end(true)
	                        .then(() => {
	                        mcaLogger_1.McaLogger.info(`${this.pre} *Success* Session.end `);
	                        this.session = null;
	                        this.createOsvcSession();
	                    })
	                        .catch((err) => {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} Exception in Session.end ${err}`);
	                        // just reset sesion variable and continue
	                        this.session = null;
	                        this.createOsvcSession();
	                    });
	                }
	                else {
	                    this.createOsvcSession();
	                }
	            }
	            else {
	                // this is failed state, will not attempt reconnection
	                this.loadStatus(mca_common_types_1.EventState.fail);
	            }
	        };
	        this.createOsvcSession = () => {
	            var _a, _b;
	            mcaLogger_1.McaLogger.info(`${this.pre} start createOsvcSession`);
	            const jwt = this.userConfigurations.mercuryInfo.chatServerClientToken;
	            const config = {
	                accountId: this.userConfigurations.mercuryInfo.chatServerAccountId,
	                delayGetMessages: false,
	                endPoint: this.userConfigurations.mercuryInfo.chatServerEndPoint,
	                pool: this.userConfigurations.mercuryInfo.chatServerPool
	            };
	            if (this.userConfigurations.mercuryInfo.chatServerQueues) {
	                config.queues = this.userConfigurations.mercuryInfo.chatServerQueues;
	            }
	            if (typeof this.userConfigurations.mercuryInfo.maxSessions !== 'undefined') {
	                config.maxSessions = this.userConfigurations.mercuryInfo.maxSessions;
	            }
	            if (typeof this.userConfigurations.mercuryInfo.maxActiveSessions !== 'undefined') {
	                config.maxActiveSessions = this.userConfigurations.mercuryInfo.maxActiveSessions;
	            }
	            const tmpEngagement = this.winMgr.getActiveEngagement();
	            if (tmpEngagement && (tmpEngagement.engagementSource === mca_common_types_1.EventSource.mercury)) {
	                if (!tmpEngagement.eventMap.closeCommEvent) {
	                    // SVC-199025 - Tell chat-client to wait for the refreshMessages call before starting to poll
	                    mcaLogger_1.McaLogger.warn(`${this.pre} Chat Config set delayGetMessages`);
	                    const engWindow = this.winMgr.getWindowForEngagement(tmpEngagement.engagementId);
	                    config.delayGetMessages = (engWindow === null || engWindow === void 0 ? void 0 : engWindow.name) === window.name;
	                }
	            }
	            if (localStorage.getItem(oj_mca_common_1$1.McaCommon.MCA_LOCAL_DEBUG_MODE_KEY) === 'Y') {
	                config.debugEnabled = 'Y';
	            }
	            else {
	                config.debugEnabled = (_a = this.userConfigurations.userDetails) === null || _a === void 0 ? void 0 : _a.debugMode;
	            }
	            try {
	                /** sjmD <TODO> Test Engage SDK Configs from Properties */
	                mcaLogger_1.McaLogger.warn(`${this.pre} using Engage SDK instead of Mercury Client Lib!`);
	                let engageSdkConfig = {
	                    'cdnHost': null,
	                    'cdnPath': null,
	                    'distributionChannel': null,
	                    'overrideUri': null,
	                    'tenancyRegion': null,
	                    'versionToken': null
	                };
	                if ((_b = this.userConfigurations.mercuryInfo) === null || _b === void 0 ? void 0 : _b.engageConfig) {
	                    engageSdkConfig = this.userConfigurations.mercuryInfo.engageConfig;
	                    if (typeof engageSdkConfig.tenancyRegion === 'undefined') {
	                        engageSdkConfig.tenancyRegion = null;
	                    }
	                    if (typeof engageSdkConfig.distributionChannel === 'undefined') {
	                        engageSdkConfig.distributionChannel = null;
	                    }
	                    if (typeof engageSdkConfig.versionToken === 'undefined') {
	                        engageSdkConfig.versionToken = null;
	                    }
	                    if (typeof engageSdkConfig.cdnHost === 'undefined') {
	                        engageSdkConfig.cdnHost = null;
	                    }
	                    if (typeof engageSdkConfig.cdnPath === 'undefined') {
	                        engageSdkConfig.Path = null;
	                    }
	                    if (typeof engageSdkConfig.overrideUri === 'undefined') {
	                        engageSdkConfig.overrideUri = null;
	                    }
	                }
	                else {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Missing Engage SDK Configs!`);
	                }
	                if ((!engageSdkConfig.cdnHost && !engageSdkConfig.cdnPath) && !engageSdkConfig.overrideUri) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} Deriving Engage SDK Host/Path from engage-mercury-adapter!`);
	                    // Adapter: https://static.oracle.com/cdn/omnicn/engage/0.2.49/engage-mercury-adapter
	                    // SDK:     https://static.oracle.com/cdn/omnicn/engage/0.2.49/engage-sdk.js
	                    const engageAdapterPath = oj_mca_common_1$1.McaCommon.getRequirePath('engage-mercury-adapter');
	                    if (!engageAdapterPath) {
	                        mcaLogger_1.McaLogger.error(`${this.pre} engage-mercury-adapter Path Not Found!`);
	                    }
	                    else {
	                        const engageSdkPath = engageAdapterPath.replace('engage-mercury-adapter', 'engage-sdk.js');
	                        try {
	                            const engageSdkUrl = new URL(engageSdkPath);
	                            mcaLogger_1.McaLogger.info(`${this.pre} Setting Engage SDK cdnHost: ${engageSdkUrl.origin} cdnPath: ${engageSdkUrl.pathname}`);
	                            engageSdkConfig.cdnHost = engageSdkUrl.origin;
	                            engageSdkConfig.cdnPath = engageSdkUrl.pathname;
	                        }
	                        catch (err) {
	                            mcaLogger_1.McaLogger.error(`${this.pre} Failed to construct URL from ${engageSdkPath}`);
	                        }
	                    }
	                }
	                config.sdkLocation = engageSdkConfig;
	                mcaLogger_1.McaLogger.info(`${this.pre} Opening OSVC Session ${config.endPoint}`);
	                mercury.Session.create(jwt, config, true)
	                    .then((session) => {
	                    mcaLogger_1.McaLogger.info(`${this.pre} *Success* OSVC Session Created with account: ${config.accountId} server\n ${config.endPoint}`);
	                    this.session = session;
	                    this.registerMercuryListeners(); // Make sure to register the listeners 1st before updating our loadStatus
	                    this.initChatConfigs(config);
	                    this.loadStatus(mca_common_types_1.EventState.complete);
	                    this.devClearAgentChats();
	                    if (config && config.endPoint) {
	                        try {
	                            const url = new URL(config.endPoint);
	                            const origin = url.origin;
	                            if (origin) {
	                                this.mercuryOrigin = origin;
	                            }
	                        }
	                        catch (err) {
	                            // nothing to do here, if endpoint malformed it probably errored earlier
	                        }
	                    }
	                })
	                    .catch((reason) => {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Error Opening OSVC Session: ${reason}`);
	                    this.session = null;
	                    this.loadStatus(mca_common_types_1.EventState.loaded);
	                    this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionLost, { reason });
	                });
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Error Creating OSVC Session ${err}`);
	                this.session = null;
	                this.loadStatus(mca_common_types_1.EventState.loaded);
	                this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionLost, { reason: err });
	            }
	        };
	        /**
	         * Disables Mercury in cached fetchUserEventConfiguration to prevent loading this component for the remainder of
	         * this user's session.
	         * This should be called if Mercury returns an errorCondition == 'RESOURCE_NOT_FOUND'
	         * TODO - KEEP THIS ???
	         */
	        this.disableMercury = (reason) => {
	            // TODO - Update to McaEngagementCommon when we uptake all type changes
	            const endPoint = oj_mca_common_1$1.McaCommon.getApiGroupMultiChannelAdapterEvents() + mca_common_types_1.McaEventName.fetchUserEventConfiguration;
	            const request = new mca_rest_helper_1.McaRestHelper(endPoint, 'application/vnd.oracle.adf.action+json');
	            mcaLogger_1.McaLogger.info(this.pre + 'Invoking McaRestHelper: ' + endPoint);
	            request.fetch().then((result) => {
	                try {
	                    if (result && typeof result === 'string') {
	                        result = JSON.parse(result);
	                        result.mercuryInfo.chatEnabled = 'N';
	                        result.mercuryInfo.errorCd = reason.errorCondition;
	                        result = JSON.stringify(result);
	                        request.manualCacheData(result);
	                        mcaLogger_1.McaLogger.warn(`${this.pre} Disabled Mercury for Session`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.warn(this.pre + 'Error disabling mercury in cache');
	                    mcaLogger_1.McaLogger.warn(err);
	                }
	            })
	                .catch((err) => {
	            });
	        };
	        this.initChatConfigs = (config) => {
	            try {
	                if (this.chatConfigData()) {
	                    return;
	                }
	                mcaLogger_1.McaLogger.info(`${this.pre} Retrieving Chat Configurations `);
	                this.chatConfigCache
	                    .fetch()
	                    .then((chatConfig) => {
	                    if (chatConfig) {
	                        mcaLogger_1.McaLogger.info(`${this.pre} Successfully retrieved Chat Configurations from cache`);
	                        // convert cached object into a Map
	                        const chatConfigMap = new Map();
	                        for (const key of Object.keys(chatConfig)) {
	                            if (chatConfig.hasOwnProperty(key)) {
	                                chatConfigMap.set(key, chatConfig[key]);
	                            }
	                        }
	                        this.chatConfigData(chatConfigMap);
	                    }
	                    else {
	                        this.getChatConfigsFromMercury(config);
	                    }
	                })
	                    .catch((reason) => {
	                    // This is expected the 1st time following a new session creation
	                    mcaLogger_1.McaLogger.info(`${this.pre} Unable to retrieve chatConfigs from cache`);
	                    this.getChatConfigsFromMercury(config);
	                });
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception Getting Mercury chatConfigs from cache ${err}`);
	                this.getChatConfigsFromMercury(config);
	            }
	        };
	        this.getChatConfigsFromMercury = (config) => {
	            try {
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    mcaLogger_1.McaLogger.info(`${this.pre} getChatConfigs for OSvC`);
	                    const chatConfig = new Map();
	                    const userPreferences = 'userPreferences';
	                    if (window[userPreferences]) {
	                        for (const key of Object.keys(window[userPreferences])) {
	                            if (typeof window[userPreferences][key] === 'string' && window[userPreferences].hasOwnProperty(key)) {
	                                chatConfig.set(key, window[userPreferences][key]);
	                            }
	                        }
	                    }
	                    this.chatConfigData(chatConfig);
	                    // Store data in cache as an object
	                    const cacheData = {};
	                    for (const key of chatConfig.keys()) {
	                        cacheData[key] = chatConfig.get(key);
	                    }
	                    this.chatConfigCache.manualCacheData(cacheData);
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception retrieving chatConfigs ${err}`);
	                this.chatConfigData(new Map());
	            }
	        };
	        /**
	         * Adds the listeners to Mercury Engagement Events for the given Mercury Channel
	         * Note: A Mercury Channel is akin to an MCA Engagement
	         */
	        this.registerListenersForMercuryChannel = (mercuryChannel) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} Registering Listeners for mercuryChannel: ${mercuryChannel}`);
	            try {
	                mercuryChannel.on(mercury.MercuryEventType.MESSAGE_ADDED, this.handleMessageEvent);
	                mercuryChannel.on(mercury.MercuryEventType.MESSAGE_REMOVED, this.handleMessageEvent);
	                mercuryChannel.on(mercury.MercuryEventType.MESSAGE_UPDATED, this.handleMessageEvent);
	                mercuryChannel.on(mercury.MercuryEventType.MEMBER_LEFT, this.handleMemberEvent);
	                mercuryChannel.on(mercury.MercuryEventType.MEMBER_JOINED, this.handleMemberEvent);
	                mercuryChannel.on(mercury.MercuryEventType.MEMBER_UPDATED, this.handleMemberEvent);
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Exception Registering listeners for Mercury Channel: ' + mercuryChannel + ' Error: ' + err);
	            }
	        };
	        this.registerMercuryListeners = () => {
	            this.session.on(mercury.MercuryEventType.WORK_OFFER, this.handleWorkOffer);
	            this.session.on(mercury.MercuryEventType.CHANNEL_ADDED, this.handleChannelEvent);
	            this.session.on(mercury.MercuryEventType.CHANNEL_REMOVED, this.handleChannelEvent);
	            this.session.on(mercury.MercuryEventType.CONTROL_MESSAGE, this.handleControlEvent);
	            this.session.on(mercury.MercuryEventType.ACTIVITY_CHANGE, this.handleActivityEvent);
	            this.session.on(mercury.MercuryEventType.MEMBER_JOINED, this.handleMemberEvent);
	            this.session.on(mercury.MercuryEventType.MEMBER_LEFT, this.handleMemberEvent);
	            this.session.on(mercury.MercuryEventType.MEMBER_UPDATED, this.handleMemberEvent);
	            // Only registering these for the window where the active engagement resides, otherwise we get redundant events on refresh
	            // this.session.on(mercury.MercuryEventType.MESSAGE_ADDED, this.handleMessageEvent);
	            // this.session.on(mercury.MercuryEventType.MESSAGE_REMOVED, this.handleMessageEvent);
	            // this.session.on(mercury.MercuryEventType.MESSAGE_UPDATED, this.handleMessageEvent);
	            this.session.on(mercury.MercuryEventType.CONNECTION_ERROR, this.handleConnectionErrorEvent);
	            this.session.on(mercury.MercuryEventType.CONNECTION_ESTABLISHED, this.handleConnectionEstablishedEvent);
	            this.session.on(mercury.MercuryEventType.UPLOAD_COMPLETED, this.handleUploadEvent);
	            this.session.on(mercury.MercuryEventType.UPLOAD_STATUS, this.handleUploadEvent);
	            this.session.on(mercury.MercuryEventType.AVAILABILITY_CHANGE, this.handleAvailableEvent);
	            this.session.on(mercury.MercuryEventType.UNSTABLE_CONNECTION, this.handleUnstableConnectionEvent);
	            this.session.on(mercury.MercuryEventType.OFFER_CANCELLATION, this.handleChatCancelEvent);
	            try {
	                const channels = this.session.getChannels();
	                if (channels && channels.length > 0) {
	                    for (let i = 0; i < channels.length; i++) {
	                        if (channels[i]) {
	                            const mercuryChannel = channels[i];
	                            const engagementId = mercuryChannel.identifier;
	                            if (this.winMgr.isCurrentEngagementWindow(engagementId)) {
	                                this.registerListenersForMercuryChannel(mercuryChannel);
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Exception retrieving channels ' + err);
	            }
	            try {
	                mcaLogger_1.McaLogger.info(`${this.pre} Starting Mercury Session Listener ...`);
	                this.session.startListening();
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Exception startListening ' + err);
	            }
	        };
	        this.initMcaFramework = () => {
	            mcaLogger_1.McaLogger.warn(`${this.pre} TODO Add Log Handler`);
	            this.engMgr = mca_engagement_manager_1$1.EngagementManager.getInstance();
	            this.engMgr.setResponseTarget(this.handleEngagementResponse, mca_common_types_1.EventSource.mercury);
	            this.engMgr.setEventTarget(this.handleEngagementEvent, mca_common_types_1.EventSource.mercury);
	            this.winMgr = mca_window_manager_1$1.WindowManager.getInstance();
	            if (this.mcaBundle) {
	                this.winMgr.setMcaBundle(this.mcaBundle);
	            }
	            window.addEventListener(mca_common_types_1.McaEventType.unloadHandling, this.unloadListener);
	        };
	        this.setUserConfigurations = (userConfigurations) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} setUserConfigurations begins`);
	            if (!userConfigurations || !userConfigurations.mercuryInfo) {
	                mcaLogger_1.McaLogger.warn(`${this.pre} setUserConfigurations failed, missing mercuryInfo`);
	                return;
	            }
	            this.userConfigurations = userConfigurations;
	            if (this.userConfigurations.userDetails) {
	                if (this.userConfigurations.userDetails.permissions) {
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Chat_Access') !== -1 ||
	                        this.userConfigurations.userDetails.permissions.indexOf('SVC_CHAT_FEATURES_PRIV') !== -1) {
	                        this.allowMcaChatAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Audio_Access') !== -1) {
	                        this.allowMcaAudioAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Video_Access') !== -1) {
	                        this.allowMcaVideoAccess(true);
	                    }
	                    if (this.userConfigurations.userDetails.permissions.indexOf('MCA_Recording_Access') !== -1) {
	                        this.allowMcaRecordingAccess(true);
	                    }
	                }
	                // Special handling for Local tests, because some user permission settings
	                //   are not passed in to local test user.
	                if (this.userConfigurations.userDetails.appName === mca_common_types_1.AppName.mca) {
	                    this.allowMcaChatAccess(true);
	                    this.allowMcaAudioAccess(true);
	                    this.allowMcaVideoAccess(true);
	                    this.allowMcaRecordingAccess(true);
	                }
	            }
	            const mercuryInfo = userConfigurations.mercuryInfo;
	            if (mercuryInfo != null && mercuryInfo.chatEnabled === true) {
	                mcaLogger_1.McaLogger.info(`${this.pre} setUserConfigurations - chat is enabled, make validations`);
	                if (!oj_mca_common_1$1.McaCommon.isValidUrl(mercuryInfo.chatServerEndPoint)) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} chatEnabled is true and chatServerEndPoint URL is invalid`);
	                    this.loadStatus(mca_common_types_1.EventState.fail);
	                }
	                else if (!mercuryInfo.chatServerClientToken) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} chatEnabled is true but missing JWT`);
	                    this.loadStatus(mca_common_types_1.EventState.fail);
	                }
	                else if (!mercuryInfo.omniBrowserNotificationEnabled && !mercuryInfo.omniDesktopNotificationEnabled) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} channels are disabled because chat and notifications are disabled`);
	                    this.loadStatus(mca_common_types_1.EventState.fail);
	                }
	                else {
	                    // Since this should only ever read from cache we don't need extensionObject param
	                    this.chatConfigCache = new mca_rest_helper_1.McaRestHelper(McaEngageSdkModel.CHAT_CONFIG_CACHE, mca_rest_helper_1.McaRestHelper.NO_REST);
	                    this.connect();
	                }
	            }
	            else {
	                this.loadStatus(mca_common_types_1.EventState.fail);
	                mcaLogger_1.McaLogger.info(`${this.pre} setUserConfigurations after set this.loadStatus to fail`);
	            }
	            mcaLogger_1.McaLogger.info(`${this.pre} setUserConfigurations ends`);
	        };
	        /**
	         * Retrieves the current Agent States from Mercury and broadcasts events.
	         */
	        this.refreshAgentStates = () => {
	            this.getAgentStates()
	                .then((agentStateMap) => {
	                if (agentStateMap && agentStateMap.size > 0) {
	                    const workTypes = agentStateMap.keys();
	                    for (const workType of workTypes) {
	                        const agentState = agentStateMap.get(workType);
	                        const formattedEvent = { bubbles: true, cancelable: false, detail: agentState };
	                        const customEvent = new CustomEvent(mca_common_types_1.McaEventType.agentState, formattedEvent);
	                        this.dispatchClientEvent(customEvent);
	                    }
	                }
	                else {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} No Mercury ChannelStates retrieved`);
	                }
	            })
	                .catch((reason) => {
	                mcaLogger_1.McaLogger.error(`${this.pre} Error retrieving Mercury ChannelStates ` + reason);
	            });
	        };
	        this.getMcaChannelFromMercuryType = (type) => {
	            if (type === 'REALTIME_CHAT') {
	                // session.availability returns workType: 'CHAT' but availability event come with workType 'REALTIME_CHAT'
	                mcaLogger_1.McaLogger.warn(`${this.pre} Converting OLD Mercury WorkType: REALTIME_CHAT, to new WorkType: CHAT`);
	                type = 'CHAT';
	            }
	            if (type === 'VIDEO') {
	                mcaLogger_1.McaLogger.warn(`${this.pre} Converting channel Type: VIDEO, to WorkType: Video`);
	                type = 'Video';
	            }
	            let retVal;
	            if (this.supportedChannels) {
	                for (const channel of this.supportedChannels) {
	                    if (type === channel.workType) {
	                        retVal = channel;
	                        break;
	                    }
	                }
	            }
	            if (!retVal) {
	                mcaLogger_1.McaLogger.warn(`${this.pre} Unknown Mercury WorkType: ${type}, Using Raw WorkType for Display`);
	                retVal = {
	                    channelType: mca_common_types_1.ChannelType.none,
	                    displayName: type,
	                    source: mca_common_types_1.EventSource.mercury,
	                    workType: type
	                };
	            }
	            return retVal;
	        };
	        /**
	         * An Engagement Event was detected in another window.
	         * FYI, This event MAY have already been detected in this window as well.
	         */
	        this.handleEngagementEvent = (event) => {
	            mcaLogger_1.McaLogger.info(this.pre + 'handleEngagementEvent ' + event);
	            switch (event.method) {
	                case mca_common_types_1.McaMethod.newComm:
	                    this.checkAndSendNotify(event, true);
	                    break;
	                case mca_common_types_1.McaMethod.startComm:
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca_common_types_1.McaMethod.closeComm:
	                    const newEvent = this.convertMcaEvent(event, null);
	                    if (newEvent) {
	                        this.dispatchClientEvent(newEvent);
	                    }
	                    this.checkAndSendNotify(event, false);
	                    break;
	                case mca_common_types_1.McaMethod.updateComm:
	                    this.sendMercuryDataUpdate(event);
	                    break;
	            }
	        };
	        this.sendMercuryDataUpdate = (event) => {
	            const response = {};
	            if (!event.data.inData) {
	                return;
	            }
	            response.uuid = event.uuid;
	            response.result = mca_common_types_1.Result.success;
	            response.method = event.method;
	            response.channelType = event.data.channelType;
	            response.origin = event.origin;
	            response.eventId = event.data.eventId;
	            response.engagementId = event.data.engagementId;
	            response.outData = event.data.inData;
	            this.sendToMercury(response);
	        };
	        this.handleEngagementResponse = (response, event) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} handleEngagementResponse ${response}`);
	            if (event.previewMode) {
	                response.previewMode = event.previewMode;
	            }
	            response.workType = event.data.workType;
	            this.sendProviderResponse(response);
	            const newEvent = this.convertMcaEvent(event, response);
	            if (newEvent) {
	                this.dispatchClientEvent(newEvent);
	            }
	            if (event && event.method) {
	                switch (event.method) {
	                    case mca_common_types_1.McaMethod.newComm:
	                        const engagement = this.engMgr.getEngagement(event.data.eventId);
	                        // Don't send this if we already got a start or close
	                        if (engagement && engagement.lastEvent.method === mca_common_types_1.McaMethod.newComm) {
	                            this.checkAndSendNotify(event, true, response); // Update Notification with Response Data
	                        }
	                        break;
	                    case mca_common_types_1.McaMethod.closeComm:
	                        // Ensure the Chat is Cleaned Up in the No-Wrap-Up Case
	                        if (response && response.actions) {
	                            for (let i = 0; i < response.actions.length; i++) {
	                                if (response.actions[i].name === mca_common_types_1.ActionName.EndCommunication && event.data.reason !== mca_common_types_1.CloseCommReason.transferred) {
	                                    const command = new mca_common_types_1.Command(mca_common_types_1.InteractionCommandName.wrapupComplete, event.data.eventId, null, null, null, null, response.workType);
	                                    // 1-11-22 Once again Closing chat since this is no longer done by Chat UI
	                                    // Engagement Component does not call omnichannel-chat-container.closeChannel anymore.
	                                    // So, this is now required for Chat.
	                                    this.invokeCommand(command);
	                                    break;
	                                }
	                            }
	                        }
	                        const win = this.winMgr.getWindowForLatestEngagement(event.data.eventId);
	                        if (!win || win.unloadTime > 0) {
	                            if ([mca_common_types_1.CloseCommReason.transferred, mca_common_types_1.CloseCommReason.reject, mca_common_types_1.CloseCommReason.timeout, mca_common_types_1.CloseCommReason.abandoned].indexOf(event.data.reason) === -1) {
	                                // Try to Clean Up the Chat in case the Window is Closed
	                                const command = new mca_common_types_1.Command(mca_common_types_1.InteractionCommandName.wrapupComplete, event.data.eventId, null, null, null, null, response.workType);
	                                mcaLogger_1.McaLogger.warn(`${this.pre} Evidently the ${event.data.channel} window was closed, Forcing ${command} for ${response.method}`);
	                                this.invokeCommand(command);
	                            }
	                        }
	                        break;
	                }
	            }
	        };
	        /**
	         * Checks if a notification event is necessary and if so sends it.
	         */
	        this.checkAndSendNotify = (event, notifyOn, response) => {
	            if (!event) {
	                return;
	            }
	            if (event.previewMode && event.previewMode === 'MANUAL') {
	                return;
	            }
	            if (event.data === undefined || !event.data.inData) {
	                return;
	            }
	            if (event.data.inData[mca_common_types_1.SystemToken.direction] === mca_common_types_1.DirectionToken.outbound) {
	                return;
	            }
	            if (notifyOn) {
	                if (!event.actions) {
	                    mcaLogger_1.McaLogger.info(this.pre + 'no notify Action set');
	                    return;
	                }
	                else {
	                    let notifyFound = false;
	                    for (const action of event.actions) {
	                        if (action.name === mca_common_types_1.ActionName.Notify) {
	                            notifyFound = true;
	                            break;
	                        }
	                    }
	                    if (!notifyFound) {
	                        mcaLogger_1.McaLogger.info(this.pre + 'no notify Action set');
	                        return;
	                    }
	                }
	            }
	            const detail = { event, response };
	            const formattedEvent = {
	                bubbles: true,
	                cancelable: false,
	                detail
	            };
	            const eventType = notifyOn ? mca_common_types_1.McaEventType.notifyOn : mca_common_types_1.McaEventType.notifyOff;
	            const ne = new CustomEvent(eventType, formattedEvent);
	            this.dispatchClientEvent(ne);
	        };
	        /**
	         * Format events for client publication
	         * @return the event to be published, null is returned if no event publication is required.
	         */
	        this.convertMcaEvent = (event, response) => {
	            mcaLogger_1.McaLogger.info(this.pre + 'convertMcaEvent: ' + event.method);
	            let rv = null;
	            if (!event.data) {
	                mcaLogger_1.McaLogger.warn(this.pre + 'convertMcaEvent: missing event.data');
	                return rv;
	            }
	            const eventName = 'mcaEvent';
	            let detail;
	            if (!event.data.engagementId) {
	                event.data.engagementId = event.data.eventId;
	            }
	            if (event.method && response) {
	                switch (event.method) {
	                    case mca_common_types_1.McaMethod.newComm:
	                    case mca_common_types_1.McaMethod.startComm:
	                    case mca_common_types_1.McaMethod.closeComm:
	                    case mca_common_types_1.McaMethod.updateComm:
	                    case mca_common_types_1.McaMethod.transferedToQueue:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                    case mca_common_types_1.McaMethod.agentStateEvent:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                    case mca_common_types_1.McaMethod.interactionControlsChanged:
	                        detail = {
	                            event,
	                            invokeCommand: this.invokeCommand,
	                            response
	                        };
	                        break;
	                }
	            }
	            if (detail) {
	                const formattedEvent = {
	                    bubbles: true,
	                    cancelable: false,
	                    detail
	                };
	                rv = new CustomEvent(eventName, formattedEvent);
	            }
	            return rv;
	        };
	        this.dispatchClientEvent = (event) => {
	            if (event && event.type) {
	                try {
	                    let callback;
	                    switch (event.type) {
	                        case mca_common_types_1.McaEventType.agentState:
	                            if (this.agentStateEventListener) {
	                                callback = this.agentStateEventListener;
	                            }
	                            break;
	                        case mca_common_types_1.McaEventType.mcaEvent:
	                            if (this.mcaEventTarget) {
	                                callback = this.mcaEventTarget;
	                            }
	                            break;
	                        case mca_common_types_1.McaEventType.notifyOn:
	                        case mca_common_types_1.McaEventType.notifyOff:
	                            if (this.notificationEventTarget) {
	                                callback = this.notificationEventTarget;
	                            }
	                            break;
	                        default:
	                            mcaLogger_1.McaLogger.warn(`${this.pre} No dispacher defined for eventType: ${event.type}`);
	                            break;
	                    }
	                    if (callback) {
	                        mcaLogger_1.McaLogger.info(this.pre + 'Dispatching Event: ' + event.type);
	                        callback(event);
	                    }
	                    else {
	                        mcaLogger_1.McaLogger.warn(`${this.pre} no Listener registered for event: ${event.type}`);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Exception during event dispatch`, err);
	                }
	            }
	        };
	        /**
	         * MCA --> Mercury Command Converters
	         */
	        this.setAvailability = (command) => {
	            try {
	                const availabilityMap = new Map();
	                if (!command.workType) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Mercury setAvailability Command missing workType!`);
	                    return;
	                }
	                const workType = command.workType;
	                const mercuryState = command.command === mca_common_types_1.AgentCommandName.makeAvailable
	                    ? mercury.AvailabilityType.AVAILABLE : mercury.AvailabilityType.UNAVAILABLE;
	                const osvcState = command.command === mca_common_types_1.AgentCommandName.makeAvailable
	                    ? OSvCAvailableStates.AVAILABLE : OSvCAvailableStates.UNAVAILABLE;
	                availabilityMap.set(workType, mercuryState);
	                if (this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.chatEnabled) {
	                    if (this.session) {
	                        this.session.setActivityStatus(osvcState)
	                            .then(() => {
	                            mcaLogger_1.McaLogger.info(`${this.pre} *Success* set availability OSvC chat: ${osvcState}`);
	                            if (command.responseCallback) {
	                                const resp = new mca_common_types_1.CommandResponse(command.command, mca_common_types_1.Result.success, command.commandId, null, {}, command.channelType, null, workType);
	                                try {
	                                    command.responseCallback(resp);
	                                }
	                                catch (iErr) { }
	                            }
	                        })
	                            .catch((reason) => {
	                            mcaLogger_1.McaLogger.error(`${this.pre} Error setting availability for OSvC chat: ${reason}`);
	                            this.loadStatus(mca_common_types_1.EventState.loaded);
	                            this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionLost, { reason });
	                            if (command.responseCallback) {
	                                const resp = new mca_common_types_1.CommandResponse(command.command, mca_common_types_1.Result.error, command.commandId, null, { reason }, command.channelType, null, workType);
	                                try {
	                                    command.responseCallback(resp);
	                                }
	                                catch (iErr) { }
	                            }
	                        });
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception in setAvailability`, err);
	                this.loadStatus(mca_common_types_1.EventState.loaded);
	                this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionLost, { reason: err });
	                if (command.responseCallback) {
	                    const resp = new mca_common_types_1.CommandResponse(command.command, mca_common_types_1.Result.success, command.commandId, null, {}, command.channelType, null, command.workType);
	                    try {
	                        command.responseCallback(resp);
	                    }
	                    catch (iErr) { }
	                }
	            }
	        };
	        this.checkTarget = (target) => {
	            let retVal = true;
	            if (target && target.trim().length > 0) {
	                if (target !== mca_common_types_1.EventSource.mercury) {
	                    retVal = false;
	                }
	            }
	            return retVal;
	        };
	        this.checkChannel = (channelType) => {
	            let retVal = false;
	            if (this.supportedChannels) {
	                for (const channel of this.supportedChannels) {
	                    if (channelType === channel.channelType) {
	                        retVal = true;
	                        break;
	                    }
	                }
	            }
	            // In case channels haven't been initialized yet
	            if (!retVal) {
	                if (channelType === mca_common_types_1.ChannelType.chat) {
	                    retVal = true;
	                }
	            }
	            return retVal;
	        };
	        this.getCommEvent = (method, engagementId, details, workType) => {
	            let channelType;
	            let channel;
	            if (workType) {
	                const channelObj = this.getMcaChannelFromMercuryType(workType);
	                channelType = channelObj.channelType;
	                channel = channelObj.channel;
	            }
	            else {
	                channelType = mca_common_types_1.ChannelType.chat;
	                channel = mca_common_types_1.Constants.CHAT;
	            }
	            const appClass = mca_common_types_1.Constants.DEFAULT_APP_CLASS;
	            const data = {
	                appClassification: appClass,
	                channel,
	                channelType,
	                engagementId,
	                eventId: engagementId,
	                inData: {}
	            };
	            const mcaEvent = {
	                data,
	                eventSource: mca_common_types_1.EventSource.mercury,
	                mcaOrigEventSource: mca_common_types_1.EventSource.mercury,
	                method,
	                origin: this.mercuryOrigin,
	                toolbarName: mca_common_types_1.EventSource.mercury,
	                uuid: data.eventId,
	                version: this.mercuryVersion
	            };
	            data.inData[mca_common_types_1.SystemToken.direction] = mca_common_types_1.DirectionToken.inbound;
	            switch (method) {
	                case mca_common_types_1.McaMethod.startComm:
	                    break;
	                case mca_common_types_1.McaMethod.closeComm:
	                    if (details) {
	                        if (details === mca_common_types_1.CloseCommReason.canceled) {
	                            data.reason = mca_common_types_1.CloseCommReason.abandoned;
	                        }
	                        else if (details === mca_common_types_1.CloseCommReason.timeout ||
	                            details === mca_common_types_1.CloseCommReason.missed ||
	                            details === mca_common_types_1.CloseCommReason.reject ||
	                            details === mca_common_types_1.CloseCommReason.end ||
	                            details === mca_common_types_1.CloseCommReason.transferred ||
	                            details === mca_common_types_1.CloseCommReason.wrapup) {
	                            data.reason = details;
	                        }
	                    }
	                    else {
	                        data.reason = mca_common_types_1.CloseCommReason.wrapup;
	                    }
	                    break;
	            }
	            return mcaEvent;
	        };
	        this.internalProcessReceivedMessage = (mcaEvent) => {
	            if (mcaEvent.method) {
	                const eventResponse = {};
	                switch (mcaEvent.method) {
	                    case mca_common_types_1.McaMethod.newComm:
	                        this.checkAndSendNotify(mcaEvent, true);
	                        break;
	                    case mca_common_types_1.McaMethod.startComm:
	                        this.checkAndSendNotify(mcaEvent, false);
	                        break;
	                    case mca_common_types_1.McaMethod.closeComm:
	                        try {
	                            this.activeChannelsMap.delete(mcaEvent.data.eventId);
	                        }
	                        catch (err) {
	                            mcaLogger_1.McaLogger.error(`Failed to delete channel from channel map: [${err}]`);
	                        }
	                        this.checkAndSendNotify(mcaEvent, false);
	                        break;
	                    case mca_common_types_1.McaMethod.agentStateEvent:
	                        break;
	                    case mca_common_types_1.McaMethod.interactionControlsChanged:
	                        break;
	                }
	                this.processMcaEvent(mcaEvent, eventResponse);
	            }
	            else {
	                mcaLogger_1.McaLogger.info(this.pre + 'Ignoring event missing method!!!');
	            }
	        };
	        this.processMcaEvent = (event, response) => {
	            let deferredEngagement;
	            let setResponse = false;
	            switch (event.method) {
	                case mca_common_types_1.McaMethod.startComm:
	                case mca_common_types_1.McaMethod.newComm:
	                case mca_common_types_1.McaMethod.upgradeComm:
	                case mca_common_types_1.McaMethod.downgradeComm:
	                case mca_common_types_1.McaMethod.closeComm:
	                case mca_common_types_1.McaMethod.previewComm:
	                case mca_common_types_1.McaMethod.transferedToQueue:
	                    deferredEngagement = this.engMgr.processEvent(event);
	                    break;
	                case mca_common_types_1.McaMethod.agentStateEvent:
	                    if (response) {
	                        response.result = mca_common_types_1.Result.success;
	                        setResponse = true;
	                    }
	                    break;
	                case mca_common_types_1.McaMethod.interactionControlsChanged:
	                    setResponse = true;
	                    break;
	            }
	            if (deferredEngagement) {
	                deferredEngagement.then((engagement) => {
	                    if (!engagement) {
	                        mcaLogger_1.McaLogger.info(this.pre + 'Why no engagement returned from processEvent?');
	                    }
	                    else {
	                        mcaLogger_1.McaLogger.log(this.pre + 'processEvent Promise returned');
	                        const state = engagement.stateMap[event.method];
	                        if (state === mca_common_types_1.EventState.complete) {
	                            // event was processed on the server
	                            mcaLogger_1.McaLogger.log(this.pre + 'Event was already processed on the server.');
	                            const newResponse = engagement.responseMap[event.method];
	                            if (!newResponse) {
	                                mcaLogger_1.McaLogger.warn(this.pre + 'Event marked complete but no response.');
	                            }
	                            else {
	                                // uuid is unique to this toolbar's instance event
	                                newResponse.uuid = event.uuid;
	                                newResponse.workType = event.data.workType;
	                                this.sendProviderResponse(newResponse);
	                            }
	                        }
	                    }
	                });
	                deferredEngagement.catch((err) => {
	                    mcaLogger_1.McaLogger.warn(this.pre + 'Error detected in processEvent: ' + err);
	                });
	                return; // early exit!!!
	            }
	            let newEvent = null;
	            if (setResponse) {
	                newEvent = this.convertMcaEvent(event, response);
	                this.sendProviderResponse(response);
	                this.dispatchClientEvent(newEvent);
	            }
	        };
	        /**
	         * Wait for the Session Creation to complete or fail then invoke any outstanding commands
	         */
	        this.loadStatusListener = (newValue) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} loadStatus updated====>: ${newValue}`);
	            if (newValue === mca_common_types_1.EventState.complete || newValue === mca_common_types_1.EventState.fail) {
	                mcaLogger_1.McaLogger.info(`${this.pre} loadStatus updated: ${newValue}`);
	                if (this.commandQueue.length > 0) {
	                    mcaLogger_1.McaLogger.info(`${this.pre}  Processing ${this.commandQueue.length} Queued Commmands `);
	                    for (let i = 0; i < this.commandQueue.length; i++) {
	                        mcaLogger_1.McaLogger.info(`${this.pre}  Processing Queued Commmand ${this.commandQueue[i]}`);
	                        this.invokeCommand(this.commandQueue[i]);
	                    }
	                    this.commandQueue = new Array(); // just reset the queue
	                }
	            }
	        };
	        /**
	         * Wait for the chatConfigs retrieval to complete or fail then send the results to any outstanding requestors
	         */
	        this.chatConfigListener = (newValue) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} chatConfigs updated====>: ${newValue}`);
	            if (this.chatConfigQueue.length > 0) {
	                for (let i = 0; i < this.chatConfigQueue.length; i++) {
	                    mcaLogger_1.McaLogger.info(`${this.pre}  Processing Queued chatConfig Commmand ${this.chatConfigQueue[i]}`);
	                    this.invokeCommand(this.chatConfigQueue[i]);
	                }
	                this.chatConfigQueue = new Array(); // just reset the queue
	            }
	        };
	        /**
	         * Asynchronous Command processing required when commands are initiated prior to the Mercury Session Creation
	         */
	        this.invokeCommandAsync = (command) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(`${this.pre} invokeCommandAsync ${command}`);
	            try {
	                if (!this.session) {
	                    const dbgStatus = this.loadStatus();
	                    if (dbgStatus !== mca_common_types_1.EventState.complete && dbgStatus !== mca_common_types_1.EventState.fail) {
	                        mcaLogger_1.McaLogger.info(`${this.pre} queueing command ${command}`);
	                        this.commandQueue.push(command);
	                        return;
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception invokeCommandAsync: ${err}`);
	            }
	            this.invokeCommand(command);
	        });
	        this.getChannel = (id) => {
	            let channel = this.activeChannelsMap.get(id);
	            mcaLogger_1.McaLogger.info(`${this.pre} ##### getChannel get from activeChannelsMap ${JSON.stringify(channel)}`);
	            try {
	                if (!channel) {
	                    if (this.session) {
	                        const channels = this.session.getChannels();
	                        if (channels) {
	                            for (let i = 0; i < channels.length; i++) {
	                                if (channels[i] && channels[i].identifier === id) {
	                                    channel = channels[i];
	                                    mcaLogger_1.McaLogger.info(`${this.pre} ##### getChannel get from session ${JSON.stringify(channel)}`);
	                                    break;
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Exception retrieving channels', err);
	            }
	            return channel;
	        };
	        /**
	         * Retrieves the site visitor that initiated the Chat.
	         * @return mercury.Particant
	         */
	        this.getVisitor = (mercuryChannel) => {
	            let participant = null;
	            for (let i = 0; i < mercuryChannel.members.length; i++) {
	                const tmpParticipant = mercuryChannel.members[i];
	                if (tmpParticipant.role === mercury.ParticipationRoleType.END_USER) {
	                    participant = mercuryChannel.members[i];
	                    break;
	                }
	            }
	            return participant;
	        };
	        ///////////////////////////////
	        // Mercury Command Processors
	        ///////////////////////////////
	        this.acceptOffer = (command, offerResponseType = mca_mercury_copy_1$1.OfferResponseType.MANUAL) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(this.pre + 'acceptOffer ', command, offerResponseType);
	            let event = this.getCommEvent(mca_common_types_1.McaMethod.closeComm, command.eventId, null, command.workType);
	            if (event.data.reason) {
	                event.data.reason = mca_common_types_1.CloseCommReason.reject;
	            }
	            const offer = this.pendingOffersMap.get(command.eventId);
	            // sjmD <TODO> Doesn't seem that All Offers are sent to All Windows???
	            if (!offer) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Could not find offer to accept for command ' + command);
	                // Ensure the notification gets closed
	                mcaLogger_1.McaLogger.warn(this.pre + 'Assuming close is in order');
	                this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    this.session.acceptOffer(offer, offerResponseType)
	                        .then((channel) => {
	                        mcaLogger_1.McaLogger.info(`${this.pre} *Success* acceptOffer ${channel}`);
	                        event = this.getCommEvent(mca_common_types_1.McaMethod.startComm, command.eventId, null, command.workType);
	                        // const channelStr: string = JSON.stringify(channel);
	                        // McaLogger.info(`${this.pre} Channel String is ` + channelStr);
	                        this.activeChannelsMap.set(offer.identifier, channel);
	                        this.internalProcessReceivedMessage(event);
	                        // sjm - 12-01-20 Don't see any reason to register Channel Listeners in the Accept Window
	                        // this.registerListenersForMercuryChannel(channel);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1.McaLogger.info(`${this.pre} Error in acceptOffer ${reason}`);
	                        mcaLogger_1.McaLogger.info(this.pre + 'Assuming close is in order');
	                        // Assume the Visitor Left the Chat
	                        event.data.reason = mca_common_types_1.CloseCommReason.abandoned;
	                        event.data.errorMsg = 'chatCanceled';
	                        this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Exception in acceptOffer ${err}`);
	                    mcaLogger_1.McaLogger.warn(this.pre + 'Assuming close is in order');
	                    this.internalProcessReceivedMessage(event);
	                }
	                this.cleanupOffer(offer.identifier);
	            }
	        });
	        this.rejectOffer = (command) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(this.pre + 'rejectOffer ' + command);
	            const event = this.getCommEvent(mca_common_types_1.McaMethod.closeComm, command.eventId, null, command.workType);
	            if (event.data.reason) {
	                event.data.reason = mca_common_types_1.CloseCommReason.reject;
	            }
	            const offer = this.pendingOffersMap.get(command.eventId);
	            if (!offer) {
	                mcaLogger_1.McaLogger.error(this.pre + 'Could not find offer to reject for command ' + command);
	                // Ensure the notification gets closed
	                mcaLogger_1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    this.session
	                        .rejectOffer(offer)
	                        .then(() => {
	                        mcaLogger_1.McaLogger.info(this.pre + '*Success* rejectOffer ');
	                        // At this point we don't have a channel so no need to delete
	                        // it from the map
	                        // this.activeChannelsMap.delete(channel.identifier);
	                        this.internalProcessReceivedMessage(event);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1.McaLogger.error(`${this.pre} Error in rejectOffer ${reason}`);
	                        mcaLogger_1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                        this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Exception in rejectOffer ${err}`);
	                    mcaLogger_1.McaLogger.warn(this.pre + 'Processing close anyway...');
	                    this.internalProcessReceivedMessage(event);
	                }
	                this.cleanupOffer(offer.identifier);
	            }
	        });
	        this.disconnectWithReasonCode = (command, reason) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(this.pre + 'chatOfferTimeout ' + command);
	            const event = this.getCommEvent(mca_common_types_1.McaMethod.closeComm, command.eventId, reason, command.workType);
	            if (event.data.reason) {
	                event.data.reason = reason;
	            }
	            this.internalProcessReceivedMessage(event);
	        });
	        /**
	         * This does something on the Mercury Channel like a disconnect.
	         * This *MUST* be called to trigger closeCommEvent processing.
	         */
	        this.concludeEngagement = (command) => __awaiter$1(this, void 0, void 0, function* () {
	            var _a;
	            mcaLogger_1.McaLogger.info(this.pre + 'concludeEngagement ' + command);
	            let reason = null;
	            if ((_a = command === null || command === void 0 ? void 0 : command.inData) === null || _a === void 0 ? void 0 : _a.reason) {
	                reason = command.inData.reason;
	            }
	            const event = this.getCommEvent(mca_common_types_1.McaMethod.closeComm, command.eventId, reason, command.workType);
	            this.internalProcessReceivedMessage(event);
	        });
	        /**
	         * ToDo: transfer is done
	         */
	        this.transferedEngagement = (command) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(this.pre + 'transferedEngagement ' + command);
	            const event = this.getCommEvent(mca_common_types_1.McaMethod.transferedToQueue, command.eventId, null, command.workType);
	            event.data.reason = mca_common_types_1.CloseCommReason.transferred;
	            this.internalProcessReceivedMessage(event);
	        });
	        /* 09-01-20: Original method, now seems Chat UI is invoking Channel.conclude so removed redundant call
	        private concludeEngagement = async (command: mca.Command): Promise<void> => {
	          McaLogger.info(this.pre + 'concludeEngagement ' + command);
	          const event: mca.McaEvent = this.getCommEvent(mca.McaMethod.closeComm, command.eventId);
	          const channel: mercury.Channel = this.getChannel(command.eventId);
	          if (!channel) {
	            McaLogger.error(this.pre + "Couldn't get Mercury Channel for comand: " + command);
	            McaLogger.warn(this.pre + 'Processing close anyway..');
	            this.internalProcessReceivedMessage(event);
	          } else {
	            try {
	              McaLogger.info(this.pre + 'Invoking Channel.conclude for ' + command);
	              channel
	                .conclude()
	                .then((response: any) => {
	                  McaLogger.info(`${this.pre} *Success* Channel.conclude ${response}`);
	                  this.internalProcessReceivedMessage(event);
	                })
	                .catch((reason: any) => {
	                  McaLogger.error(`${this.pre} Error Channel.conclude ${reason}`);
	                  McaLogger.warn(this.pre + 'Processing close anyway..');
	                  this.internalProcessReceivedMessage(event);
	                });
	            } catch (err) {
	              McaLogger.error(`${this.pre} Exception in Channel.conclude ${err}`);
	              McaLogger.warn(this.pre + 'Processing close anyway..');
	              this.internalProcessReceivedMessage(event);
	            }
	          }
	        }; */
	        /**
	         * This ensures the Mercury Channel is closed.
	         * This *MUST* be called for *EVERY* Chat after the Engagement has been Ended
	         * This *MUST* be called once wrap-up is complete.
	         */
	        this.closeEngagement = (command) => __awaiter$1(this, void 0, void 0, function* () {
	            mcaLogger_1.McaLogger.info(this.pre + 'closeEngagement ' + command);
	            this.getCommEvent(mca_common_types_1.McaMethod.closeComm, command.eventId, null, command.workType);
	            const channel = this.getChannel(command.eventId);
	            if (!channel) {
	                mcaLogger_1.McaLogger.error(this.pre + "Couldn't get Mercury Channel for comand: " + command);
	                // McaLogger.warn(this.pre + 'Processing close anyway..');
	                // this.internalProcessReceivedMessage(event);
	            }
	            else {
	                try {
	                    mcaLogger_1.McaLogger.info(this.pre + 'Invoking Channel.close for ' + command);
	                    // TODO should have some way to check if this needs invoked for example: if (channel.isConnected)
	                    channel.close()
	                        .then((response) => {
	                        mcaLogger_1.McaLogger.info(`${this.pre} *Success* Channel.close ${response}`);
	                        // McaLogger.warn(this.pre + 'Processing close anyway..');
	                        // this.internalProcessReceivedMessage(event);
	                    })
	                        .catch((reason) => {
	                        mcaLogger_1.McaLogger.error(`${this.pre} Error Channel.close ${reason}`);
	                        // McaLogger.warn(this.pre + 'Processing close anyway..');
	                        // this.internalProcessReceivedMessage(event);
	                    });
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Exception in Channel.close ${err}`);
	                    // McaLogger.warn(this.pre + 'Processing close anyway..');
	                    // this.internalProcessReceivedMessage(event);
	                }
	            }
	        });
	        /**
	         * Converts the incoming mercuryData attributes into mcaData Tokens.
	         * The well-known Mercury Attributes are Mapped Here.
	         * All other Mercury Attributes are just added to the mcaData list and may be mapped
	         * to MCA Tokens on the Server using the MCA Token Alt Name Value.
	         * @returns the outgoing mcaData object
	         */
	        this.convertMercuryData = (mercuryData, mcaData, assignmentType, method) => {
	            // Map -> Mercury Name : MCA Token
	            // const mercuryDataStr: string = JSON.stringify(mercuryData);
	            // console.log('Convert MercuryData String ' + mercuryDataStr);
	            // const mcaDataStr: string = JSON.stringify(mcaData);
	            // console.log('Convert mcaData String ' + mcaDataStr);
	            try {
	                const conversionMap = {
	                    ["question" /* mercury.ChannelContextNameType.QUESTION */]: mca_common_types_1.SystemToken.interactionDescription,
	                    ["QUEUE_NAME" /* mercury.ChannelContextNameType.QUEUE_NAME */]: mca_common_types_1.SystemToken.queueName,
	                    ["offerTimeOut" /* mercury.ChannelContextNameType.OFFER_TIMEOUT */]: mca_common_types_1.SystemToken.offerTimeout,
	                    ["contactId" /* mercury.ChannelContextNameType.CONTACT_ID */]: mca_common_types_1.SystemToken.contactId,
	                    ['appClassification']: mca_common_types_1.SystemToken.appClassification,
	                    ['applicationClassification']: mca_common_types_1.SystemToken.appClassification,
	                    ['appClass']: mca_common_types_1.SystemToken.appClassification,
	                    ['stripeCode']: mca_common_types_1.SystemToken.stripeCd,
	                    // Added For Engage Adapter
	                    ['emailAddress']: mca_common_types_1.SystemToken.email
	                };
	                if (!mercuryData || mercuryData.size < 1) {
	                    mcaLogger_1.McaLogger.warn(`${this.pre} No Mercury Data Found!`);
	                    return;
	                }
	                let checkCustomFields = false;
	                let customFields;
	                const mercuryItems = mercuryData.keys();
	                for (const mercuryKey of mercuryItems) {
	                    const mercuryVal = mercuryData.get(mercuryKey);
	                    if (mercuryVal === null) {
	                        continue;
	                    }
	                    // Engage SDK includes many attributes with -1 values just remove these.
	                    if (mercuryVal === '-1' || mercuryVal === -1) {
	                        // continue;  SVC-297804 - Revert Fix to Handle Invalid Data
	                    }
	                    switch (mercuryKey) {
	                        case 'customFields':
	                            if (mercuryVal && mercuryVal.length > 0) {
	                                checkCustomFields = true;
	                                customFields = mercuryVal;
	                            }
	                            continue;
	                        case 'fusionEngagementId':
	                        case 'queueNames':
	                        // Added for Engage SDK
	                        case 'mediaList':
	                        case 'operatingSystem':
	                        case 'userAgent':
	                            // TODO Add Any Other Items that we want to filter out
	                            continue;
	                        case 'queueIdString':
	                            let queueFound = false;
	                            if (!mcaData[mca_common_types_1.SystemToken.queueName]) {
	                                if (this.userConfigurations.mercuryInfo.chatServerQueues) {
	                                    for (let iq = 0; iq < this.userConfigurations.mercuryInfo.chatServerQueues.length; iq++) {
	                                        const queueDesc = this.userConfigurations.mercuryInfo.chatServerQueues[iq];
	                                        const queueDescId = '' + queueDesc.id;
	                                        const queueDescName = queueDesc.name;
	                                        if (queueDescId === mercuryVal) {
	                                            mcaData[mca_common_types_1.SystemToken.queueName] = queueDescName;
	                                            queueFound = true;
	                                            break;
	                                        }
	                                    }
	                                }
	                            }
	                            if (queueFound) {
	                                continue;
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                    const convertToken = conversionMap[mercuryKey];
	                    if (convertToken) {
	                        if (convertToken === mca_common_types_1.SystemToken.contactId && (mercuryVal === '' || mercuryVal === '-1')) {
	                            mcaLogger_1.McaLogger.warn(`${this.pre} Found wrong contactId Value: ${mercuryKey}:${mercuryVal} - skipping conversion `);
	                            continue;
	                        }
	                        mcaData[convertToken] = mercuryVal;
	                        mcaLogger_1.McaLogger.log(`${this.pre} Found Mapped Mercury Value: ${mercuryKey}:${mercuryVal} -> ${convertToken} `);
	                        continue; // DEV Note: Comment this line to include the raw Mercury token as well
	                    }
	                    mcaData[mercuryKey] = mercuryVal;
	                }
	                let contextName;
	                let contextType;
	                let woName;
	                let woId;
	                let objectTypeCd;
	                let objectId;
	                let extCustJsonString;
	                if (checkCustomFields) {
	                    let confInteractionsMapperFound = false;
	                    for (let j = 0; j < customFields.length; j++) {
	                        const customField = customFields[j];
	                        if (customField && customField.name) {
	                            const convertToken = conversionMap[customField.name];
	                            if (convertToken) {
	                                mcaLogger_1.McaLogger.info(`${this.pre} Found Mapped Mercury Custom Value: ${customField.name}:${customField.value} -> ${convertToken} `);
	                                mcaData[convertToken] = customField.value;
	                                continue; // DEV Note: Comment this line to include the raw token as well
	                            }
	                            // McaLogger.info(this.pre + 'customField.name is ' + customField.name);
	                            // McaLogger.info(this.pre + 'customField.value is ' + customField.value);
	                            switch (customField.name) {
	                                case 'ContextObjectName':
	                                case 'incidentName':
	                                    contextName = customField.value;
	                                    break;
	                                case 'ContextObjectType':
	                                case 'incidentType':
	                                    contextType = customField.value;
	                                    break;
	                                case 'WoName':
	                                    woName = customField.value;
	                                    break;
	                                case 'WorkId':
	                                    woId = customField.value;
	                                    break;
	                                case 'ObjectTypeCd':
	                                    objectTypeCd = customField.value;
	                                    break;
	                                case 'ObjectId':
	                                    objectId = customField.value;
	                                    break;
	                                case 'extendedCustomFieldsJsonStr':
	                                    extCustJsonString = customField.value;
	                                    continue; // don't add the raw json string to the mcaData
	                                case 'INTERACTION_ID':
	                                    if (method === mca_common_types_1.McaMethod.newComm) {
	                                        if (assignmentType === 'CONFERENCE' || assignmentType === 'TRANSFER') {
	                                            // If the newCommEvent and conference offer then this is the parent interaction Id
	                                            mcaData[mca_common_types_1.SystemToken.parentInteractionId] = customField.value;
	                                            const intRefIdField = customFields.find((item) => item.name === mca_common_types_1.SystemToken.chatId);
	                                            if (intRefIdField) {
	                                                const intRefId = intRefIdField.value;
	                                                const intRefTypeId = mca_common_types_1.ChannelType.chatIntRef;
	                                                mcaData[mca_common_types_1.SystemToken.objectId] = intRefId;
	                                                mcaData[mca_common_types_1.SystemToken.objectType] = intRefTypeId;
	                                            }
	                                            mcaLogger_1.McaLogger.info(`${this.pre} converting interactionId to parentInteractionId for conference newComm`);
	                                            continue;
	                                        }
	                                        else {
	                                            // If the newCommEvent then this is the interaction Id to set for processEvent
	                                            mcaData[mca_common_types_1.SystemToken.interactionId] = customField.value;
	                                            continue;
	                                        }
	                                    }
	                                    break;
	                                case 'SVCMCA_INTERACTION_MAPPER':
	                                    confInteractionsMapperFound = true;
	                                    break;
	                                case 'queueNames':
	                                case 'QUEUE_NAMES':
	                                    // TODO Add Any Other Custom Items that we want to filter out
	                                    continue;
	                                case 'SVCMCA_INTERACTION_ID':
	                                    if (method === mca_common_types_1.McaMethod.newComm) {
	                                        // If the newCommEvent has an interaction id, assume this is the parentInteractionId
	                                        mcaData[mca_common_types_1.SystemToken.parentInteractionId] = customField.value;
	                                        mcaLogger_1.McaLogger.info(`${this.pre} converting interactionId to parentInteractionId for newComm`);
	                                        continue;
	                                    }
	                                    break;
	                                default:
	                                    break;
	                            }
	                            mcaData[customField.name] = customField.value;
	                        }
	                    }
	                    if (method === mca_common_types_1.McaMethod.newComm && assignmentType === 'CONFERENCE') {
	                        if (!confInteractionsMapperFound) {
	                            mcaData[mca_common_types_1.SystemToken.confInteractionsMapper] = JSON.stringify([]);
	                        }
	                    }
	                }
	                mcaLogger_1.McaLogger.info(this.pre + 'Context Name is ' + contextType);
	                mcaLogger_1.McaLogger.info(this.pre + 'objectTypeCd is ' + objectTypeCd);
	                mcaLogger_1.McaLogger.info(this.pre + 'objectId is ' + objectId);
	                if (contextName && contextType) {
	                    switch (contextType) {
	                        case 'SVC_SERVICE_REQUESTS':
	                            mcaData[mca_common_types_1.SystemToken.srNum] = contextName;
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_HRHD':
	                            mcaData[mca_common_types_1.SystemToken.srNumHrHd] = contextName;
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_ISR':
	                            mcaData[mca_common_types_1.SystemToken.isrNum] = contextName;
	                            break;
	                        case 'MKL_LEADS':
	                            mcaData[mca_common_types_1.SystemToken.leadNum] = contextName;
	                            break;
	                        // TODO Add Special Handling for other ContextObjectTypes
	                        default:
	                            break;
	                    }
	                }
	                else if (objectTypeCd && objectId) {
	                    // For NON-RT offers we don't see the contextName but, we do see the objectTypeCd/Id
	                    mcaData[mca_common_types_1.SystemToken.objectType] = objectTypeCd;
	                    mcaData[mca_common_types_1.SystemToken.objectId] = objectId;
	                    switch (objectTypeCd) {
	                        case 'SVC_SERVICE_REQUESTS':
	                            mcaData[mca_common_types_1.SystemToken.srId] = objectId;
	                            if (woName) {
	                                mcaData[mca_common_types_1.SystemToken.srNum] = woName;
	                            }
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_HRHD':
	                            mcaData[mca_common_types_1.SystemToken.srIdHrHd] = objectId;
	                            if (woName) {
	                                mcaData[mca_common_types_1.SystemToken.srNumHrHd] = woName;
	                            }
	                            break;
	                        case 'SVC_SERVICE_REQUESTS_ISR':
	                            mcaData[mca_common_types_1.SystemToken.isrId] = objectId;
	                            if (woName) {
	                                mcaData[mca_common_types_1.SystemToken.isrNum] = woName;
	                            }
	                            break;
	                        case 'MKL_LEADS':
	                            mcaData[mca_common_types_1.SystemToken.leadId] = objectId;
	                            if (woName) {
	                                mcaData[mca_common_types_1.SystemToken.leadNum] = woName;
	                            }
	                            break;
	                        default:
	                            break;
	                    }
	                }
	                // Not sure if this is normal but, the custom fields added in chat simulator get added as a JSON String via the special
	                // custom field named: extendedCustomFieldsJsonStr. Assumes the underlying JSON only contains simple Key/Value string pairs.
	                if (extCustJsonString && extCustJsonString.trim().length > 1) {
	                    try {
	                        const extendedCustomFields = JSON.parse(extCustJsonString);
	                        for (const key of Object.keys(extendedCustomFields)) {
	                            const convertToken = conversionMap[key];
	                            const value = extendedCustomFields[key];
	                            if (convertToken) {
	                                mcaLogger_1.McaLogger.info(`${this.pre} Extended Custom Fields: Found Mapped Mercury Custom Value: ${key}:${value} -> ${convertToken}`);
	                                mcaData[convertToken] = value;
	                            }
	                            else {
	                                mcaData[key] = value;
	                            }
	                        }
	                    }
	                    catch (ierr) {
	                        mcaLogger_1.McaLogger.error(`${this.pre} Exception in convertMercuryData, processing extendedCustomFields JSON String ${extCustJsonString} error: ${ierr}`);
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception in convertMercuryData: ${err}`);
	            }
	            return mcaData;
	        };
	        ///////////////////////////
	        // Mercury Event Handlers
	        ///////////////////////////
	        this.handleWorkOffer = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleWorkOffer: ');
	            try {
	                const dbgDetails = JSON.stringify(details);
	                mcaLogger_1.McaLogger.info(dbgDetails);
	            }
	            catch (err) { }
	            if (details && details instanceof mercury.MercuryOffer) {
	                try {
	                    let offer = details;
	                    if (offer.type && offer.type === mca_common_types_1.Constants.CHAT) {
	                        if (this.allowMcaChatAccess() === false && offer.workTypeCode && offer.workTypeCode !== 'Video') {
	                            mcaLogger_1.McaLogger.warn(this.pre + 'Skip Chat Offer, Chat Access is not allowed');
	                            return;
	                        }
	                        if (this.allowMcaVideoAccess() === false && offer.workTypeCode === 'Video') {
	                            mcaLogger_1.McaLogger.warn(this.pre + 'Skip Video Offer, Video Access is not allowed');
	                            return;
	                        }
	                    }
	                    if (offer.type && offer.type === mca_common_types_1.Constants.CHAT && offer.workTypeCode === 'Video') {
	                        // convert the offer from type CHAT to type Video
	                        const origOffer = offer;
	                        offer = new mercury.MercuryOffer(origOffer.identifier, origOffer.externalIdString, mca_common_types_1.Constants.VIDEO, origOffer.workTypeCode, origOffer.fusionChannelId, origOffer.conversationId, origOffer.created.getTime());
	                        offer.assignmentType = origOffer.assignmentType;
	                        offer.behavior = origOffer.behavior;
	                        offer.context = origOffer.context;
	                        offer.from = origOffer.from;
	                        offer.timeout = origOffer.timeout;
	                    }
	                    const commEvent = this.getCommEvent(mca_common_types_1.McaMethod.newComm, offer.identifier, null, offer.workTypeCode);
	                    this.pendingOffersMap.set(offer.identifier, offer);
	                    localStorage.setItem('pendingOffersMap', JSON.stringify(Array.from(this.pendingOffersMap.entries()), (key, value) => {
	                        if (key === 'context') {
	                            return JSON.stringify(Array.from(value.entries()));
	                        }
	                        return value;
	                    }));
	                    const contact = offer.from;
	                    const resource = contact.resource;
	                    const data = commEvent.data;
	                    if (resource) {
	                        // data.inData[SystemToken.email] = resource.emailAddress; //Engage SDK is missing emailAddress!!!
	                        if (!resource.name || resource.name.trim() === '') {
	                            data.inData[mca_common_types_1.SystemToken.contactName] = resource.firstName + ' ' + resource.lastName;
	                        }
	                        else {
	                            data.inData[mca_common_types_1.SystemToken.contactName] = resource.name;
	                        }
	                    }
	                    else {
	                        mcaLogger_1.McaLogger.error(this.pre + 'offer is missing resource');
	                    }
	                    if (!data.inData[mca_common_types_1.SystemToken.contactName] || data.inData[mca_common_types_1.SystemToken.contactName].trim() === '') {
	                        mcaLogger_1.McaLogger.warn(this.pre + 'Offer is missing contact name');
	                    }
	                    if (offer.type && offer.type === mca_common_types_1.Constants.VIDEO && offer.externalIdString) {
	                        data.inData.externalIdString = offer.externalIdString;
	                    }
	                    if (offer.fusionChannelId) {
	                        data.inData.fusionChannelId = offer.fusionChannelId;
	                    }
	                    data.workType = offer.workTypeCode; // Not set for Chat
	                    data.inData[mca_common_types_1.SystemToken.assignmentType] = offer.assignmentType;
	                    const context = offer.context;
	                    let realTimeFlag = 'Y';
	                    if (context) {
	                        if (context.get('fusionEngagementId')) {
	                            data.engagementId = context.get('fusionEngagementId');
	                        }
	                        this.convertMercuryData(context, data.inData, offer.assignmentType, mca_common_types_1.McaMethod.newComm);
	                        if (data.inData.channelType === mca_common_types_1.ChannelType.none) {
	                            data.channel = 'NONE';
	                            data.channelType = mca_common_types_1.ChannelType.none;
	                        }
	                        if (data.inData.RealtimeFlag) {
	                            realTimeFlag = data.inData.RealtimeFlag;
	                        }
	                        if (data.inData[mca_common_types_1.SystemToken.appClassification]) {
	                            data.appClassification = data.inData[mca_common_types_1.SystemToken.appClassification];
	                        }
	                        if (data.inData[mca_common_types_1.SystemToken.stripeCd]) {
	                            switch (data.inData[mca_common_types_1.SystemToken.stripeCd]) {
	                                case 'ORA_SVC_HRHD':
	                                case 'ORA_SVC_ISR':
	                                    if (data.appClassification !== 'ORA_HRHD') {
	                                        mcaLogger_1.McaLogger.warn(this.pre + 'Forcing appClassification to ORA_HRHD for stripeCode: ' + data.inData[mca_common_types_1.SystemToken.stripeCd]);
	                                        data.appClassification = 'ORA_HRHD';
	                                    }
	                                    break;
	                                default:
	                                    break;
	                            }
	                        }
	                    }
	                    if (offer.behavior === mercury.WorkOfferBehaviorType.ForcedAccept || data.channelType === mca_common_types_1.ChannelType.none || realTimeFlag === 'N') {
	                        // We EXPECT the behavior to be ForcedAccept for NON-RT Work Assignements
	                        // But, since this is currently undefined we'll also assume if the channelType is NONE then we are dealing with NON-RT
	                        // Also, noticed a new flag in the customFields, RealtimeFlag, So, what the heck we'll check this also.
	                        mcaLogger_1.McaLogger.warn(`${this.pre} Assuming a Non-RT Assignment for notification purposes only; behavior: ${offer.behavior} channelType: ${data.channelType} realTimeFlag ${realTimeFlag}`);
	                        const actions = [{ name: mca_common_types_1.ActionName.Notify }];
	                        commEvent.actions = actions;
	                        data.notificationType = mca_common_types_1.NotificationType.nonRealtime;
	                        data.notificationCategory = offer.type;
	                        // This is a HACK becuase, the workOffer type is coming as chat ...
	                        if (!offer.type || offer.type === mca_common_types_1.Constants.CHAT) {
	                            if (data.inData[mca_common_types_1.SystemToken.objectType]) {
	                                data.notificationCategory = data.inData[mca_common_types_1.SystemToken.objectType];
	                                mcaLogger_1.McaLogger.warn(`${this.pre} Invalid workOffer.type ${offer.type} for NON-RealTime Assignment using objectType: ${data.notificationCategory}`);
	                            }
	                        }
	                        if (data.inData[mca_common_types_1.SystemToken.interactionDescription]) {
	                            data.notificationSubtitle = data.inData[mca_common_types_1.SystemToken.interactionDescription];
	                        }
	                        let workTypeOrig = data.inData[mca_common_types_1.SystemToken.woType];
	                        // Convert OMNI Legacy request name to routableVOName
	                        if (workTypeOrig === mca_common_types_1.Constants.SERVICE_REQUEST) {
	                            workTypeOrig = mca_common_types_1.Constants.OMNI_SERVICE_REQUEST;
	                        }
	                        else if (workTypeOrig === mca_common_types_1.Constants.SERVICE_REQUEST_HRHD) {
	                            workTypeOrig = mca_common_types_1.Constants.OMNI_SVC_REQ_HRHD;
	                        }
	                        else if (workTypeOrig === mca_common_types_1.Constants.SERVICE_REQUEST_ISR) {
	                            workTypeOrig = mca_common_types_1.Constants.OMNI_SVC_REQ_ISR;
	                        }
	                        // assign workType first, in case we can find matching translation.
	                        let workTypeLabel = null;
	                        let workTypeLabelPlural = null;
	                        let workTypeViewable = 'N'; // Only set viewable to 'Y' when it's defined in work type
	                        const workName = data.inData[mca_common_types_1.SystemToken.woName]; // e.g. SR0000074379
	                        if (this.supportedChannels) {
	                            for (const channel of this.supportedChannels) {
	                                if (offer.workTypeCode === channel.workType) {
	                                    workTypeLabel = channel.displayName;
	                                    workTypeLabelPlural = channel.displayNamePlural;
	                                    break;
	                                }
	                            }
	                        }
	                        // Retrieve translated routable VO Name
	                        if (this.userConfigurations.routableVOInfo) {
	                            const routableVONames = this.userConfigurations.routableVOInfo;
	                            if (routableVONames && routableVONames[workTypeOrig]) {
	                                // We use routable table only if missing work type definition
	                                if (!workTypeLabel) {
	                                    workTypeLabel = routableVONames[workTypeOrig].LABEL;
	                                }
	                                if (!workTypeLabelPlural) {
	                                    workTypeLabelPlural = routableVONames[workTypeOrig].LABEL_PLURAL;
	                                }
	                                if (routableVONames[workTypeOrig].VIEWABLE) {
	                                    workTypeViewable = routableVONames[workTypeOrig].VIEWABLE;
	                                }
	                            }
	                        }
	                        // We use the woType only if both work type definitions and routable names are missing
	                        if (!workTypeLabel) {
	                            workTypeLabel = data.inData[mca_common_types_1.SystemToken.woType]; // e.g. Service Request
	                        }
	                        if (!workTypeLabelPlural) {
	                            workTypeLabelPlural = data.inData[mca_common_types_1.SystemToken.woType]; // e.g. Service Request
	                        }
	                        const stringTokens = {
	                            WORK_TYPE: workTypeLabel
	                        };
	                        const stringTokensPlural = {
	                            WORK_TYPE: workTypeLabelPlural
	                        };
	                        const title = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokens);
	                        // const title: string = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokens) + ': ' + workName;
	                        const titlePlural = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokensPlural);
	                        // const titlePlural: string = oj.applyParameters(this.getMcaBundleString('workTypeAssigned'), stringTokensPlural) + ': ' + workName;
	                        data.notificationIconTitle = workTypeLabel;
	                        data.notificationTitle = title;
	                        data.notificationTitlePlural = titlePlural;
	                        data.notificationViewable = workTypeViewable;
	                        this.checkAndSendNotify(commEvent, true);
	                    }
	                    else {
	                        this.internalProcessReceivedMessage(commEvent);
	                    }
	                }
	                catch (err) {
	                    mcaLogger_1.McaLogger.error(`${this.pre} Exeption processing WorkOffer: ${err}`);
	                }
	            }
	            else {
	                mcaLogger_1.McaLogger.error(this.pre + 'Invalid WORK_OFFER details', details);
	            }
	        };
	        this.handleChannelEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleChannelEvent: ' + eventName, details);
	        };
	        this.handleControlEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleControlEvent: ' + eventName, details);
	        };
	        this.handleActivityEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleActivityEvent: ' + eventName, details);
	        };
	        this.handleAvailableEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleAvailableEvent: ' + eventName);
	            try {
	                if (!details) {
	                    mcaLogger_1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing details`);
	                    return;
	                }
	                const mercuryStateMap = details.availability;
	                if (mercuryStateMap && mercuryStateMap.size > 0) {
	                    const keys = mercuryStateMap.keys();
	                    for (const key of keys) {
	                        const availState = mercuryStateMap.get(key);
	                        const isAvailable = availState === mercury.AvailabilityType.AVAILABLE;
	                        const availItem = this.getMcaChannelFromMercuryType(key);
	                        const agentState = {
	                            channelType: availItem.channelType,
	                            displayName: availItem.displayName,
	                            isAvailable,
	                            isLoggedIn: true,
	                            workType: key
	                        };
	                        mcaLogger_1.McaLogger.info(`${this.pre} ChannelType: ${availItem.channelType} isAvailable: ${isAvailable}`);
	                        const formattedEvent = { bubbles: true, cancelable: false, detail: agentState };
	                        const customEvent = new CustomEvent(mca_common_types_1.McaEventType.agentState, formattedEvent);
	                        this.dispatchClientEvent(customEvent);
	                        this.agentStateMap.set(key, agentState);
	                    }
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception processing ${eventName} Error: ${err}`);
	            }
	        };
	        this.getChatActiveMemberCount = (channel) => {
	            let count = 0;
	            if (channel.members && channel.members.length > 0) {
	                for (let i = 0; i < channel.members.length; i++) {
	                    const member = channel.members[i];
	                    if (!member.isConnected) {
	                        continue;
	                    }
	                    count++;
	                }
	            }
	            return count;
	        };
	        this.getChatActiveEndUserCount = (channel) => {
	            let count = 0;
	            if (channel.members && channel.members.length > 0) {
	                for (let i = 0; i < channel.members.length; i++) {
	                    const member = channel.members[i];
	                    if (!member.isConnected) {
	                        continue;
	                    }
	                    if (member.role !== mercury.ParticipationRoleType.END_USER) {
	                        continue;
	                    }
	                    count++;
	                }
	            }
	            return count;
	        };
	        this.handleMemberEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleMemberEvent: ' + eventName);
	            try {
	                if (!details) {
	                    mcaLogger_1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing details`);
	                    return;
	                }
	                const engagementId = details.channelIdentifier;
	                if (!engagementId) {
	                    mcaLogger_1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing engagementId`);
	                    return;
	                }
	                const mercuryChannel = this.getChannel(engagementId);
	                if (!mercuryChannel) {
	                    mcaLogger_1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing mercuryChannel`);
	                    return;
	                }
	                let member = details.participant;
	                if (!member) {
	                    member = details.member; // member is set to a different attribute base on the event???
	                    if (!member) {
	                        mcaLogger_1.McaLogger.info(this.pre + `Ignoring event ${eventName} missing participant`);
	                        return;
	                    }
	                }
	                let command = null;
	                const activeEndUserCount = this.getChatActiveEndUserCount(mercuryChannel);
	                const activeMembers = this.getChatActiveMemberCount(mercuryChannel);
	                switch (eventName) {
	                    case mercury.MercuryEventType.MEMBER_LEFT:
	                        if (activeEndUserCount < 1 || activeMembers < 1 || details.reason === 'AGENT_CONCLUDED' || (details.reason === 'IDLE_TIMEOUT' && member.role === mercury.ParticipationRoleType.CONFEREE && member.identifier === this.getMercurySession().clientIdentifier)) {
	                            // reason AGENT_CONCLUDED checking is a hack to solve CONFEREE not being notified of chat closed
	                            command = new mca_common_types_1.Command(mca_common_types_1.InteractionCommandName.disconnect, engagementId, null, null, null, mca_common_types_1.EventSource.mercury, mercuryChannel.workTypeCode);
	                        }
	                        else {
	                            mcaLogger_1.McaLogger.info(`${this.pre}Ignoring event ${eventName}, there are still multiple participants`);
	                        }
	                        break;
	                    default:
	                        mcaLogger_1.McaLogger.info(this.pre + 'Ignoring unhandled event: ' + eventName);
	                        break;
	                }
	                if (command) {
	                    mcaLogger_1.McaLogger.info(`${this.pre} Triggering disconnect for ${eventName} reason ${details.reason}`);
	                    this.invokeCommand(command);
	                }
	            }
	            catch (err) {
	                mcaLogger_1.McaLogger.error(`${this.pre} Exception processing ${eventName} Error: ${err}`);
	            }
	        };
	        this.handleMessageEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleMessageEvent: ' + eventName);
	            const engagementId = details.channelIdentifier;
	            const messageBody = details.body;
	            switch (eventName) {
	                case mercury.MercuryEventType.MESSAGE_ADDED:
	                    if (details.sender) {
	                        if (details.sender.role !== mercury.ParticipationRoleType.END_USER) {
	                            mcaLogger_1.McaLogger.info(this.pre + 'Ignoring event not generated by the END_USER  ' + eventName);
	                            break;
	                        }
	                    }
	                    // Initiate browser tab notification
	                    const event = this.getCommEvent(mca_common_types_1.McaMethod.newMessage, engagementId);
	                    let attnMessage = messageBody;
	                    if (messageBody && messageBody.length > 31) {
	                        attnMessage = messageBody.substr(0, 30);
	                    }
	                    else if (!messageBody || messageBody.trim().length < 1) {
	                        attnMessage = '...';
	                    }
	                    this.winMgr.notifyWindowForEngagement(engagementId, attnMessage, event, true);
	                    break;
	                default:
	                    mcaLogger_1.McaLogger.info(this.pre + 'Ignoring event: ' + eventName);
	            }
	        };
	        this.dispatchWindowEvent = (eventType, details) => {
	            const detail = details;
	            const formattedEvent = {
	                bubbles: true,
	                cancelable: false,
	                detail
	            };
	            const ne = new CustomEvent(eventType, formattedEvent);
	            window.dispatchEvent(ne);
	        };
	        this.handleConnectionErrorEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.error(`${this.pre} ==> handleConnectionErrorEvent: ${eventName} - details: ${details ? details.error : ''}`);
	            this.session = null;
	            this.loadStatus(mca_common_types_1.EventState.loaded);
	            this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionLost, details);
	        };
	        this.handleConnectionEstablishedEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(`${this.pre} ==> handleConnectionEstablishedEvent: ${eventName} - details: ${details}`);
	            this.loadStatus(mca_common_types_1.EventState.complete);
	            this.dispatchWindowEvent(mca_common_types_1.McaEventType.connectionEstablished, details);
	        };
	        this.handleUnstableConnectionEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.error(this.pre + '==> handleUnstableConnectionEvent: ' + eventName, details);
	            this.dispatchWindowEvent(mca_common_types_1.McaEventType.unstableConnection, details);
	        };
	        this.handleChatCancelEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleChatCancelEvent: ' + eventName, details);
	            const commEvent = this.getCommEvent(mca_common_types_1.McaMethod.closeComm, details.channelIdentifier, mca_common_types_1.CloseCommReason.canceled);
	            this.internalProcessReceivedMessage(commEvent);
	            this.dispatchWindowEvent(mca_common_types_1.McaEventType.removeNotifOnUi, details);
	            const offer = this.pendingOffersMap.get(commEvent.data.eventId);
	            if (offer) {
	                this.cleanupOffer(offer.identifier);
	            }
	        };
	        this.handleUploadEvent = (eventName, details) => {
	            mcaLogger_1.McaLogger.info(this.pre + '==> handleUploadEvent: ' + eventName, details);
	        };
	        this.bundle = Object.assign({}, oj_mca_common_1$1.McaCommon.mcaCoreStrings);
	        this.properties = properties;
	        if (properties.mcaBundle) {
	            this.mcaBundle = properties.mcaBundle;
	        }
	        this.initMcaFramework();
	        mcaLogger_1.McaLogger.info(`${this.pre} properties.loadStatus is ` + properties.loadStatus);
	        if (properties.loadStatus) {
	            if (typeof properties.loadStatus !== 'function') {
	                properties.loadStatus = ko$1.observable(mca_common_types_1.EventState.wait);
	                mcaLogger_1.McaLogger.warn(`${this.pre} converting invalid property type for loadStatus `);
	            }
	            this.loadStatus = properties.loadStatus;
	        }
	        if (!this.loadStatus) {
	            mcaLogger_1.McaLogger.warn(`${this.pre} Missing loadStatus property!`);
	            this.loadStatus = ko$1.observable(mca_common_types_1.EventState.wait);
	        }
	        this.loadStatus.subscribe(this.loadStatusListener);
	        this.chatConfigData.subscribe(this.chatConfigListener);
	        if (properties.onMcaEvent) {
	            this.mcaEventTarget = properties.onMcaEvent;
	        }
	        if (properties.onNotifyOnEvent) {
	            this.notificationEventTarget = properties.onNotifyOnEvent;
	        }
	        if (properties.onMcaAgentStateEvent) {
	            this.agentStateEventListener = properties.onMcaAgentStateEvent;
	        }
	        if (properties.userConfigurations) {
	            this.setUserConfigurations(properties.userConfigurations);
	        }
	        // try {
	        //   const config: any = JSON.parse(componentConfig);
	        //   const version: string = config.version;
	        //   McaLogger.info(`${this.pre} <ctor> Complete, version: ${version}`);
	        // } catch (err) {
	        //   McaLogger.error(`${this.pre} <ctor> Complete, version: UNKNOWN :[${err}]`);
	        // }
	        const pendingOffers = JSON.parse(localStorage.getItem('pendingOffersMap'), (key, value) => {
	            if (key === 'context') {
	                return new Map(JSON.parse(value));
	            }
	            if (key === 'created') {
	                return new Date(value);
	            }
	            return value;
	        });
	        if (pendingOffers) {
	            pendingOffers.forEach((pendingOffer) => {
	                const mercuryOffer = pendingOffer[1];
	                this.pendingOffersMap.set(mercuryOffer.identifier, mercuryOffer);
	            });
	        }
	    }
	    getInProgressChats() {
	        return (this.session ? this.session.getChannels() : []);
	    }
	    cleanupOffer(identifier) {
	        this.pendingOffersMap.delete(identifier);
	        localStorage.setItem('pendingOffersMap', JSON.stringify(Array.from(this.pendingOffersMap.entries()), (key, value) => {
	            if (key === 'context') {
	                return JSON.stringify(Array.from(value.entries()));
	            }
	            return value;
	        }));
	    }
	}
	// STATIC KEYS USED FOR DEV DEMOS
	McaEngageSdkModel.RESET_AGENT = 'clearChats';
	McaEngageSdkModel.CHAT_CONFIG_CACHE = 'mercuryChatConfig';
	mcaEngageSdkConnector.McaEngageSdkModel = McaEngageSdkModel;

	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(mcaAdfMain, "__esModule", { value: true });
	exports.McaAdfMain = mcaAdfMain.McaAdfMain = void 0;
	const ko = knockoutLatestExports;
	const mca_adf_container_1 = mcaAdfContainer;
	const mca_adf_presence_1 = mcaAdfPresence;
	const mca_adf_rest_helper_1 = mcaAdfRestHelper;
	const mca = requireMcaCommonTypes();
	const mca_engagement_manager_1 = mcaEngagementManager;
	const mca_mercury_copy_1 = mcaMercuryCopy;
	const mca_notification_manager_1 = mcaNotificationManager;
	const mca_shared_worker_1 = mcaSharedWorker;
	const mca_user_event_config_1 = mcaUserEventConfig;
	const mca_window_manager_1 = mcaWindowManager;
	const ToolbarLoadState_1 = ToolbarLoadState;
	const oj_mca_common_1 = requireOjMcaCommon();
	const oj_mca_mercury_1 = ojMcaMercury;
	const mca_engage_sdk_connector_1 = mcaEngageSdkConnector;
	const logger = require$$0;
	class McaAdfMain {
	    constructor() {
	        this.pre = '[McaAdfMain] ';
	        this.mcaBundle = null;
	        this.notificationsList = ko.observableArray();
	        this.mercuryLoadStatus = ko.observable(mca.EventState.wait);
	        this.mercuryEnabled = false;
	        this.toolbarEnabled = false;
	        this.omniEnabled = false;
	        this.configLoaded = ko.observable(false);
	        this.configLoadStatus = mca.EventState.wait;
	        this.initLinkInterface = (initLinkConfig) => {
	            this.agentStateCallback = initLinkConfig.agentStateChangeCallback;
	            this.faJwtTkn = initLinkConfig.faToken;
	            this.faSessionId = initLinkConfig.faSession;
	            this.mcaBundle = initLinkConfig.mcaBundle;
	            this.adfModuleCallback = initLinkConfig.adfCallback;
	            this.userPermissions = initLinkConfig.permissions;
	            this.webNotifIcons = initLinkConfig.webNotifIcons;
	            oj_mca_common_1.McaCommon.setAdfEngageSdkUrl(initLinkConfig.adfEngageSdkUrl);
	            if (this.restHelper) {
	                this.restHelper.updateJwtToken(this.faJwtTkn);
	            }
	            else {
	                this.restHelper = mca_adf_rest_helper_1.McaAdfRestHelper.getInstance(this.faJwtTkn);
	            }
	            this.initMcaFramework();
	        };
	        this.updateJwtTkn = (faJwtTkn) => {
	            this.faJwtTkn = faJwtTkn;
	            if (this.restHelper) {
	                this.restHelper.updateJwtToken(this.faJwtTkn);
	            }
	            if (this.sharedWorker) {
	                this.sharedWorker.updateJwtTkn(this.faJwtTkn);
	            }
	        };
	        this.getUserEventConfiguration = () => {
	            if (this.configLoaded() === false) {
	                this.fetchUserConfig();
	            }
	            return new Promise((resolve, reject) => {
	                if (this.configLoaded() === true) {
	                    if (this.configLoadStatus === mca.EventState.complete) {
	                        resolve({
	                            chatEnabled: this.mercuryEnabled,
	                            srEnabled: this.omniEnabled,
	                            toolbarEnabled: this.toolbarEnabled
	                        });
	                    }
	                    else {
	                        reject('Error loading user event configuration!');
	                    }
	                }
	                else {
	                    this.configLoaded.subscribe((value) => {
	                        if (value === true) {
	                            if (this.configLoadStatus === mca.EventState.complete) {
	                                resolve({
	                                    chatEnabled: this.mercuryEnabled,
	                                    srEnabled: this.omniEnabled,
	                                    toolbarEnabled: this.toolbarEnabled
	                                });
	                            }
	                            else {
	                                reject('Error loading user event configuration!');
	                            }
	                        }
	                    });
	                }
	            });
	        };
	        this.openCtiToolbar = () => {
	            if (this.toolbarEnabled) {
	                this.toolbarContainer.showToolbar();
	            }
	            else {
	                logger.warn(`${this.pre} Can't open CTI toolbar before configuration initialization!`);
	            }
	        };
	        this.toggleOmniAvailability = (channel) => {
	            if (this.presenceControl) {
	                this.presenceControl.toggleOmniAvailability(channel);
	            }
	        };
	        this.mcaNotificationAcceptedListener = (event) => {
	            if (event && event.notificationEventId) {
	                const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === event.notificationEventId);
	                if (posInArray !== -1) {
	                    let workType = null;
	                    if (this.notificationsList()[posInArray].data) {
	                        workType = this.notificationsList()[posInArray].data.workType;
	                    }
	                    const command = new mca.Command(mca.InteractionCommandName.accept, this.notificationsList()[posInArray].notificationEventId, null, null, this.notificationInvokeCommandCallback, this.notificationsList()[posInArray].notificationEventSource, workType);
	                    this.invokeCommand(command);
	                    this.notificationsList.splice(posInArray, 1);
	                }
	                this.updateNotifMap(mca.McaEventType.removeNotifToMap, event.notificationEventId);
	                if (this.notificationsList().length === 0) {
	                    this.winMgr.closeWebNotification(event.notificationEventId);
	                }
	            }
	        };
	        this.mcaNotificationRejectedListener = (event) => {
	            if (event && event.notificationEventId) {
	                const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === event.notificationEventId);
	                if (posInArray !== -1) {
	                    let workType = null;
	                    if (this.notificationsList()[posInArray].data) {
	                        workType = this.notificationsList()[posInArray].data.workType;
	                    }
	                    const command = new mca.Command(mca.InteractionCommandName.reject, this.notificationsList()[posInArray].notificationEventId, null, null, this.notificationInvokeCommandCallback, this.notificationsList()[posInArray].notificationEventSource, workType);
	                    this.invokeCommand(command);
	                    this.notificationsList.splice(posInArray, 1);
	                }
	                this.updateNotifMap(mca.McaEventType.removeNotifToMap, event.notificationEventId);
	                if (this.notificationsList().length === 0) {
	                    this.winMgr.closeWebNotification(event.notificationEventId);
	                }
	            }
	        };
	        this.mcaNotificationExpiredListener = (event) => {
	            if (event && event.notificationEventId) {
	                const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === event.notificationEventId);
	                if (posInArray !== -1) {
	                    let workType = null;
	                    const notificationEvent = this.notificationsList()[posInArray];
	                    if (notificationEvent === null || notificationEvent === void 0 ? void 0 : notificationEvent.data) {
	                        workType = notificationEvent.data.workType;
	                    }
	                    if (notificationEvent.notificationCategory === mca.ChannelType.chat) {
	                        let commandName = mca.InteractionCommandName.chatOfferTimeout;
	                        if (mca.NotificationAssignType.AUTO === notificationEvent.assignType) {
	                            commandName = mca.InteractionCommandName.autoAccept;
	                        }
	                        else if (mca.NotificationAssignType.FORCED === notificationEvent.assignType) {
	                            commandName = mca.InteractionCommandName.forceAccept;
	                        }
	                        const command = new mca.Command(commandName, notificationEvent.notificationEventId, null, null, this.notificationInvokeCommandCallback, notificationEvent.notificationEventSource, workType);
	                        logger.log(`${this.pre} mcaNotificationExpiredListener - invokeCommand: ${commandName}`, notificationEvent);
	                        this.invokeCommand(command);
	                    }
	                }
	                this.updateNotifMap(mca.McaEventType.removeNotifToMap, event.notificationEventId);
	                if (this.notificationsList().length === 0) {
	                    this.winMgr.closeWebNotification(event.notificationEventId);
	                }
	            }
	        };
	        this.getMcaBundleString = (key) => {
	            let returnString = null;
	            if (this.mcaBundle) {
	                returnString = this.mcaBundle[key];
	            }
	            if (!returnString) {
	                if (this.bundle[key]) {
	                    returnString = this.bundle[key];
	                }
	                else {
	                    logger.error(this.pre + 'unable to find mca translation bundle with String key ==> ' + key);
	                    returnString = '*' + key;
	                }
	            }
	            return returnString;
	        };
	        this.initMcaFramework = () => {
	            oj_mca_common_1.McaCommon.setSessionId(this.faSessionId);
	            this.winMgr = mca_window_manager_1.WindowManager.getInstance();
	            this.winMgr.setMcaBundle(this.mcaBundle);
	            this.engMgr = mca_engagement_manager_1.EngagementManager.getInstance();
	            this.notifMgr = mca_notification_manager_1.NotificationManager.getInstance();
	            window.addEventListener(mca.McaEventType.addNotifOnUi, this.updateNotifListEventListener, false);
	            window.addEventListener(mca.McaEventType.removeNotifOnUi, this.updateNotifListEventListener, false);
	            window.addEventListener(mca.McaEventType.unstableConnection, this.unstableConnectionEventListener, false);
	            window.addEventListener(mca.McaEventType.connectionLost, this.connectionLostEventListener, false);
	            window.addEventListener(mca.McaEventType.connectionEstablished, this.connectionEstablishedEventListener, false);
	            window.addEventListener(mca.McaEventType.reloadChatConfig, this.reloadChatConfigEventListener, false);
	            window.addEventListener('mcaAdfRenewTkn', this.renewTknListener, false);
	            window.addEventListener('unload', this.unloadEventListener, false);
	            window.addEventListener('mcaInitOmniComplete', this.initOmniSessionCompleteListener, false);
	            window.addEventListener('mcaSWRenewTkn', this.renewTknListener, false);
	            this.engMgr.setResponseTarget(this.appEventResponseHandler, mca.EventSource.application);
	        };
	        this.initContainer = () => {
	            const properties = {};
	            properties.userConfigurations = this.userConfigurations;
	            // properties.loadStatus = TBD; // writeback property
	            properties.onMcaEvent = this.mcaEventListener;
	            properties.onMcaAgentStateEvent = this.agentStateEventListener;
	            properties.onNotifyOnEvent = this.notificationEventListener;
	            this.toolbarContainer = new mca_adf_container_1.McaAdfContainer(properties);
	        };
	        this.initMercury = () => {
	            logger.info(`${this.pre} Loaded Mercury Adapter`);
	            const properties = {};
	            properties.userConfigurations = this.userConfigurations;
	            properties.loadStatus = this.mercuryLoadStatus; // writeback property
	            properties.onMcaEvent = this.mcaEventListener;
	            properties.onMcaAgentStateEvent = this.agentStateEventListener;
	            properties.onNotifyOnEvent = this.notificationEventListener;
	            properties.onNotifyOffEvent = this.notificationEventListener;
	            properties.mcaBundle = this.mcaBundle;
	            if (oj_mca_common_1.McaCommon.isEngageSDKEnabled()) {
	                this.mercuryAdapter = new mca_engage_sdk_connector_1.McaEngageSdkModel(properties);
	            }
	            else {
	                this.mercuryAdapter = new oj_mca_mercury_1.McaMercuryModel(properties);
	            }
	            this.mercuryLoadStatus.subscribe(eventState => {
	                if (eventState === mca.EventState.complete) {
	                    this.mercuryReadyPromiseResolverRef();
	                }
	            });
	        };
	        this.initOmniSessionCompleteListener = (event) => {
	            if (event && event.detail) {
	                if (event.detail.status === 'Success') {
	                    this.initPresence();
	                }
	            }
	        };
	        this.initPresence = () => {
	            const properties = {};
	            properties.userConfigurations = this.userConfigurations;
	            properties.mercuryAdapter = this.mercuryAdapter;
	            properties.toolbarAdapter = this.toolbarContainer;
	            properties.onMcaAgentStateEvent = this.agentStateEventListener;
	            this.presenceControl = new mca_adf_presence_1.McaAdfPresence(properties);
	        };
	        this.renewTknListener = (renewEvent) => {
	            if (this.adfModuleCallback) {
	                this.adfModuleCallback('renewTkn');
	            }
	        };
	        this.initCurrentAgentChannelStates = () => {
	            const phoneState = {
	                channelType: mca.ChannelType.phone,
	                isAvailable: false,
	                isLoggedIn: false
	            };
	            if (!this.currentAgentChannelStates) {
	                this.currentAgentChannelStates = new Array();
	            }
	            this.currentAgentChannelStates.push(phoneState);
	        };
	        this.updateAgentStatus = (agentState) => {
	            let foundStateForChannel = false;
	            for (let i = 0; i < this.currentAgentChannelStates.length; i++) {
	                const state = this.currentAgentChannelStates[i];
	                if (agentState.channelType === state.channelType) {
	                    this.currentAgentChannelStates[i] = agentState;
	                    foundStateForChannel = true;
	                    break;
	                }
	            }
	            if (!foundStateForChannel) {
	                this.currentAgentChannelStates.push(agentState);
	            }
	        };
	        this.appEventResponseHandler = (response, event) => {
	            logger.info(this.pre + 'appEventResponseHandler ==> ');
	            const newEvent = this.convertMcaEvent(event, response);
	            if (newEvent && event.method === mca.McaMethod.previewComm) {
	                const command = this.engMgr.getLogCallCommand();
	                if (command) {
	                    const commandResp = new mca.CommandResponse(command.command, event.data.result, response.eventId, response.eventId, response.outData);
	                    command.responseCallback(commandResp);
	                }
	            }
	            else if (newEvent) {
	                this.dispatchClientEvent(newEvent); // 07-28-20 Added for Unknown Caller Flow
	            }
	        };
	        this.agentStateEventListener = (event) => {
	            if (event == null || event.detail == null) {
	                return;
	            }
	            const agentState = event.detail;
	            logger.info(this.pre + 'agentStateEventListener ==> ', agentState);
	            this.updateAgentStatus(agentState);
	            // Must Recreate the Event for Rebroadcast to prevent Duplicate Event Exception
	            const formattedEvent = { bubbles: true, cancelable: false, detail: agentState };
	            const newEvent = new CustomEvent(mca.McaEventType.agentState, formattedEvent);
	            // Note: No MCA Consumers in ADF but ADF wrapper is expecting this events 
	            this.agentStateCallback(newEvent);
	        };
	        this.convertMcaEvent = (event, response) => {
	            let retVal = null;
	            let eventName = null;
	            let detail;
	            if (!event || !event.data) {
	                logger.warn(this.pre + 'convertMcaEvent: missing event.data');
	                return;
	            }
	            if (!event.data.engagementId) {
	                event.data.engagementId = event.data.eventId;
	            }
	            if (event && event.method) {
	                switch (event.method) {
	                    case mca.McaMethod.newComm:
	                        break;
	                    case mca.McaMethod.startComm:
	                        if (event.data.engagementId === this.startCommEngagementId) {
	                            break;
	                        }
	                        // In case of Lead with no Contact, toolbar should display nothing not Unknown
	                        const ob = response.outData[mca.SystemToken.leadId];
	                        const displayName = response.outData[mca.SystemToken.displayName];
	                        if (ob && displayName === 'Unknown') {
	                            response.outData[mca.SystemToken.displayName] = '';
	                        }
	                        eventName = mca.McaEventType.screenPop;
	                        detail = this.getScreenPopData(event, response);
	                        if (!detail && this.winMgr.isWindowFocused()) {
	                            this.winMgr.notifyWindowForEngagement(event.data.engagementId, this.getMcaBundleString('statusActive'), event);
	                            this.winMgr.focusWindowForEngagement(event.data.engagementId);
	                        }
	                        break;
	                    case mca.McaMethod.updateComm:
	                        // This is very ugly but time is short and works until a more elegant solution
	                        if (this.winMgr.isMsiApp()) {
	                            // Used to Update the Engagement Header in MSI App
	                            eventName = mca.McaEventType.updateComm;
	                            detail = response;
	                        }
	                        else {
	                            // Used in Unknown Caller Page to trigger navigation
	                            eventName = mca.McaEventType.screenPop;
	                            detail = this.getScreenPopData(event, response);
	                        }
	                        break;
	                    case mca.McaMethod.getScreenPopDataEvent:
	                        eventName = mca.McaEventType.screenPop;
	                        detail = this.getScreenPopData(event, response);
	                        break;
	                    case mca.McaMethod.closeComm:
	                        eventName = mca.McaEventType.endComm;
	                        detail = this.getWrapupDetail(event, response);
	                        if (detail) {
	                            if (detail.reason && detail.reason === mca.CloseCommReason.wrapup) {
	                                eventName = mca.McaEventType.wrapUp;
	                            }
	                        }
	                        this.startCommEngagementId = null; // must reset in case chat gets transferred back
	                        break;
	                    case mca.McaMethod.transferedToQueue:
	                        eventName = mca.McaEventType.transferToQueue;
	                        detail = this.getWrapupDetail(event, response);
	                        break;
	                    case mca.McaMethod.interactionControlsChanged:
	                        eventName = mca.McaEventType.interactionControlsChanged;
	                        detail = this.getInteractionControlStateDetail(event);
	                        break;
	                    case mca.McaMethod.previewComm:
	                        eventName = mca.McaEventType.previewComm;
	                        const newEvent = event;
	                        if (newEvent.data) {
	                            newEvent.data.channelId = response.channelId;
	                            newEvent.data.outData = response.outData;
	                        }
	                        detail = { event, response, invokeCommand: this.invokeCommand };
	                        break;
	                }
	            }
	            if (eventName && detail) {
	                const formattedEvent = { bubbles: true, cancelable: false, detail };
	                retVal = new CustomEvent(eventName, formattedEvent);
	            }
	            return retVal;
	        };
	        this.dispatchClientEvent = (event) => __awaiter(this, void 0, void 0, function* () {
	            if (event) {
	                let doDispatch = true;
	                let engagementId;
	                let origEvent;
	                if (event.detail && event.detail.mcaRefEvent) {
	                    origEvent = event.detail.mcaRefEvent;
	                    engagementId = origEvent.data.engagementId;
	                }
	                switch (event.type) {
	                    case mca.McaEventType.screenPop:
	                        if (this.winMgr.isMsiApp()) {
	                            if (origEvent && origEvent.method === mca.McaMethod.updateComm) {
	                                logger.info(this.pre + 'Skipping Screen Pop for updateCommEvent in MSI Page');
	                                doDispatch = false;
	                                break;
	                            }
	                        }
	                        // for ADF we always screenpop in a new window
	                        // if (this.enableNewWindowScreenpop()) {
	                        doDispatch = false;
	                        if (event.detail.pageKey) {
	                            const pageKey = event.detail.pageKey;
	                            let forcedScreenPop = false;
	                            // Fix Chat Unknown Caller flow issue
	                            // need to check and record Unknown Caller page here
	                            // not needed in ADF
	                            // if (event.detail.isUnknownCallerPage) {
	                            //   this.currentUnknownPageScreenPop = event.detail;
	                            // }
	                            if (origEvent && origEvent.data && origEvent.data.inData && origEvent.data.inData.forcedStartComm === true) {
	                                forcedScreenPop = true;
	                            }
	                            const screenPop = this.winMgr.getCurrentScreenPop();
	                            if ((screenPop && screenPop.pageKey === pageKey) || forcedScreenPop) {
	                                logger.info(this.pre + 'ScreenPop *IS* intended for this window!');
	                                doDispatch = true;
	                                this.winMgr.setScreenPop(event.detail);
	                                break;
	                            }
	                            if (event.detail.displayMode === mca.PageDisplayMode.None) {
	                                // Outbound C2D Case where we don't want to open a new Window
	                                logger.info(this.pre + 'Associating Outbound Call with this window!');
	                                doDispatch = true;
	                                this.winMgr.setScreenPop(event.detail);
	                                break;
	                            }
	                            else if (event.detail.displayMode === mca.PageDisplayMode.CloseWindow) {
	                                // Outbound C2D Case where we are on the Unknown_Contact page
	                                logger.info(this.pre + 'Associating Outbound Call with Original window!');
	                                yield this.winMgr.setScreenPop(event.detail, event.detail.windowName);
	                                this.winMgr.closeCurrentWindow();
	                                break;
	                            }
	                            if (event.detail.isUnknownCallerPage &&
	                                event.detail.mcaRefEvent &&
	                                event.detail.mcaRefEvent.data &&
	                                this.checkClickToDialFromHere(event.detail.mcaRefEvent.data.inData)) {
	                                // Outbound C2D Case where we need to launch the Unknown_Contact page
	                                // Send Event to clear out the Engagement Component while it is displayed on the
	                                // Uknown_Contact page.  Another event will be fired to refresh it after a contact
	                                // is identified.
	                                doDispatch = false;
	                                const detail = {
	                                    event: event.detail.event,
	                                    invokeCommand: this.invokeCommand,
	                                    response: event.detail.response
	                                };
	                                const formattedEvent = { bubbles: true, cancelable: false, detail };
	                                // We can just use endComm here since the engagement is in preview mode
	                                const tmpEvent = new CustomEvent(mca.McaEventType.endComm, formattedEvent);
	                                logger.info(this.pre + 'Dispatching Event to Close Engagement Temporarily', tmpEvent);
	                                // this event bubbles up to document listeners ie, consumers don't need a direct binding
	                                // for ADF there are no listeners
	                                // this.composite.dispatchEvent(tmpEvent);
	                            }
	                        }
	                        // not needed in ADF
	                        // if (event.detail.isUnknownCallerPage) {
	                        //   this.currentUnknownPageScreenPop = event.detail;
	                        // }
	                        let result = null;
	                        result = yield this.winMgr.openTab(event.detail);
	                        // not needed in ADF
	                        // if (event.detail.isUnknownCallerPage) {
	                        //   this.currentUnknownPageScreenPopResult = result;
	                        // }
	                        if (result && result.windowName === window.name) {
	                            doDispatch = true;
	                        }
	                        else {
	                            logger.info(this.pre + 'Ignoring Event: ' + event.type + ' targeted for another window: ');
	                        }
	                        break;
	                    case mca.McaEventType.endComm:
	                        doDispatch = this.checkTargetedEvent(origEvent);
	                        // no need to set focus on endComm
	                        if (doDispatch) {
	                            logger.info(this.pre + 'EndComm *IS* intended for this window!');
	                        }
	                        break;
	                    case mca.McaEventType.wrapUp:
	                        doDispatch = this.checkTargetedEvent(origEvent);
	                        this.winMgr.focusWindowForEngagement(engagementId);
	                        this.winMgr.notifyWindowForEngagement(engagementId, this.getMcaBundleString('wrapUp'), origEvent);
	                        if (doDispatch) {
	                            logger.info(this.pre + 'WrapUp *IS* intended for this window!');
	                        }
	                        break;
	                }
	                if (doDispatch) {
	                    logger.info(this.pre + 'Dispatching Event: ' + event.type, event.detail);
	                    // for ADF there is no listener for this event to be dispatched
	                }
	            }
	        });
	        this.fetchUserConfig = () => {
	            const endPoint = '/crmRestApi/resources/latest/multiChannelAdapterEvents/action/fetchUserEventConfiguration';
	            const endPointOptions = {
	                headers: {
	                    'Content-Type': 'application/vnd.oracle.adf.action+json'
	                },
	                method: 'POST'
	            };
	            this.restHelper
	                .fetch(endPoint, endPointOptions)
	                .then((result) => {
	                try {
	                    const jsonResult = JSON.parse(result);
	                    this.handleRestResponse(jsonResult.result);
	                }
	                catch (parseErr) {
	                    logger.error(`${this.pre} Error parsing fetchUserEventConfiguration response: ${parseErr}`);
	                    this.handleRestResponse({});
	                }
	            })
	                .catch((reason) => {
	                this.handleRestResponse(reason);
	            });
	        };
	        this.handleRestResponse = (result) => {
	            this.configLoadStatus = mca.EventState.start;
	            try {
	                const info = mca_user_event_config_1.McaUserEventConfig.parseUserEventConfiguration(result);
	                // check if toolbar should be enabled
	                if (info.toolbarInfo.orientation === mca.ToolbarLayout.redwood && info.toolbarInfo.url && info.toolbarInfo.url.toLowerCase().startsWith('http')) {
	                    this.toolbarEnabled = true;
	                }
	                else {
	                    logger.warn(this.pre + 'Invalid Toolbar Configuration ,' + info.toolbarInfo.displayName + ', VBCS Apps require a Redwood Layout');
	                    info.toolbarInfo.loadState = ToolbarLoadState_1.ToolbarLoadState.invalidConfigured;
	                }
	                // window manager enable web notifications
	                this.winMgr.enableWebNotfications(info.userDetails.profileOmniDesktopNotification);
	                if (info.toolbarInfo && info.toolbarInfo.devMode === true && !info.userDetails.agentId) {
	                    // so we can test in dev mode when rest isn't working
	                    const userDetails = {
	                        NLS_LANG: 'en',
	                        NLS_LOCALE: 'us',
	                        agentId: 'MCADEV',
	                        agentPartyId: 456,
	                        appName: mca.AppName.mca,
	                        debugMode: 'Y',
	                        faTrustToken: 'FAKE',
	                        features: null,
	                        profileOmniDesktopNotification: true
	                    };
	                    info.userDetails = userDetails;
	                }
	                if (this.userPermissions) {
	                    info.userDetails.permissions = this.userPermissions;
	                }
	                this.userConfigurations = info;
	                oj_mca_common_1.McaCommon.setUserConfigurations(this.userConfigurations);
	                const newNotifConfig = {
	                    nonRealtimeAutoDismissInterval: Number.isNaN(Number(info.mercuryInfo.omniBrowserNotificationAutoInt)) ? 30 : Number(info.mercuryInfo.omniBrowserNotificationAutoInt),
	                    nonRealtimeDesktopNotificationEnabled: info.mercuryInfo.omniDesktopNotificationEnabled,
	                    nonRealtimeNotificationEnabled: info.mercuryInfo.omniBrowserNotificationEnabled,
	                    nonRealtimeRollupThreshold: Number.isNaN(Number(info.mercuryInfo.omniNotificationMutliAggrThreshold)) ? 3 : Number(info.mercuryInfo.omniNotificationMutliAggrThreshold)
	                };
	                this.notifConfig = newNotifConfig;
	                if (info.mercuryInfo.srRoutingEnabled) {
	                    this.omniEnabled = true;
	                }
	                if (info.mercuryInfo.chatEnabled === false) {
	                    logger.warn(`${this.pre} chatEnabled is false`);
	                }
	                else if (!oj_mca_common_1.McaCommon.isValidUrl(info.mercuryInfo.chatServerEndPoint)) {
	                    logger.warn(`${this.pre} osvcChatEndPoint URL is invalid: ${info.mercuryInfo.chatServerEndPoint}`);
	                }
	                else {
	                    this.mercuryEnabled = true;
	                }
	                if (this.toolbarEnabled) {
	                    this.initContainer();
	                }
	                if (this.mercuryEnabled) {
	                    this.initMercury();
	                }
	                if (this.mercuryEnabled || (this.omniEnabled && this.userConfigurations.userDetails.agentPartyId)) {
	                    this.sharedWorker.initialize(this.userConfigurations, this.faSessionId);
	                    this.sharedWorker.sendRequest({
	                        method: 'InitOmniSession'
	                    });
	                    // On listener response to continue with keep-alive and retrieve availability
	                    // Move initPresence() to listener response for 'InitOmniSession'
	                }
	                else if (this.toolbarEnabled) {
	                    this.initPresence();
	                }
	                // TODO
	                // if (reloadConfigOnly && this.mercuryEnabled) {
	                //   const context: any = {
	                //     previousValue: null,
	                //     property: 'userConfigurations',
	                //     updatedFrom: 'external',
	                //     value: this.userConfigurations()
	                //   };
	                //   this.mercury.propertyChanged(context);
	                // }
	                this.configLoadStatus = mca.EventState.complete;
	            }
	            catch (err) {
	                logger.warn(this.pre + 'Exception processing REST Response', err);
	                this.configLoadStatus = mca.EventState.fail;
	            }
	            finally {
	                this.configLoaded(true);
	                if (this.toolbarEnabled || this.mercuryEnabled) {
	                    this.initMcaNotifications();
	                }
	            }
	        };
	        this.initMcaNotifications = () => {
	            // initiate notifMgr and refresh notification ui to latest
	            const notifKeys = this.notifMgr.getNotificationKeys();
	            if (notifKeys && notifKeys.length > 0) {
	                const unprocessedNotifKeys = notifKeys.filter((notifKey) => {
	                    const notificationItem = this.notifMgr.getNotification(notifKey);
	                    return !this.isNotificationAlreadyProcessed(notificationItem.notificationEngagementId);
	                });
	                if (unprocessedNotifKeys && unprocessedNotifKeys.length > 0) {
	                    for (const notifKey of unprocessedNotifKeys) {
	                        const notifItem = this.notifMgr.getNotification(notifKey);
	                        this.notificationsList.push(notifItem);
	                        // show notification 
	                        logger.info(`${this.pre} initMcaNotifications ==> show notication: ${JSON.stringify(notifItem)}`);
	                        this.adfModuleCallback('notification', notifItem);
	                    }
	                }
	            }
	        };
	        this.isNotificationAlreadyProcessed = (engagementId) => {
	            const engagement = this.engMgr.getEngagement(engagementId);
	            if (engagement) {
	                const startComm = engagement.stateMap[mca.McaMethod.startComm];
	                const closeComm = engagement.stateMap[mca.McaMethod.closeComm];
	                return startComm && !closeComm;
	            }
	            return false;
	        };
	        this.notificationEventListener = (event) => __awaiter(this, void 0, void 0, function* () {
	            logger.info(this.pre + 'notificationEventListener ==> ' + event.type);
	            if (event.type === mca.McaEventType.notifyOn) {
	                const newNotificationEvent = {
	                    data: event.detail.event.data,
	                    method: event.detail.event.method,
	                    notificationCategory: '',
	                    notificationEngagementId: '',
	                    notificationEventId: '',
	                    notificationIconTitle: null,
	                    notificationStartTimestamp: Date.now(),
	                    notificationSubtitle: null,
	                    notificationTitle: null,
	                    notificationTitlePlural: null,
	                    notificationType: mca.NotificationType.realtime
	                };
	                const data = event.detail.event.data;
	                newNotificationEvent.notificationTitle = this.getMcaBundleString('unknownContact');
	                newNotificationEvent.notificationSubtitle = undefined;
	                if (event.detail.event && event.detail.event.data) {
	                    newNotificationEvent.notificationEventId = event.detail.event.data.eventId;
	                    newNotificationEvent.notificationEngagementId = event.detail.event.data.engagementId;
	                    newNotificationEvent.notificationEventSource = event.detail.event.eventSource;
	                }
	                else {
	                    newNotificationEvent.notificationEventId = '';
	                    newNotificationEvent.notificationTitle = this.getMcaBundleString('unknownContact');
	                    newNotificationEvent.notificationSubtitle = '';
	                }
	                if (newNotificationEvent.notificationEventId && newNotificationEvent.notificationEventId !== '') {
	                    const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === newNotificationEvent.notificationEventId);
	                    let existingNotificationEvent;
	                    if (posInArray !== -1) {
	                        existingNotificationEvent = this.notificationsList()[posInArray];
	                    }
	                    if (event.detail.response && event.detail.response.outData) {
	                        let chatSubject = '';
	                        let chatQueueName = '';
	                        let chatCustomerAndAccount = '';
	                        if (event.detail.event.data.channelType === mca.ChannelType.chat) {
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                if (event.detail.response.outData[mca.SystemToken.interactionDescription]) {
	                                    newNotificationEvent.notificationTitle = '"' + event.detail.response.outData[mca.SystemToken.interactionDescription] + '"';
	                                    chatSubject = event.detail.response.outData[mca.SystemToken.interactionDescription];
	                                }
	                                else {
	                                    if (event.detail.response.outData[mca.SystemToken.contactName]) {
	                                        newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.contactName];
	                                    }
	                                    else {
	                                        if (event.detail.response.outData[mca.SystemToken.email]) {
	                                            newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.email];
	                                        }
	                                    }
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (event.detail.response.outData[mca.SystemToken.contactName]) {
	                                if (event.detail.response.outData[mca.SystemToken.accountName]) {
	                                    chatCustomerAndAccount = event.detail.response.outData[mca.SystemToken.contactName] + ',' + event.detail.response.outData[mca.SystemToken.accountName];
	                                }
	                                else {
	                                    chatCustomerAndAccount = event.detail.response.outData[mca.SystemToken.contactName];
	                                }
	                            }
	                            if (event.detail.response.outData[mca.SystemToken.queueName]) {
	                                newNotificationEvent.notificationSubtitle = event.detail.response.outData[mca.SystemToken.queueName];
	                                chatQueueName = event.detail.response.outData[mca.SystemToken.queueName];
	                            }
	                            newNotificationEvent.tooltip = chatSubject + '\n' + 'Queue: ' + chatQueueName + '\n' + 'Customer: ' + chatCustomerAndAccount;
	                            if (existingNotificationEvent) {
	                                newNotificationEvent.timeoutValue = existingNotificationEvent.timeoutValue;
	                                newNotificationEvent.assignType = existingNotificationEvent.assignType;
	                            }
	                            else if (event.detail.event.data.inData[mca.SystemToken.offerTimeout]) {
	                                newNotificationEvent.timeoutValue = event.detail.event.data.inData[mca.SystemToken.offerTimeout];
	                            }
	                            else if (this.userConfigurations && this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.profileChatOfferTimeout) {
	                                newNotificationEvent.timeoutValue = Number(this.userConfigurations.mercuryInfo.profileChatOfferTimeout);
	                            }
	                            else {
	                                newNotificationEvent.timeoutValue = 30;
	                            }
	                            this.addNotificationAssignType(newNotificationEvent, event.detail.event.data.inData[mca.SystemToken.assignmentType]);
	                        }
	                        else if (event.detail.event.data.channelType === mca.ChannelType.video) {
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                // TODO
	                                // if (event.detail.response.outData[mca.SystemToken.email]) {
	                                //   newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.email];
	                                // }
	                                if (event.detail.response.outData[mca.SystemToken.contactName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.contactName];
	                                }
	                                if (event.detail.response.outData[mca.SystemToken.displayName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.displayName];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (event.detail.response.outData[mca.SystemToken.queueName]) {
	                                newNotificationEvent.notificationSubtitle = event.detail.response.outData[mca.SystemToken.queueName];
	                                chatQueueName = event.detail.response.outData[mca.SystemToken.queueName];
	                            }
	                            if (event.detail.response.outData[mca.SystemToken.accountName]) {
	                                chatCustomerAndAccount = event.detail.response.outData[mca.SystemToken.accountName];
	                            }
	                            else if (event.detail.response.outData[mca.SystemToken.primaryAccountName]) {
	                                chatCustomerAndAccount = event.detail.response.outData[mca.SystemToken.primaryAccountName];
	                            }
	                            else {
	                                chatCustomerAndAccount = this.getMcaBundleString('unknownContact');
	                            }
	                            newNotificationEvent.tooltip = 'Queue: ' + chatQueueName + '\n' + 'Customer: ' + chatCustomerAndAccount;
	                            if (existingNotificationEvent) {
	                                newNotificationEvent.timeoutValue = existingNotificationEvent.timeoutValue;
	                            }
	                            else if (event.detail.response.outData[mca.SystemToken.offerTimeout]) {
	                                newNotificationEvent.timeoutValue = event.detail.response.outData[mca.SystemToken.offerTimeout];
	                            }
	                            else if (this.userConfigurations && this.userConfigurations.mercuryInfo && this.userConfigurations.mercuryInfo.profileChatOfferTimeout) {
	                                newNotificationEvent.timeoutValue = Number(this.userConfigurations.mercuryInfo.profileChatOfferTimeout);
	                            }
	                            else if (event.detail.event.data.channelType !== mca.ChannelType.phone) {
	                                newNotificationEvent.timeoutValue = 30;
	                            }
	                        }
	                        else {
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                if (event.detail.response.outData[mca.SystemToken.contactName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.contactName];
	                                }
	                                if (event.detail.response.outData[mca.SystemToken.displayName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.response.outData[mca.SystemToken.displayName];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationSubtitle === undefined ||
	                                existingNotificationEvent.notificationSubtitle !== '') {
	                                if (event.detail.response.outData[mca.SystemToken.contactJobTitle]) {
	                                    newNotificationEvent.notificationSubtitle = event.detail.response.outData[mca.SystemToken.contactJobTitle];
	                                }
	                                if (event.detail.response.outData[mca.SystemToken.ani]) {
	                                    newNotificationEvent.notificationSubtitle = event.detail.response.outData[mca.SystemToken.ani];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationSubtitle = existingNotificationEvent.notificationSubtitle;
	                            }
	                        }
	                    }
	                    else if (event.detail.event && event.detail.event.data && event.detail.event.data.inData) {
	                        if (event.detail.event.data.inData[mca.SystemToken.offerTimeout]) {
	                            newNotificationEvent.timeoutValue = event.detail.event.data.inData[mca.SystemToken.offerTimeout];
	                        }
	                        else if (this.userConfigurations && this.userConfigurations.mercuryInfo &&
	                            this.userConfigurations.mercuryInfo.profileChatOfferTimeout && event.detail.event.data.channelType !== mca.ChannelType.phone) {
	                            newNotificationEvent.timeoutValue = Number(this.userConfigurations.mercuryInfo.profileChatOfferTimeout);
	                        }
	                        let chatSubject = '';
	                        let chatQueueName = '';
	                        let chatCustomerAndAccount = '';
	                        if (event.detail.event.data.channelType === mca.ChannelType.chat) {
	                            this.addNotificationAssignType(newNotificationEvent, event.detail.event.data.inData[mca.SystemToken.assignmentType]);
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                if (event.detail.event.data.inData[mca.SystemToken.interactionDescription]) {
	                                    newNotificationEvent.notificationTitle = '"' + event.detail.event.data.inData[mca.SystemToken.interactionDescription] + '"';
	                                    chatSubject = event.detail.event.data.inData[mca.SystemToken.interactionDescription];
	                                }
	                                else {
	                                    if (event.detail.event.data.inData[mca.SystemToken.contactName]) {
	                                        newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.contactName];
	                                    }
	                                    else {
	                                        if (event.detail.event.data.inData[mca.SystemToken.email]) {
	                                            newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.email];
	                                        }
	                                    }
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (event.detail.event.data.inData[mca.SystemToken.contactName]) {
	                                if (event.detail.event.data.inData[mca.SystemToken.accountName]) {
	                                    chatCustomerAndAccount = event.detail.event.data.inData[mca.SystemToken.contactName] + ',' + event.detail.event.data.inData[mca.SystemToken.accountName];
	                                }
	                                else {
	                                    chatCustomerAndAccount = event.detail.event.data.inData[mca.SystemToken.contactName];
	                                }
	                            }
	                            if (event.detail.event.data.inData[mca.SystemToken.queueName]) {
	                                newNotificationEvent.notificationSubtitle = event.detail.event.data.inData[mca.SystemToken.queueName];
	                                chatQueueName = event.detail.event.data.inData[mca.SystemToken.queueName];
	                            }
	                            newNotificationEvent.tooltip = chatSubject + '\n' + 'Queue: ' + chatQueueName + '\n' + 'Customer: ' + chatCustomerAndAccount;
	                        }
	                        else if (event.detail.event.data.channelType === mca.ChannelType.video) {
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                // TODO
	                                // if (event.detail.event.data.inData[mca.SystemToken.email]) {
	                                //   newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.email];
	                                // }
	                                if (event.detail.event.data.inData[mca.SystemToken.contactName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.contactName];
	                                }
	                                if (event.detail.event.data.inData[mca.SystemToken.displayName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.displayName];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (event.detail.event.data.inData[mca.SystemToken.queueName]) {
	                                newNotificationEvent.notificationSubtitle = event.detail.event.data.inData[mca.SystemToken.queueName];
	                                chatQueueName = event.detail.event.data.inData[mca.SystemToken.queueName];
	                            }
	                            if (event.detail.event.data.inData[mca.SystemToken.accountName]) {
	                                chatCustomerAndAccount = event.detail.event.data.inData[mca.SystemToken.accountName];
	                            }
	                            else if (event.detail.event.data.inData[mca.SystemToken.primaryAccountName]) {
	                                chatCustomerAndAccount = event.detail.event.data.inData[mca.SystemToken.primaryAccountName];
	                            }
	                            else {
	                                chatCustomerAndAccount = this.getMcaBundleString('unknownContact');
	                            }
	                            newNotificationEvent.tooltip = 'Queue: ' + chatQueueName + '\n' + 'Customer: ' + chatCustomerAndAccount;
	                        }
	                        else {
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationTitle === undefined
	                                || existingNotificationEvent.notificationTitle === this.getMcaBundleString('unknownContact')) {
	                                if (event.detail.event.data.inData[mca.SystemToken.contactName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.contactName];
	                                }
	                                if (event.detail.event.data.inData[mca.SystemToken.displayName]) {
	                                    newNotificationEvent.notificationTitle = event.detail.event.data.inData[mca.SystemToken.displayName];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationTitle = existingNotificationEvent.notificationTitle;
	                                newNotificationEvent.notificationIconTitle = existingNotificationEvent.notificationIconTitle;
	                            }
	                            if (existingNotificationEvent === undefined ||
	                                existingNotificationEvent.notificationSubtitle === undefined ||
	                                existingNotificationEvent.notificationSubtitle !== '') {
	                                if (event.detail.event.data.inData[mca.SystemToken.contactJobTitle]) {
	                                    newNotificationEvent.notificationSubtitle = event.detail.event.data.inData[mca.SystemToken.contactJobTitle];
	                                }
	                                if (event.detail.event.data.inData[mca.SystemToken.ani]) {
	                                    newNotificationEvent.notificationSubtitle = event.detail.event.data.inData[mca.SystemToken.ani];
	                                }
	                            }
	                            else {
	                                newNotificationEvent.notificationSubtitle = existingNotificationEvent.notificationSubtitle;
	                            }
	                        }
	                    }
	                    else {
	                        newNotificationEvent.notificationTitle = this.getMcaBundleString('unknownContact');
	                        newNotificationEvent.notificationSubtitle = '';
	                    }
	                    // GET THE Non-Real-Time Notification Details which are passed in the Notification Event:
	                    if (data.notificationType) {
	                        newNotificationEvent.notificationType = data.notificationType;
	                    }
	                    if (data.notificationCategory) {
	                        newNotificationEvent.notificationCategory = data.notificationCategory;
	                    }
	                    else {
	                        newNotificationEvent.notificationCategory = event.detail.event.data.channelType;
	                    }
	                    if (newNotificationEvent.notificationCategory === 'SVC_SERVICE_REQUESTS' ||
	                        newNotificationEvent.notificationCategory === 'SVC_SERVICE_REQUESTS_HRHD' ||
	                        newNotificationEvent.notificationCategory === 'SVC_SERVICE_REQUESTS_ISR') {
	                        newNotificationEvent.notificationType = mca.NotificationType.nonRealtime;
	                    }
	                    if (data.notificationTitle) {
	                        newNotificationEvent.notificationTitle = data.notificationTitle;
	                    }
	                    if (data.notificationIconTitle) {
	                        newNotificationEvent.notificationIconTitle = data.notificationIconTitle;
	                    }
	                    if (data.notificationSubtitle) {
	                        newNotificationEvent.notificationSubtitle = data.notificationSubtitle;
	                    }
	                    if (posInArray !== -1) {
	                        this.notificationsList.splice(posInArray, 1);
	                        this.notificationsList.push(newNotificationEvent);
	                    }
	                    else {
	                        this.notificationsList.push(newNotificationEvent);
	                    }
	                }
	                else {
	                    this.notificationsList.push(newNotificationEvent);
	                }
	                // TODO
	                const webNotification = {
	                    engagementId: newNotificationEvent.notificationEventId,
	                    icon: this.getWebNotificationIcon(event.detail.event),
	                    initialDisplay: (event.detail.response) ? false : true,
	                    message: newNotificationEvent.notificationSubtitle,
	                    title: newNotificationEvent.notificationTitle
	                };
	                this.winMgr.displayWebNotification(webNotification);
	                if (this.isNotificationAlreadyProcessed(event.detail.event.data.engagementId)) {
	                    logger.warn(this.pre + 'Notification is already processed');
	                    return;
	                }
	                // show notification 
	                logger.info(`${this.pre} notificationEventListener ==> notificationCallback: notifyOn: ${JSON.stringify(newNotificationEvent)}`);
	                this.adfModuleCallback('notification', newNotificationEvent);
	                this.updateNotifMap(mca.McaEventType.addNotifToMap, newNotificationEvent);
	            }
	            else if (event.type === mca.McaEventType.notifyOff) {
	                if (event.detail.event && event.detail.event.data) {
	                    const notificationEventId = event.detail.event.data.eventId;
	                    const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === notificationEventId);
	                    if (posInArray !== -1) {
	                        const delNotifs = this.notificationsList.splice(posInArray, 1);
	                        // hide notification 
	                        delNotifs[0].method = event.detail.event.method;
	                        logger.info(`${this.pre} notificationEventListener ==> notificationCallback: notifyOff: ${JSON.stringify(delNotifs[0])}`);
	                        this.adfModuleCallback('notification', delNotifs[0]);
	                    }
	                    this.updateNotifMap(mca.McaEventType.removeNotifToMap, notificationEventId);
	                    if (this.notificationsList().length === 0) {
	                        this.winMgr.closeWebNotification(event.detail.event.data.eventId);
	                    }
	                }
	            }
	            // re-raise the event
	            const detail = event.detail;
	            detail.invokeCommand = this.invokeCommand;
	            const formattedEvent = { bubbles: true, cancelable: false, detail };
	            const reraiseEvent = new CustomEvent(event.type, formattedEvent);
	            this.dispatchClientEvent(reraiseEvent);
	        });
	        this.addNotificationAssignType = (newNotificationEvent, assignmentType) => {
	            var _a;
	            const mercuryInfo = (_a = this.userConfigurations) === null || _a === void 0 ? void 0 : _a.mercuryInfo;
	            if (mercuryInfo) {
	                const forceAssignNotificationTimeout = mercuryInfo.forceAssignNotificationTimeout;
	                if (forceAssignNotificationTimeout > 0 && (assignmentType === mca_mercury_copy_1.AssignmentType.LEAD || mercuryInfo.forceAssignForTransferAndConferenceEnabled)) {
	                    newNotificationEvent.assignType = mca.NotificationAssignType.FORCED;
	                    if (forceAssignNotificationTimeout < newNotificationEvent.timeoutValue) {
	                        newNotificationEvent.timeoutValue = forceAssignNotificationTimeout;
	                    }
	                }
	                else if (mercuryInfo.autoAssignEnabled) {
	                    newNotificationEvent.assignType = mca.NotificationAssignType.AUTO;
	                }
	            }
	        };
	        this.notificationInvokeCommandCallback = (response) => {
	            logger.info(this.pre + 'Invoke Command from Notification callback response: ', response);
	        };
	        this.updateNotifMap = (type, notif) => {
	            logger.info(this.pre + 'updateNotifMap ');
	            if (type === mca.McaEventType.addNotifToMap) {
	                const itemInMap = this.notifMgr.getNotification(notif.notificationEventId);
	                if (!itemInMap) {
	                    // add this notif only if it does not exist in cacheMap
	                    this.notifMgr.addNotification(notif);
	                }
	                else {
	                    // fix SVC-171774  wrong notification information saved in notification manager
	                    if (itemInMap.notificationTitle &&
	                        itemInMap.notificationTitle !== notif.notificationTitle &&
	                        itemInMap.notificationTitle.startsWith('Unknown') // ????
	                    ) {
	                        this.notifMgr.addNotification(notif);
	                    }
	                }
	            }
	            else if (type === mca.McaEventType.removeNotifToMap) {
	                this.notifMgr.removeNotification(notif);
	            }
	        };
	        this.updateNotifListEventListener = (event) => {
	            if (event && event.type && event.type === mca.McaEventType.addNotifOnUi) {
	                if (event.detail && event.detail.item) {
	                    const item = event.detail.item;
	                    logger.info(this.pre + 'updateNotifListEventListener, add notification with subject ' + item.notificationTitle);
	                    const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === item.notificationEventId);
	                    if (posInArray !== -1) {
	                        this.notificationsList.splice(posInArray, 1);
	                    }
	                    this.notificationsList.push(item);
	                    this.adfModuleCallback('notification', item);
	                }
	            }
	            else if (event && event.type && event.type === mca.McaEventType.removeNotifOnUi) {
	                if (event.detail && event.detail.id) {
	                    logger.info(this.pre + 'updateNotifListEventListener, remove notification with id ' + event.detail.id);
	                    const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === event.detail.id);
	                    if (posInArray !== -1) {
	                        const delNotifs = this.notificationsList.splice(posInArray, 1);
	                        logger.info(this.pre + 'updateNotifListEventListener, notification to remove ' + JSON.stringify(delNotifs[0]));
	                        if (event.detail.event && event.detail.event.method) {
	                            delNotifs[0].method = event.detail.event.method;
	                        }
	                        else {
	                            delNotifs[0].method = mca.McaMethod.startComm;
	                        }
	                        this.adfModuleCallback('notification', delNotifs[0]);
	                    }
	                }
	                else if (event.detail.type && event.detail.channelIdentifier && event.detail.type === 'ASSIGNMENT_INVITATION_CANCELLED') {
	                    logger.info(this.pre + 'updateNotifListEventListener for chat cancel, remove notification with id ' + event.detail.channelIdentifier);
	                    const posInArray = this.notificationsList().findIndex((value) => value.notificationEventId === event.detail.channelIdentifier);
	                    if (posInArray !== -1) {
	                        const delNotifs = this.notificationsList.splice(posInArray, 1);
	                        delNotifs[0].method = event.detail.event.method;
	                        this.adfModuleCallback('notification', delNotifs[0]);
	                    }
	                }
	            }
	        };
	        this.unstableConnectionEventListener = (event) => {
	            logger.info(this.pre + '==> unstableConnectionEventListener: ');
	            this.adfModuleCallback('chatConnStatus', {
	                severity: 'error',
	                summary: this.getMcaBundleString('communicationError')
	            });
	        };
	        this.connectionLostEventListener = (event) => {
	            logger.info(this.pre + '==> connectionLostEventListener: ');
	            let summary = this.getMcaBundleString('communicationError');
	            if (event && event.detail && event.detail.reason) {
	                if (event.detail.reason === mca_mercury_copy_1.ErrorReason.CONFLICTING_SESSION) {
	                    summary = this.getMcaBundleString('connectionErrorDueToAnotherLoginDetail');
	                }
	            }
	            this.adfModuleCallback('chatConnStatus', {
	                severity: 'error',
	                summary
	            });
	        };
	        this.connectionEstablishedEventListener = (event) => {
	            logger.info(this.pre + '==> connectionEstablishedEventListener: ');
	            this.adfModuleCallback('chatConnStatus', {
	                severity: 'confirmation',
	                summary: this.getMcaBundleString('communicationEstablished')
	            });
	        };
	        this.reloadChatConfigEventListener = (event) => {
	            logger.info(this.pre + '==> reloadChatConfigEventListener: ');
	            // TODO
	            // if (this.chatConnectionErrorDisplayed) {
	            //   this.chatConnectionErrorDisplayed = false;
	            //   this.connectionApplicationMessages.removeAll();
	            // }
	            // this.chatConnectionErrorAcknowledge = false;
	            this.fetchUserConfig();
	        };
	        this.unloadEventListener = (event) => {
	            this.dispatchWindowEvent(mca.McaEventType.unloadHandling, event);
	        };
	        this.dispatchWindowEvent = (eventType, details) => {
	            const detail = details;
	            const formattedEvent = {
	                bubbles: true,
	                cancelable: false,
	                detail
	            };
	            const ne = new CustomEvent(eventType, formattedEvent);
	            window.dispatchEvent(ne);
	        };
	        this.invokeCommand = (command) => {
	            if (!command) {
	                return;
	            }
	            logger.info(`${this.pre} invokeCommand ==> ${command}`);
	            if (command.inData && command.inData.previewMode === 'MANUAL') {
	                logger.warn(this.pre + 'INVOKE command register manual call not processed in ADF presence');
	                // TODO
	                // logger.info(this.pre + 'INVOKE command register manual call: ', command);
	                // this.saveLogCall(command);
	            }
	            else if (command.target && command.target === mca.EventSource.mercury) {
	                this.mercuryReadyPromise.then(() => {
	                    if (this.mercuryAdapter) {
	                        this.mercuryAdapter.invokeCommand(command);
	                    }
	                    else {
	                        logger.warn(`${this.pre} Command targeted for Mercury but, Mercury not loaded`);
	                    }
	                });
	            }
	            else if (command.target && command.target === mca.EventSource.toolbar) {
	                if (this.toolbarContainer) {
	                    this.toolbarContainer.invokeCommand(command);
	                    if (command.method === mca.McaMethod.onInteractionCmd && command.command === mca.InteractionCommandName.init_transfer) {
	                        this.toolbarContainer.showToolbar();
	                    }
	                }
	                else {
	                    logger.warn(`${this.pre} Command targeted for Toolbar but, Toolbar not loaded`);
	                }
	            }
	            else {
	                if (this.toolbarContainer) {
	                    this.toolbarContainer.invokeCommand(command);
	                    if (command.method === mca.McaMethod.onInteractionCmd && command.command === mca.InteractionCommandName.init_transfer) {
	                        this.toolbarContainer.showToolbar();
	                    }
	                }
	                else {
	                    logger.info(`${this.pre} Toolbar Container not available to handle command: ${command}`);
	                }
	                this.mercuryReadyPromise.then(() => {
	                    if (this.mercuryAdapter) {
	                        this.mercuryAdapter.invokeCommand(command);
	                    }
	                    else {
	                        logger.info(`${this.pre} Mercury not available to handle command: ${command}`);
	                    }
	                });
	            }
	        };
	        this.mcaEventListener = (event) => {
	            logger.info(this.pre + 'mcaEventListener ==> ');
	            if (!event || !event.detail) {
	                return;
	            }
	            const mcaEvent = event.detail.event;
	            if (!mcaEvent || !mcaEvent.data) {
	                return;
	            }
	            if (mcaEvent.data.reason && mcaEvent.data.reason === mca.CloseCommReason.reject) {
	                mcaEvent.data.inData;
	                if (!mcaEvent.data.inData) {
	                    return;
	                }
	            }
	            const mcaResponse = event.detail.response;
	            if (!mcaResponse) {
	                return; // For now we only care about events with a response, this may change
	            }
	            if (!mcaEvent.previewMode || mcaEvent.previewMode !== 'MANUAL') {
	                const newEvent = this.convertMcaEvent(mcaEvent, mcaResponse);
	                if (newEvent) {
	                    switch (newEvent.type) {
	                                            }
	                    this.dispatchClientEvent(newEvent);
	                }
	                if (mcaEvent.method) {
	                    switch (mcaEvent.method) {
	                        case mca.McaMethod.startComm:
	                            // FOR NOW: do post processing for startComm because the async processing is blocking
	                            // window switching on closeComm...
	                            if (newEvent && newEvent.detail.isUnknownCallerPage && newEvent.detail.mcaRefEvent &&
	                                newEvent.detail.mcaRefEvent.data && this.checkClickToDialFromHere(newEvent.detail.mcaRefEvent.data.inData)) {
	                                logger.info(this.pre + 'Skipping startComm postProcessing for navigation to Unknown_Contact page');
	                                break;
	                            }
	                            this.postProcessMcaEvent(mcaEvent, mcaResponse);
	                            break;
	                    }
	                }
	            }
	        };
	        this.checkClickToDialFromHere = (inData) => {
	            let retVal = false;
	            if (inData && inData[mca.SystemToken.window] && inData[mca.SystemToken.direction]) {
	                if (inData[mca.SystemToken.direction] === mca.DirectionToken.outbound) {
	                    if (inData[mca.SystemToken.window] === window.name) {
	                        retVal = true;
	                    }
	                }
	            }
	            return retVal;
	        };
	        this.postProcessMcaEvent = (mcaEvent, mcaResponse) => __awaiter(this, void 0, void 0, function* () {
	            if (!mcaEvent) {
	                return;
	            }
	            let eventName;
	            let detail;
	            switch (mcaEvent.method) {
	                case mca.McaMethod.startComm:
	                    eventName = mca.McaEventType.startComm;
	                    detail = this.getStartCommData(mcaEvent, mcaResponse);
	                    if (detail) {
	                        // Check if this startCommEvent is getting triggered for a WrapUp Refresh
	                        if (mcaResponse && mcaResponse.actions) {
	                            for (const action of mcaResponse.actions) {
	                                if (action && action.name) {
	                                    if (action.name === mca.ActionName.WrapUp) {
	                                        detail.callback = this.wrapUpEventCallback;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    break;
	                case mca.McaMethod.previewComm:
	                    eventName = mca.McaEventType.previewComm;
	                    detail = { event: mcaEvent, response: mcaResponse, invokeCommand: this.invokeCommand };
	                    break;
	            }
	            if (eventName && detail) {
	                const formattedEvent = { bubbles: true, cancelable: false, detail };
	                const newEvent = new CustomEvent(eventName, formattedEvent);
	                this.dispatchClientEvent(newEvent);
	            }
	        });
	        this.getScreenPopData = (event, response) => {
	            if (!event || !response) {
	                logger.info(this.pre + 'Response missing, No ScreenPop Action required for this Event');
	                return;
	            }
	            const inData = event.data.inData;
	            let outData = {};
	            const appClassification = event.data.appClassification;
	            let doRedwoodScreenPop = false;
	            let screenPopFailOverHandling = false;
	            if (inData && inData[mca.SystemToken.uiTypeCd]) {
	                const screenPopType = inData[mca.SystemToken.uiTypeCd];
	                if (screenPopType === mca.UiTypeToken.redwood) {
	                    doRedwoodScreenPop = true;
	                }
	                else {
	                    doRedwoodScreenPop = false;
	                }
	            }
	            if (inData && inData[mca.SystemToken.spFailOverHandled] === 'Y') {
	                // Screen Pop Failure Handle UpdateComm returns
	                // Screen Pop Failure Handling must use Screen Pop Map
	                doRedwoodScreenPop = false;
	                screenPopFailOverHandling = true;
	            }
	            outData = response.outData;
	            let objectType = response.objectType;
	            let pageKey;
	            if (screenPopFailOverHandling) {
	                pageKey = inData[mca.SystemToken.spFailOverObjId];
	                objectType = inData[mca.SystemToken.spFailOverObject];
	            }
	            else if (inData[mca.Constants.PAGE_KEY]) {
	                pageKey = inData[mca.Constants.PAGE_KEY];
	            }
	            else if (inData[mca.SystemToken.leadId]) {
	                pageKey = inData[mca.SystemToken.leadId].toString();
	            }
	            else if (inData[mca.SystemToken.contactId]) {
	                pageKey = inData[mca.SystemToken.contactId].toString();
	            }
	            else if (inData[mca.SystemToken.ani]) {
	                pageKey = inData[mca.SystemToken.ani];
	            }
	            else if (inData[mca.SystemToken.email]) {
	                pageKey = inData[mca.SystemToken.email];
	            }
	            else if (inData[mca.SystemToken.srId]) {
	                pageKey = inData[mca.SystemToken.srId].toString();
	            }
	            else if (inData[mca.SystemToken.objectId]) {
	                pageKey = inData[mca.SystemToken.objectId].toString();
	            }
	            if (!pageKey) {
	                pageKey = event.data.engagementId;
	            }
	            const detail = {
	                callback: this.screenPopEventCallback,
	                crossAppNaviDebugUrl: false,
	                crossAppNaviEnabled: true,
	                crossAppNaviFaEndpoint: null,
	                crossAppNaviLaunchAppName: null,
	                crossAppNaviTargetAppName: null,
	                crossAppNaviTargetAppPath: null,
	                displayMode: response.screenPopMode,
	                engagementId: event.data.engagementId,
	                entity: null,
	                isUnknownCallerPage: false,
	                ktv: null,
	                launchedFromUnknownCaller: false,
	                mcaRefEvent: event,
	                pageDescription: 'pageDescription',
	                pageIcon: null,
	                pageKey,
	                pageName: null,
	                pageOptions: {},
	                pageParams: null,
	                pagePath: '',
	                pageTitle: 'pageTitle',
	                paramMapUsed: false,
	                redwoodScreenPopEnabled: doRedwoodScreenPop,
	                screenPopFailureErrorCode: null,
	                screenPopFailureErrorMessage: null,
	                screenPopFailureHandling: false,
	                screenPopId: 'screenPopId',
	                useDefaultScreenPopData: !doRedwoodScreenPop,
	                uuid: event.uuid
	            };
	            let screenPopAction;
	            let screenPopFailureAction;
	            let searchContactAction;
	            let launchCreateAction;
	            const engagement = this.engMgr.getEngagement(event.data.engagementId);
	            if (screenPopFailOverHandling) {
	                // Create Screen Pop Action for Failure Handling
	                const spdata = { ScreenPopPageLabel: inData[mca.SystemToken.spFailOverObjId],
	                    ScreenPopPageName: inData[mca.SystemToken.spFailOverPage],
	                    objectId: inData[mca.SystemToken.spFailOverObjId] };
	                const spAction = { name: mca.ActionName.ScreenPop, data: spdata };
	                screenPopAction = spAction;
	            }
	            else if (response.actions && response.actions.length > 0) {
	                for (let i = 0; i < response.actions.length; i++) {
	                    const action = response.actions[i];
	                    if (!action || !action.name) {
	                        continue;
	                    }
	                    switch (action.name) {
	                        case mca.ActionName.ScreenPop:
	                            if (action.data && action.data.pageName) {
	                                // Handle Empty Data
	                                screenPopAction = action;
	                            }
	                            break;
	                        case mca.ActionName.ScreenPopFailure:
	                            screenPopFailureAction = action;
	                            break;
	                        case mca.ActionName.SearchContact:
	                            searchContactAction = action;
	                            break;
	                        case mca.ActionName.LaunchCreate:
	                            launchCreateAction = action;
	                            break;
	                    }
	                }
	            }
	            if (searchContactAction || screenPopFailureAction) {
	                // Use saved default Screen Pop Map until UnknownCaller page screen pop data can be
	                // delivered by server
	                detail.pageName = mca.Constants.UNKNOWN_PAGE;
	                detail.useDefaultScreenPopData = true;
	                detail.pageTitle = 'Identify Contact';
	                detail.tmpPageKey = event.data.engagementId;
	                detail.isUnknownCallerPage = true;
	                // detail.clientSideScreenPopEnabled = false;
	                let unknownCallerPageAction = null;
	                let unknownCallerPage = null;
	                if (engagement) {
	                    unknownCallerPageAction = this.engMgr.getUnknownCallerPageFromEngagement(engagement);
	                }
	                if (unknownCallerPageAction) {
	                    unknownCallerPage = this.getRedwoodPageInfo(unknownCallerPageAction);
	                }
	                // User REST returned unknown caller page infor if it's avaiable
	                if (unknownCallerPage && unknownCallerPage.pageName) {
	                    this.processRedwoodScreenPop(event, detail, unknownCallerPage);
	                }
	                if (screenPopFailureAction) {
	                    // Screen Pop Failure Handling page must change page key to
	                    // to allow the possible screen pop to the Edit_Contact or Edit_Lead page,
	                    // because pageKey created above is a valid object Id, which could be the same
	                    // as the pageKey of the Edit_xxx page.
	                    // Regular unknown caller page's pagekey does not have this problem.
	                    detail.pageKey = 'SPFH_' + detail.pageKey;
	                    detail.screenPopFailureHandling = true;
	                    let callerType = null;
	                    if (inData[mca.SystemToken.contactId] != null) {
	                        callerType = this.getMcaBundleString('contact');
	                    }
	                    else if (inData[mca.SystemToken.leadId] != null) {
	                        callerType = this.getMcaBundleString('lead');
	                    }
	                    else {
	                        // Should never be here
	                        callerType = 'Unknown';
	                    }
	                    // detail.pageTitle = 'Screen Pop Failure Handling';
	                    detail.pageTitle = callerType + ' ' + inData[mca.SystemToken.displayName];
	                    const data = screenPopFailureAction.data;
	                    detail.screenPopFailureErrorCode = data.errorCode;
	                    detail.screenPopFailureErrorMessage = data.errorMessage;
	                }
	                else {
	                    // Need to use page key with unknowncaller signature
	                    if (!(detail.pageKey && detail.pageKey.includes(mca.Constants.PAGE_KEY_TIME_DELIM))) {
	                        detail.pageKey = 'UnknownCaller_' + detail.pageKey;
	                    }
	                }
	            }
	            else if (launchCreateAction) {
	                // Use saved default Screen Pop Map until UnknownCaller page screen pop data can be
	                // delivered by server
	                detail.useDefaultScreenPopData = true;
	                let createContactAction = null;
	                let createLeadAction = null;
	                let createContactPage = null;
	                let createLeadPage = null;
	                let createPage = null;
	                if (engagement) {
	                    createContactAction = this.engMgr.getCreateContactPageFromEngagement(engagement);
	                    createLeadAction = this.engMgr.getCreateLeadPageFromEngagement(engagement);
	                }
	                if (createContactAction) {
	                    createContactPage = this.getRedwoodPageInfo(createContactAction);
	                }
	                if (createLeadAction) {
	                    createLeadPage = this.getRedwoodPageInfo(createLeadAction);
	                }
	                if (objectType === 'Lead') {
	                    detail.pageName = 'Create_Lead';
	                    detail.pageKey = 'Create_Lead_' + detail.pageKey;
	                    createPage = createLeadPage;
	                }
	                else if (objectType === 'Account') {
	                    detail.pageName = 'Create_Account';
	                    detail.pageKey = 'Create_Account_' + detail.pageKey;
	                    createPage = createContactPage;
	                }
	                else {
	                    // by default objectType === 'Contact'
	                    detail.pageName = 'Create_Contact';
	                    detail.pageKey = 'Create_Contact_' + detail.pageKey;
	                    createPage = createContactPage;
	                }
	                detail.launchedFromUnknownCaller = true;
	                if (createPage && createPage.pageName) {
	                    // Use Create XXX Page info returned from REST call if it's availabel
	                    this.processRedwoodScreenPop(event, detail, createPage);
	                }
	                detail.pageTitle = '';
	                detail.tmpPageKey = event.data.engagementId;
	                // detail.clientSideScreenPopEnabled = false;
	            }
	            else if (screenPopAction) {
	                // 20200804 Handle Screen Pop Data here
	                if (screenPopAction.data) {
	                    const data = screenPopAction.data;
	                    const items = Object.keys(data);
	                    let paramString = null;
	                    detail.crossAppNaviLaunchAppName = detail.webApp;
	                    for (let i = 0; i < items.length; i++) {
	                        if (doRedwoodScreenPop) {
	                            console.log(this.pre + ' Redwood Screen Pop is enabled.');
	                            if (items[i] === 'pageName') {
	                                detail.pageName = data[items[i]];
	                            }
	                            else if (items[i] === 'pageLabel') {
	                                detail.pageTitle = data[items[i]];
	                            }
	                            else if (items[i] === 'faEndPoint') {
	                                detail.crossAppNaviFaEndpoint = data[items[i]];
	                            }
	                            else if (items[i] === 'pagePath') {
	                                // Redwood Screen Pop path includes application name and
	                                // page path, split them into app name and path to fix existing processing logic
	                                const redwoodPath = data[items[i]];
	                                if (redwoodPath !== null) {
	                                    // const firstChar: string = redwoodPath.charAt(0);
	                                    // if (firstChar === '/') {
	                                    // strip first character if it's '/'
	                                    //  redwoodPath = redwoodPath.substring(1);
	                                    // }
	                                    // find '/' after applcation name
	                                    // const index: number = redwoodPath.indexOf('/');
	                                    // detail.crossAppNaviTargetAppPath = redwoodPath.substring(0, index);
	                                    // detail.pagePath = redwoodPath.substring(index);
	                                    //  Fix bug 33328108: application name in screen pop path was stripped here before
	                                    //                    need to restore the application name in screen pop path after
	                                    //                    constructurl changes in windonw manager
	                                    detail.pagePath = redwoodPath;
	                                }
	                                else {
	                                    detail.crossAppNaviTargetAppPath = null;
	                                    detail.pagePath = null;
	                                }
	                            }
	                            else if (items[i] === 'pageKey') {
	                                const tempKey = data[items[i]];
	                                // 3/16/23 - fix missing pageKey Token - noticed this while testing ContactVerified following Unknown Caller Flow
	                                let pkTokenData = inData;
	                                const pkKeys = Object.keys(outData);
	                                if (pkKeys.length > 0) {
	                                    pkTokenData = outData;
	                                }
	                                const formattedPageKey = this.substitutePageKeyTokens(tempKey, pkTokenData);
	                                if (formattedPageKey !== null && formattedPageKey !== '') {
	                                    // User Redwood pageKey only when valid pageKey is created after replacing tokens.
	                                    // if redwood pageKey format or tokens contain errors,  formatedPageKey returns ''
	                                    detail.pageKey = formattedPageKey;
	                                }
	                            }
	                            else if (items[i] === 'entity') {
	                                detail.entity = data[items[i]];
	                            }
	                            else if (items[i] === 'parameters') {
	                                paramString = '?' + data[items[i]];
	                            }
	                            else if (items[i] === 'paramMapUsed') {
	                                if (items[i] === 'Y' || items[i] === 'y') {
	                                    detail.paramMapUsed = true;
	                                }
	                                else {
	                                    detail.paramMapUsed = false;
	                                }
	                            }
	                        }
	                        else {
	                            if (items[i] === 'ScreenPopPageName') {
	                                detail.pageName = data[items[i]];
	                            }
	                            else if (items[i] === 'ScreenPopPageLabel') {
	                                detail.pageTitle = data[items[i]];
	                            }
	                            else if (items[i] === 'objectId') {
	                                detail.objectId = data[items[i]];
	                            }
	                        }
	                    }
	                    if (detail.pagePath && paramString) {
	                        detail.pagePath = detail.pagePath + paramString;
	                    }
	                    // Use the pageName + the objectId to form a unique pageKey for window mgmt
	                    if (detail.pageName && detail.objectId) {
	                        detail.pageKey = detail.pageName + '_' + detail.objectId;
	                    }
	                }
	            }
	            else {
	                detail.pageKey = null;
	                // 02-25-20 - Now Returning ScreenPops for Outbound Calls so, we can set the Window Context correctly
	                if (this.checkClickToDialFromHere(inData)) {
	                    logger.info(this.pre + 'Getting pageKey for Outbound Call...');
	                    detail.displayMode = mca.PageDisplayMode.None;
	                    detail.pageKey = this.winMgr.getCurrentPageKey();
	                }
	                else {
	                    if (inData && inData[mca.SystemToken.window] && inData[mca.SystemToken.direction]) {
	                        if (inData[mca.SystemToken.direction] === mca.DirectionToken.outbound) {
	                            const page = this.winMgr.getCurrentScreenPop();
	                            if (page && page.isUnknownCallerPage) {
	                                if (this.winMgr.isCurrentUnknownCallerPage(event)) {
	                                    // For ClickToDial Case where we have opened the Unknown_Contact page ensure we
	                                    // always close this window and go to the window that initiated the outbound call
	                                    logger.info(this.pre + 'Getting pageKey for ClickToDial Window...');
	                                    detail.displayMode = mca.PageDisplayMode.CloseWindow;
	                                    detail.windowName = inData[mca.SystemToken.window];
	                                    detail.pageKey = this.winMgr.getPageKeyForWindow(inData[mca.SystemToken.window]);
	                                }
	                            }
	                        }
	                    }
	                    else if (inData[mca.SystemToken.direction] === mca.DirectionToken.outbound) {
	                        logger.warn(this.pre + 'Externally Originated Outbound Call Case Unhandled!');
	                    }
	                }
	                if (!detail.pageKey) {
	                    logger.info(this.pre + 'No ScreenPop Action required for this Event');
	                    return; // 11-08-19 now returning null
	                }
	            }
	            const pageParams = {};
	            if (event.data.channel && event.data.channel !== 'ORA_SVC_NONE') {
	                // NOTE: For Channel Communications we override the configured pageTitle a.k.a Tab Title
	                // in order to identify the person we are in communications with
	                if (outData[mca.SystemToken.contactName]) {
	                    detail.pageTitle = outData[mca.SystemToken.contactName];
	                }
	                else if (outData[mca.SystemToken.ani]) {
	                    detail.pageTitle = outData[mca.SystemToken.ani];
	                }
	                else if (outData[mca.SystemToken.email]) {
	                    detail.pageTitle = outData[mca.SystemToken.email];
	                }
	            }
	            // 11/10/20 - HZH test and add "launchedFrom=unknownCaller" page variable
	            if (detail.launchedFromUnknownCaller) {
	                pageParams[mca.Constants.LAUNCHED_FROM] = mca.Constants.UNKNOWN_CALLER;
	                detail.pageParams = pageParams;
	            }
	            // 06/19/20 - sjm - No longer appending all the inData to the detail.pageParams
	            // if (detail.pageName && detail.keyTokenVal) {
	            //  const hostname: string = window.location.hostname;
	            //   detail.pageKey = detail.pageName + '_' + detail.keyTokenVal + '_' + hostname;
	            // }
	            if (detail.isUnknownCallerPage) {
	                // Need to Pass all the inData to the detail.pageParams for unknown page
	                pageParams[mca.Constants.LAUNCH_APP_NAME] = detail.crossAppNaviLaunchAppName;
	                pageParams[mca.Constants.APP_CLASSIFICATION] = appClassification;
	                const keys = Object.keys(inData);
	                for (let i = 0; i < keys.length; i++) {
	                    if (!inData[keys[i]]) {
	                        continue; // skip null values
	                    }
	                    pageParams[keys[i]] = inData[keys[i]];
	                }
	                detail.pageParams = pageParams;
	            }
	            // Add 03-11-21 to prevent screen popping to a window with an active engagement
	            if (detail.pageKey) {
	                const replacementKey = this.winMgr.getReplacementPageKey(detail.pageKey, event);
	                if (replacementKey) {
	                    detail.pageKey = replacementKey;
	                }
	            }
	            return detail;
	        };
	        this.screenPopEventCallback = (originalEvent, result) => {
	            logger.info(this.pre + 'screenPopEventCallback invoked');
	            const outData = {};
	            // Check if result is for Contact_Picker
	            if (originalEvent && originalEvent.detail) {
	                if (originalEvent.detail.pageName === 'Contact_Picker') {
	                    logger.info(this.pre + 'Checking Contact Search Result ...');
	                }
	                else {
	                    return;
	                }
	            }
	            else {
	                logger.error(this.pre + "screenPopEventListener didn't invoke callback with a valid parameter 1: originalEvent!");
	                return;
	            }
	            if (result && result.searchResult) {
	                if (!result.searchResult.PartyId) {
	                    logger.info(this.pre + 'Contact Search result.searchResult is missing partyId!');
	                    return;
	                }
	                outData[mca.SystemToken.displayName] = result.searchResult.PartyName;
	                outData[mca.SystemToken.contactName] = result.searchResult.PartyName;
	                outData[mca.SystemToken.contactId] = result.searchResult.PartyId;
	                logger.info(this.pre + 'Contact Search returned:  partyId: ' + outData[mca.SystemToken.contactId]);
	            }
	            else {
	                logger.error(this.pre + "Contact Search didn't invoke callback with a valid parameter 2: missing result.searchResult!!!");
	                return;
	            }
	            const messageEvent = {};
	            messageEvent.result = result.result;
	            messageEvent.outData = outData;
	            messageEvent.eventId = originalEvent.detail.engagementId;
	            messageEvent.uuid = originalEvent.detail.uuid;
	            messageEvent.method = mca.McaMethod.startComm;
	            messageEvent.eventSource = originalEvent.eventSource;
	            // Update the Toolbar UI w/ Identified Contact
	            this.sendProviderResponse(messageEvent);
	            // Follow Up with Real Screen Pop
	            const refEvent = originalEvent.detail.mcaRefEvent;
	            const inData = refEvent.data.inData;
	            const revisedData = this.mergeData(inData, outData);
	            refEvent.data.inData = revisedData;
	            const clientEvent = this.convertMcaEvent(refEvent, messageEvent);
	            this.dispatchClientEvent(clientEvent);
	        };
	        this.mergeData = (inData, outData) => {
	            const merged = {};
	            if (inData) {
	                for (const key of Object.keys(inData)) {
	                    merged[key] = inData[key];
	                }
	            }
	            if (outData) {
	                for (const key of Object.keys(outData)) {
	                    merged[key] = outData[key];
	                }
	            }
	            return merged;
	        };
	        this.sendProviderResponse = (messageEvent) => {
	            if (messageEvent && messageEvent.eventSource === mca.EventSource.mercury) {
	                this.mercuryReadyPromise.then(() => {
	                    if (this.mercuryAdapter) {
	                        this.mercuryAdapter.sendProviderResponse(messageEvent);
	                    }
	                    else {
	                        logger.warn(this.pre + 'Mercury Adapter not defined for response', messageEvent);
	                    }
	                });
	            }
	            else {
	                if (this.toolbarContainer) {
	                    this.toolbarContainer.sendProviderResponse(messageEvent);
	                }
	                else {
	                    logger.warn(this.pre + 'No Toolbar defined for response', messageEvent);
	                }
	            }
	        };
	        this.getRedwoodPageInfo = (pageInfo) => {
	            let redwoodPage = null;
	            if (pageInfo && pageInfo.data) {
	                if (pageInfo.data.pagePath) {
	                    redwoodPage = new mca.McaRedwoodPage();
	                    redwoodPage.pagePath = pageInfo.data.pagePath;
	                    redwoodPage.faEndPoint = pageInfo.data.faEndPoint;
	                    redwoodPage.pageDisplayName = pageInfo.data.pageDisplayName;
	                    redwoodPage.pageKey = pageInfo.data.pageKey;
	                    redwoodPage.pageLabel = pageInfo.data.pageLabel;
	                    redwoodPage.pageName = pageInfo.data.pageName;
	                    redwoodPage.paramMapUsed = pageInfo.data.paramMapUsed;
	                    redwoodPage.parameters = pageInfo.data.parameters;
	                }
	            }
	            return redwoodPage;
	        };
	        this.processRedwoodScreenPop = (event, spDetail, pageInfo) => {
	            if (!event || !pageInfo) {
	                return spDetail;
	            }
	            const inData = event.data.inData;
	            spDetail.useDefaultScreenPopData = false;
	            spDetail.pageName = pageInfo.pageName;
	            spDetail.pageTitle = pageInfo.pageLabel;
	            spDetail.crossAppNaviFaEndpoint = pageInfo.faEndPoint;
	            spDetail.pagePath = pageInfo.pagePath;
	            const tempKey = pageInfo.pageKey;
	            const formatedPageKey = this.substitutePageKeyTokens(tempKey, inData);
	            spDetail.pageKey = formatedPageKey;
	            let pageParameters = pageInfo.parameters;
	            if (spDetail.useDefaultScreenPopData === false &&
	                spDetail.isUnknownCallerPage === true) {
	                if (pageParameters) {
	                    pageParameters = pageParameters + '&' + mca.Constants.APP_CLASSIFICATION + '=' + event.data.appClassification;
	                }
	                else {
	                    pageParameters = mca.Constants.APP_CLASSIFICATION + '=' + event.data.appClassification;
	                }
	            }
	            if (spDetail.useDefaultScreenPopData === false && spDetail.launchedFromUnknownCaller === true) {
	                // fix bug 33849537 add &launchedFrom=unknown
	                if (pageParameters) {
	                    pageParameters = pageParameters + '&' + mca.Constants.LAUNCHED_FROM + '=' + mca.Constants.UNKNOWN_CALLER;
	                }
	                else {
	                    pageParameters = mca.Constants.LAUNCHED_FROM + '=' + mca.Constants.UNKNOWN_CALLER;
	                }
	            }
	            if (pageParameters) {
	                spDetail.pagePath = spDetail.pagePath + '?' + pageParameters;
	            }
	            spDetail.paramMapUsed = (pageInfo.paramMapUsed === 'true' ? true : false);
	            return spDetail;
	        };
	        this.substitutePageKeyTokens = (pageKey, inData) => {
	            let finalPageKey = '';
	            if (pageKey) {
	                if (pageKey.includes(mca.Constants.PAGE_KEY_TIME_DELIM)) {
	                    // The pageKey has already been substituted and made unique
	                    return pageKey;
	                }
	                let tempPageKey = '';
	                const qTokenPos = pageKey.indexOf('$');
	                if (qTokenPos < 0) {
	                    // Token is not found, return null so that MCA does not used page key returned in redwork Screep  pop
	                    return finalPageKey;
	                }
	                const paramSections = pageKey.split('$');
	                for (let i = 0; i <= Math.round(paramSections.length / 2); i++) {
	                    const nonTokenPart = paramSections[i * 2 + 0];
	                    if (!nonTokenPart || nonTokenPart === '') {
	                        // End of pageKey
	                        break;
	                    }
	                    const paramToken = paramSections[i * 2 + 1];
	                    if (inData[paramToken]) {
	                        tempPageKey += nonTokenPart + inData[paramToken];
	                    }
	                    else {
	                        // if needed token is not found in inData, return null so that MCA does not used page key returned in redwork Screep  pop
	                        // return finalPageKey;
	                        tempPageKey += nonTokenPart;
	                    }
	                }
	                if (tempPageKey != null) {
	                    // if blanks are found, substitute all blanks with "_"
	                    tempPageKey = tempPageKey.replace(/ /g, '_');
	                }
	                finalPageKey = tempPageKey;
	            }
	            return finalPageKey;
	        };
	        this.getWrapupDetail = (event, response) => {
	            if (!response || !event) {
	                logger.warn(this.pre + 'Ignoring WrapUp, Response is Missing!!!');
	                return null;
	            }
	            const engagement = this.engMgr.getEngagement(event.data.engagementId);
	            let interactionId = '<MISSING>';
	            if (!engagement) {
	                logger.warn(this.pre + 'No Engagement found for getWrapupDetail');
	            }
	            else {
	                interactionId = engagement.interactionId;
	            }
	            let detail;
	            // If the WrapUp Action is set on the response then, send a WrapUpEvent; Otherwise, send an EndCommEvent
	            if (response.actions) {
	                for (const action of response.actions) {
	                    if (action && action.name) {
	                        if (action.name === mca.ActionName.WrapUp) {
	                            detail = {
	                                callback: this.wrapUpEventCallback,
	                                enableTimeOut: false,
	                                engagementId: event.data.engagementId,
	                                interactionId,
	                                mcaRefEvent: event,
	                                reason: mca.CloseCommReason.wrapup,
	                                timeoutSecs: 0
	                            };
	                        }
	                        else if (action.name === mca.ActionName.EndCommunication) {
	                            detail = {
	                                callback: this.wrapUpEventCallback,
	                                enableTimeOut: false,
	                                engagementId: event.data.engagementId,
	                                interactionId,
	                                mcaRefEvent: event,
	                                reason: mca.CloseCommReason.end,
	                                timeoutSecs: 0
	                            };
	                        }
	                    }
	                }
	            }
	            if (!detail) {
	                logger.info(this.pre + 'WrapUp Action Missing, firing EndComm instead', event);
	                let reason = mca.CloseCommReason.end;
	                if (event.data.reason) {
	                    reason = event.data.reason; // Use the Provider Reason if Available
	                }
	                let errorCode = null;
	                let errorMsg = null;
	                if (event.data.errorCode) {
	                    reason = mca.CloseCommReason.error;
	                    errorCode = event.data.errorCode;
	                }
	                if (event.data.errorMsg) {
	                    errorMsg = event.data.errorMsg;
	                }
	                detail = {
	                    callback: this.wrapUpEventCallback,
	                    engagementId: event.data.engagementId,
	                    errorCode,
	                    errorMessage: errorMsg,
	                    interactionId,
	                    mcaRefEvent: event,
	                    reason
	                };
	            }
	            return detail;
	        };
	        this.wrapUpEventCallback = (originalEvent, result) => {
	            logger.info(this.pre + 'wrapUpEventCallback invoked');
	            if (originalEvent && originalEvent.data) {
	                const engagementId = originalEvent.data.engagementId;
	                const channelType = originalEvent.data.channelType;
	                if (engagementId && channelType) {
	                    mca_window_manager_1.WindowManager.getInstance().notifyEngagementComplete(engagementId, channelType);
	                }
	                const engagement = this.engMgr.getLatestEngagementByEventId(originalEvent.data.eventId);
	                if (engagement && !engagement.cacheControl.okForDelete()) {
	                    // Latest engagment for eventId is not in wrapup so skip firing wrapupComplete event to mercury-client otherwise it will close the channel
	                    return;
	                }
	                let outData = result.data;
	                if (!outData) {
	                    outData = {};
	                }
	                outData[mca.McaKey.updateType] = mca.UpdateType.wrapUp;
	                const response = {
	                    channel: originalEvent.data.channel,
	                    channelType: originalEvent.data.channelType,
	                    eventId: originalEvent.data.eventId,
	                    eventSource: originalEvent.eventSource,
	                    method: mca.McaMethod.onDataUpdate,
	                    origin: window.location.origin,
	                    outData,
	                    toolbarName: originalEvent.toolbarName,
	                    uuid: originalEvent.uuid
	                };
	                this.sendProviderResponse(response);
	            }
	            else {
	                logger.warn(this.pre + 'wrapUpEventCallback missing originalEvent!');
	            }
	        };
	        this.getStartCommData = (mcaEvent, mcaResponse) => {
	            const proceed = this.checkTargetedEvent(mcaEvent);
	            let detail;
	            if (proceed) {
	                if (this.winMgr.isMsiApp()) {
	                    logger.info(this.pre + 'mcaStartCommEvent ignoring duplicate check for MSI App Window engagementId: ' + mcaEvent.data.engagementId);
	                }
	                else if (this.startCommEngagementId === mcaEvent.data.engagementId) {
	                    logger.info(this.pre + 'mcaStartCommEvent has already been delivered in this window ' + this.startCommEngagementId);
	                    return;
	                }
	                else {
	                    this.startCommEngagementId = mcaEvent.data.engagementId;
	                }
	                logger.info(this.pre + 'StartComm *IS* intended for this window!');
	                // This event triggers oj-mca-engagment component display and is passed as input.
	                // we shouldn't need any addt'l events for verify, contact picker etc.
	                // this can be derived from the actions, but we may need to massage the format
	                detail = { event: mcaEvent, response: mcaResponse, invokeCommand: this.invokeCommand };
	            }
	            return detail;
	        };
	        this.checkTargetedEvent = (mcaEvent) => {
	            let retVal = this.winMgr.isCurrentEngagementWindow(mcaEvent.data.engagementId);
	            if (!retVal) {
	                // handle outbound case, where there is no screenpop
	                const engagement = this.engMgr.getEngagement(mcaEvent.data.engagementId);
	                if (engagement.windowName && engagement.windowName === window.name) {
	                    retVal = true;
	                }
	            }
	            return retVal;
	        };
	        this.getInteractionControlStateDetail = (event) => {
	            const detail = {
	                actionName: event.data.actionName,
	                data: event.data.inData,
	                engagementId: event.data.eventId,
	                newControlStates: event.data.newControlStates,
	                timestamp: event.data.timestamp
	            };
	            return detail;
	        };
	        this.getWebNotificationIcon = (event) => {
	            let iconPath = this.webNotifIcons.sr;
	            if (event.data.channelType) {
	                switch (event.data.channelType) {
	                    // svg files are NOT supported in chrome notifications
	                    case mca.ChannelType.phone:
	                        iconPath = this.webNotifIcons.phone;
	                        break;
	                    case mca.ChannelType.chat:
	                        iconPath = this.webNotifIcons.chat;
	                        break;
	                    case mca.ChannelType.none:
	                        if (event.data.notificationCategory) {
	                            switch (event.data.notificationCategory) {
	                                // TODO add cases here if diff icons needed for diff workTypes
	                                case mca.Constants.SERVICE_REQUEST: // fall thru
	                                default:
	                                    iconPath = this.webNotifIcons.sr;
	                                    break;
	                            }
	                        }
	                        break;
	                }
	            }
	            return iconPath;
	        };
	        const defaultNotifConfig = {
	            nonRealtimeAutoDismissInterval: 30,
	            nonRealtimeDesktopNotificationEnabled: true,
	            nonRealtimeNotificationEnabled: true,
	            nonRealtimeRollupThreshold: 3
	        };
	        this.notifConfig = defaultNotifConfig;
	        this.bundle = Object.assign({}, oj_mca_common_1.McaCommon.mcaCoreStrings);
	        this.sharedWorker = mca_shared_worker_1.McaSharedWorker.getInstance();
	        this.initCurrentAgentChannelStates();
	        this.mercuryReadyPromise = new Promise(resolve => {
	            this.mercuryReadyPromiseResolverRef = resolve;
	        });
	    }
	}
	exports.McaAdfMain = mcaAdfMain.McaAdfMain = McaAdfMain;

	exports.default = mcaAdfMain;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
